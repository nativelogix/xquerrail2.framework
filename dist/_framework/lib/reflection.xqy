xquery version "1.0" encoding "UTF-8";

(: This file was generated on Wed Sep 14, 2011 23:47 by REx v5.9 which is Copyright (c) 1979-2011 by Gunther Rademacher <grd@gmx.net> :)
(: REx command line: XQueryML10.ebnf -xquery -tree :)

(:~
 : The parser that was generated for the XQueryML10 grammar.
 :)
module namespace p="http://xquerrail.com/reflection";

declare default function namespace "http://www.w3.org/2005/xpath-functions";

declare namespace xdmp = "http://marklogic.com/xdmp";
declare namespace map  = "http://marklogic.com/xdmp/map";
(:Optimization for codepoints:)
declare variable $input-cp := ();
(:Left Factoring Tokens:)




(:~
 : The codepoint to charclass mapping for 7 bit codepoints.
 :)
declare variable $p:MAP0 as xs:integer+ :=
(
  62, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
  8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
  29, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 6, 34, 6, 35, 36,
  37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 30, 58, 59, 60, 6, 6
);

(:~
 : The codepoint to charclass mapping for codepoints below the surrogate block.
 :)
declare variable $p:MAP1 as xs:integer+ :=
(
  216, 291, 323, 383, 415, 908, 351, 815, 815, 447, 479, 511, 543, 575, 621, 882, 589, 681, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 713, 745, 821, 649, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 777, 809, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 259, 815,
  815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247, 247,
  247, 247, 247, 247, 247, 247, 247, 247, 853, 940, 949, 941, 941, 957, 965, 973, 979, 987, 994, 998, 1006, 1025, 1033,
  1041, 1049, 1254, 1254, 1254, 1254, 1254, 1254, 1431, 1254, 1246, 1246, 1247, 1246, 1246, 1246, 1247, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1248, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
  1254, 1254, 1254, 1254, 1246, 1246, 1246, 1246, 1246, 1246, 1362, 1247, 1245, 1244, 1246, 1246, 1246, 1246, 1246,
  1247, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1250, 1014, 1246, 1246, 1246, 1246, 1175, 1017, 1246, 1246,
  1246, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246,
  1253, 1254, 1016, 1252, 1254, 1408, 1254, 1254, 1254, 1254, 1254, 1245, 1246, 1246, 1251, 1112, 1328, 1407, 1254,
  1402, 1408, 1112, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1364, 1246, 1247, 1123, 1402, 1317, 1188, 1402,
  1408, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1402, 1404, 1254, 1254, 1254, 1408, 1254, 1254, 1254, 1387, 1223,
  1246, 1246, 1243, 1246, 1246, 1246, 1246, 1247, 1247, 1418, 1244, 1246, 1250, 1254, 1245, 1070, 1246, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1245, 1070, 1246, 1246, 1246, 1246, 1079, 1254, 1246, 1246, 1246, 1246, 1246, 1246,
  1092, 1101, 1246, 1246, 1246, 1093, 1248, 1252, 1444, 1246, 1246, 1246, 1246, 1246, 1246, 1141, 1402, 1404, 1189,
  1246, 1159, 1402, 1254, 1254, 1444, 1092, 1363, 1246, 1246, 1244, 1173, 1184, 1150, 1162, 1431, 1199, 1159, 1402,
  1252, 1254, 1210, 1233, 1363, 1246, 1246, 1244, 1062, 1184, 1165, 1162, 1254, 1221, 1432, 1402, 1231, 1254, 1444,
  1222, 1243, 1246, 1246, 1244, 1241, 1141, 1264, 1084, 1254, 1254, 1273, 1402, 1254, 1254, 1444, 1092, 1363, 1246,
  1246, 1244, 1360, 1141, 1190, 1162, 1432, 1199, 1104, 1402, 1254, 1254, 1281, 1289, 1305, 1301, 1176, 1289, 1114,
  1104, 1191, 1188, 1431, 1254, 1431, 1402, 1254, 1254, 1444, 1070, 1244, 1246, 1246, 1244, 1071, 1104, 1265, 1188,
  1433, 1254, 1104, 1402, 1254, 1254, 1281, 1070, 1244, 1246, 1246, 1244, 1071, 1104, 1265, 1188, 1433, 1256, 1104,
  1402, 1254, 1254, 1281, 1070, 1244, 1246, 1246, 1244, 1246, 1104, 1151, 1188, 1431, 1254, 1104, 1402, 1254, 1254,
  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1246,
  1246, 1246, 1246, 1248, 1254, 1246, 1246, 1246, 1246, 1247, 1254, 1245, 1246, 1246, 1246, 1246, 1247, 1313, 1407,
  1325, 1403, 1402, 1408, 1254, 1254, 1254, 1254, 1202, 1337, 1015, 1245, 1347, 1357, 1313, 1133, 1372, 1404, 1402,
  1408, 1254, 1254, 1254, 1254, 1256, 1293, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1251, 1254,
  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1241, 1061, 1251, 1254, 1254,
  1254, 1254, 1416, 1253, 1416, 1175, 1012, 1349, 1174, 1201, 1254, 1254, 1254, 1254, 1256, 1254, 1339, 1255, 1303,
  1251, 1254, 1254, 1254, 1254, 1427, 1253, 1429, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1250, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246,
  1246, 1252, 1246, 1246, 1248, 1248, 1246, 1246, 1246, 1246, 1248, 1248, 1246, 1419, 1246, 1246, 1246, 1248, 1246,
  1246, 1246, 1246, 1246, 1246, 1070, 1115, 1213, 1249, 1093, 1250, 1246, 1249, 1213, 1249, 1055, 1254, 1254, 1254,
  1245, 1329, 1149, 1254, 1245, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1249, 1278, 1245, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1441, 1014, 1246, 1246, 1246, 1246, 1249, 1254, 1254, 1254, 1254,
  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1402, 1405, 1385, 1254, 1254, 1254, 1246, 1246, 1246, 1246,
  1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1246, 1250, 1254, 1254,
  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1408, 1402, 1408, 1395, 1377, 1246, 1245, 1246, 1246, 1246,
  1252, 1401, 1402, 1265, 1406, 1264, 1401, 1402, 1404, 1401, 1385, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,
  1245, 1246, 1246, 1246, 1247, 1429, 1245, 1246, 1246, 1246, 1247, 1254, 1401, 1402, 1147, 1402, 1402, 1129, 1382,
  1254, 1246, 1246, 1246, 1251, 1251, 1254, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
  9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 26, 30,
  30, 30, 30, 30, 30, 30, 30, 31, 30, 30, 30, 30, 30, 30, 32, 6, 33, 6, 34, 6, 6, 6, 6, 6, 34, 34, 34, 34, 34, 34, 6,
  35, 36, 37, 38, 39, 40, 41, 42, 43, 30, 30, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 30, 58, 59, 60, 6,
  6, 6, 6, 6, 61, 6, 34, 6, 34, 34, 6, 34, 34, 6, 34, 34, 34, 34, 34, 6, 34, 34, 34, 34, 34, 6, 61, 61, 61, 61, 6, 61,
  61, 61, 6, 6, 34, 34, 34, 34, 34, 6, 6, 34, 34, 34, 6, 6, 34, 34, 6, 6, 6, 6, 61, 61, 61, 34, 34, 34, 34, 34, 34, 34,
  6, 34, 6, 34, 34, 34, 34, 6, 34, 61, 61, 6, 61, 61, 61, 6, 61, 61, 34, 6, 6, 34, 34, 6, 6, 61, 34, 61, 61, 6, 61, 61,
  61, 61, 61, 6, 6, 61, 61, 34, 34, 61, 61, 6, 6, 61, 61, 61, 6, 6, 6, 6, 61, 34, 6, 34, 6, 6, 6, 34, 34, 6, 6, 6, 34,
  34, 6, 6, 61, 6, 61, 61, 61, 61, 6, 6, 6, 61, 61, 6, 6, 6, 6, 34, 34, 6, 34, 6, 6, 34, 6, 6, 61, 6, 6, 34, 34, 34, 6,
  34, 34, 6, 34, 34, 34, 34, 6, 34, 6, 34, 34, 61, 61, 34, 34, 34, 6, 6, 6, 6, 34, 34, 6, 34, 34, 6, 34, 34, 34, 34, 34,
  34, 34, 34, 6, 6, 6, 6, 6, 6, 6, 6, 34, 6, 61, 61, 61, 61, 61, 61, 6, 61, 61, 34, 6, 6, 6, 6, 6, 61, 61, 6, 6, 61, 61,
  6, 34, 34, 34, 34, 34, 34, 6, 6, 6, 34, 34, 6, 6, 34, 6, 6, 34, 34, 6, 34, 6, 34, 34, 34, 34, 6, 6, 34, 61, 34, 34,
  61, 61, 61, 61, 61, 34, 34, 61, 34, 34, 34, 34, 34, 34, 61, 61, 61, 61, 61, 61, 34, 6, 34, 6, 6, 34, 6, 6, 34, 34, 6,
  34, 34, 34, 6, 34, 6, 34, 6, 34, 6, 6, 34, 34, 6, 34, 34, 6, 6, 34, 34, 34, 34, 34, 6, 34, 34, 34, 34, 34, 6, 61, 6,
  6, 6, 6, 61, 61, 6, 61, 6, 6, 6, 6, 6, 6, 34, 61, 6, 6, 6, 6, 6, 61, 6, 61, 61, 61, 61, 61, 61, 61, 61, 6, 6, 6, 6, 6,
  6, 6, 6, 6, 6, 34, 6, 34, 6, 34, 6, 34, 6, 6, 6, 34, 6, 6, 6, 6, 6, 6, 6, 61, 61, 6, 34, 34, 34, 6, 61, 61, 61, 6, 34,
  34, 34
);

(:~
 : The codepoint to charclass mapping for codepoints above the surrogate block.
 :)
declare variable $p:MAP2 as xs:integer+ :=
(
  57344, 65536, 65533, 1114111, 6, 6
);

(:~
 : The token-set-id to DFA-initial-state mapping.
 :)
declare variable $p:INITIAL as xs:integer+ :=
(
  6145, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 2071, 4119, 24, 25, 26, 27, 28, 29,
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,
  59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
  114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136,
  137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182,
  183
);

(:~
 : The DFA transition table.
 :)
declare variable $p:TRANSITION as xs:integer+ :=
(
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 9472, 8064, 8092, 8092, 8090,
  8092, 8092, 8074, 8108, 8111, 8127, 8136, 8163, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600,
  17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362,
  8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724,
  8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001,
  9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023,
  9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12607, 12612,
  9447, 9465, 10047, 8318, 15004, 8318, 8448, 8372, 8318, 8318, 9349, 8897, 9392, 8269, 9488, 8189, 14616, 8318, 8244,
  12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594,
  8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269,
  8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116,
  9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8143, 9525, 8318, 8318, 9550, 8318, 16391, 15854, 16393, 8318, 9084, 9570, 16632, 8318, 15004,
  19368, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 15901, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073,
  8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627,
  8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756,
  8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242,
  9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  9593, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 8318, 8318, 8318, 12457, 10047, 8318, 21876, 23880, 24108, 8372, 8318,
  8318, 9349, 8897, 9392, 8600, 23598, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887,
  8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332,
  8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012,
  8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389,
  9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 9643, 20498, 8318, 8318, 9665,
  8318, 20502, 9917, 8318, 20500, 20325, 20338, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392,
  8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335,
  8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581,
  8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458,
  9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365,
  9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 8318,
  8318, 8318, 12065, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616,
  8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416,
  8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878,
  8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130,
  9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 18573, 8318, 8318, 8318, 12065, 14963,
  8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260,
  10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915,
  9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740,
  8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211,
  9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8143, 9689, 8318, 8318, 9714, 8318, 16842, 15391, 16844, 8318, 18955, 9734, 21384, 8318, 15004, 22982, 24108,
  8372, 8318, 8318, 9349, 8897, 9392, 8600, 18011, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396,
  8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654,
  8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834,
  8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317,
  9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 9761, 16247, 9794,
  9794, 9784, 9794, 9794, 9804, 9820, 9831, 9847, 9860, 10047, 8318, 14580, 8318, 24108, 8372, 8318, 8318, 9349, 8897,
  9392, 8600, 17558, 8189, 14479, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153,
  8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485,
  8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965,
  8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565,
  9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 14221, 8318, 8318, 9905, 8318, 22961, 19475,
  9944, 9955, 9933, 9971, 10047, 8318, 22951, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 9881,
  8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416,
  8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878,
  8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130,
  9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12668, 9999, 10015, 10028, 10047,
  8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260,
  10073, 8285, 8906, 10063, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915,
  9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740,
  8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211,
  9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 10111, 10089, 10105, 10127, 10047, 8318, 15004, 8318, 24108,
  8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396,
  8301, 8887, 10162, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654,
  8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834,
  8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317,
  9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 17797, 8318,
  8318, 10180, 8318, 22971, 10215, 10194, 10199, 22980, 10231, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349,
  8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318,
  24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545,
  8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940,
  8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556,
  8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 10258, 8318, 8318, 8318, 9887, 8318, 8318,
  9917, 10342, 10282, 10336, 10296, 10047, 8318, 15004, 8318, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495,
  20427, 8318, 14616, 18409, 10404, 10408, 8318, 14488, 13884, 13885, 20896, 13276, 12474, 12474, 10358, 8318, 8318,
  13369, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 10377, 8318, 17091, 17815, 23798, 13884, 13884,
  23250, 12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 16489, 18373, 12474, 14431, 8318, 10401, 23797, 13884,
  17728, 12474, 10425, 8318, 23291, 13884, 10508, 12474, 13432, 17092, 10445, 10464, 10490, 22112, 14386, 18867, 10527,
  10543, 10582, 18465, 10505, 22915, 10642, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143,
  8318, 8318, 8318, 9887, 8318, 8318, 9917, 8318, 8318, 17673, 17686, 10047, 8318, 15004, 8318, 12298, 10408, 8318,
  8318, 20895, 14177, 13272, 21505, 10663, 8318, 14616, 8318, 10404, 10408, 8318, 14488, 13884, 13885, 20896, 13276,
  12474, 12474, 8318, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 8318, 8318,
  17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474,
  14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508,
  13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8143, 10699, 8318, 8318, 9887, 8318, 8318, 9917, 12758, 12769, 10735, 10748, 10047,
  8318, 15004, 8318, 19662, 8372, 14954, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231,
  8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421,
  8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711,
  8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175,
  9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 8318, 8318, 17150, 17163, 10047, 8318, 15004, 8318, 12298,
  10408, 8318, 8318, 20895, 14177, 13272, 21749, 10775, 8318, 14616, 10138, 10404, 10408, 8318, 14488, 13884, 13885,
  20896, 13276, 12474, 12474, 10792, 8318, 8318, 10820, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 20066,
  10838, 8318, 23286, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882, 8318, 12298, 10409, 23798, 13884, 20157,
  12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092,
  20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 10776, 10856, 8318, 10873, 10856, 10877, 9917, 8318, 17070, 8318,
  9608, 14590, 8318, 15563, 8318, 24108, 8372, 8318, 8318, 10951, 10943, 11033, 11039, 17558, 8189, 10709, 8318, 8244,
  12800, 8231, 10893, 11535, 10918, 10934, 10975, 11005, 11287, 8317, 8318, 24153, 8335, 8362, 9226, 10959, 11131,
  11021, 11280, 11055, 11071, 11375, 9627, 8437, 16657, 8654, 11087, 11426, 11103, 11157, 11468, 11184, 11197, 8616,
  8640, 11878, 11213, 11141, 11229, 11254, 11598, 11303, 8781, 8803, 11324, 11650, 10902, 11455, 11340, 8965, 19672,
  11414, 11681, 11365, 10989, 9100, 11400, 11442, 11484, 9211, 11521, 11551, 11567, 11583, 11267, 11620, 11614, 11168,
  11118, 11636, 11238, 11666, 11697, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 11743, 8318, 11732, 11761, 8318,
  14357, 11780, 11785, 11743, 11801, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558,
  8189, 14616, 9422, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 11836, 8318, 24153, 11865, 8362,
  8818, 8529, 8416, 8388, 8594, 8405, 8421, 9075, 8173, 8437, 11894, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 9159,
  8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001,
  9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023,
  9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 21437, 8980, 8985,
  11910, 11923, 10047, 8318, 15004, 8318, 24108, 8372, 11958, 8318, 9349, 8897, 9392, 8600, 11975, 8189, 14616, 8318,
  8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388,
  8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670,
  9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100,
  9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 12006, 8318, 12037, 8318, 9887, 8318, 8318, 9917, 12016, 12021, 12038, 12054, 19145,
  8318, 15004, 8318, 24108, 8346, 12092, 8318, 9349, 8897, 9392, 8600, 12110, 8189, 14616, 8318, 8244, 12800, 8231,
  8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421,
  8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711,
  8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175,
  9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 20345, 12166, 8318, 8318, 9887, 8318, 8318, 9917, 9190, 9195, 12193, 12219, 12262, 8318, 15004, 8318,
  24108, 8372, 12296, 8318, 9349, 8897, 9392, 8600, 12314, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285,
  8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437,
  16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781,
  8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285,
  9301, 9317, 8874, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 12280,
  12364, 8318, 8318, 12382, 8318, 8318, 9917, 8318, 12389, 8318, 12273, 10047, 8318, 15004, 8318, 13623, 8372, 8318,
  8318, 9349, 8897, 9392, 8695, 12405, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887,
  8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332,
  8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012,
  8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389,
  9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887,
  8318, 8318, 9917, 8318, 8318, 8787, 12446, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600,
  17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362,
  8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724,
  8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001,
  9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023,
  9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263,
  14908, 22208, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616,
  24013, 10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 12491, 10407, 12983,
  13884, 13884, 13884, 13145, 12474, 12474, 10474, 12511, 8318, 23286, 17815, 23798, 13884, 13884, 23250, 12474, 12474,
  15882, 8318, 9718, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472,
  8318, 12529, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511,
  10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318,
  9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177,
  13272, 10495, 8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076,
  8318, 8318, 12491, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 10474, 12511, 8318, 23286, 17815, 23798,
  13884, 13884, 23250, 12474, 12474, 15882, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758,
  23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012,
  23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 8318, 15004, 24009,
  12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884,
  13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 12568, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474,
  10474, 12511, 8318, 23286, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882, 8318, 12298, 10409, 23798, 13884,
  20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433,
  17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927,
  14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908,
  22208, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013,
  10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 12491, 10407, 12983, 13884,
  13884, 13884, 13145, 12474, 12474, 10474, 12511, 8318, 23980, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882,
  8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318,
  23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505,
  10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887,
  8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177,
  13272, 22294, 8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 12594,
  8318, 8318, 12491, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 10474, 12511, 8318, 23286, 17815, 23798,
  13884, 13884, 23250, 12474, 12474, 15882, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758,
  23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012,
  23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 8318, 15004, 24009,
  12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884,
  13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474,
  14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884,
  20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433,
  17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927,
  14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908,
  22208, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013,
  10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 17090, 10407, 12983, 13884,
  13884, 13884, 13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431,
  8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 15062, 23797, 13884, 10510, 12474, 18472, 8318,
  23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505,
  10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887,
  8318, 8318, 9917, 14019, 14030, 12628, 12646, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392,
  8600, 17558, 8189, 14616, 19812, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153,
  8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485,
  8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965,
  8458, 9001, 9049, 9065, 9130, 12684, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565,
  9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 12700, 8318, 9887, 8318, 8318, 14776,
  12720, 12731, 12702, 12747, 10047, 8318, 15004, 8318, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189,
  14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529,
  8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640,
  11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065,
  9130, 9100, 9116, 9146, 9175, 12785, 9242, 9285, 12816, 9317, 8516, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208,
  10047, 8318, 15004, 8318, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8318, 8318, 14616, 8318, 10404, 10408,
  8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 8318, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884,
  13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298,
  10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884,
  10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734,
  20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 11499, 8318, 12832, 12855, 12839,
  22541, 12882, 12893, 12909, 12922, 11942, 12938, 15110, 11384, 12966, 12999, 24047, 12950, 19039, 13030, 13059, 13084,
  8624, 8318, 15433, 21103, 10404, 13379, 8318, 20736, 13884, 23686, 13133, 12473, 12474, 18187, 22076, 13165, 9619,
  13185, 13206, 23653, 14397, 19739, 23678, 17586, 12474, 13514, 10474, 13222, 8203, 23629, 13244, 13260, 18894, 13884,
  14806, 16678, 12474, 12150, 20435, 11812, 10409, 23798, 13884, 13293, 12474, 18723, 13322, 13358, 17758, 23797, 13884,
  13395, 19521, 18472, 8318, 23291, 21331, 16322, 13417, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473,
  10680, 16431, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693,
  8318, 17470, 8318, 9887, 18078, 8318, 15122, 12979, 13455, 19638, 19651, 10047, 8318, 15004, 24009, 12298, 10408,
  8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 13885, 13014,
  12473, 12474, 12474, 22076, 8318, 24199, 12491, 22337, 12983, 13884, 10448, 13884, 13145, 12474, 16989, 10474, 12511,
  8318, 23286, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882, 16771, 12366, 19402, 20843, 13884, 13496, 13512,
  12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895,
  10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 12541, 13530, 17734, 20274, 15962, 18927, 14944, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 22215, 8318, 8924, 8318, 9887, 11707, 9768, 13552, 13567, 13583, 13599, 13612,
  10047, 8318, 13639, 17137, 12298, 10408, 8318, 8318, 20895, 14177, 13665, 13686, 8624, 8318, 17403, 21462, 13712,
  10408, 9431, 21194, 13767, 23424, 15714, 13789, 12474, 12474, 23078, 15893, 8318, 13805, 10407, 12983, 13821, 13829,
  19757, 22904, 13845, 19714, 10474, 12511, 8318, 13862, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882, 8318,
  12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 12495, 20207, 13883, 10510, 22804, 21649, 13901, 14671,
  15998, 13922, 21569, 14433, 17092, 20895, 22256, 22314, 22112, 13012, 23250, 18473, 10680, 18670, 18972, 13947, 10500,
  17734, 20274, 15962, 22463, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 10361, 8318, 9887, 12176, 12177,
  8215, 13963, 13979, 13995, 14008, 10047, 8318, 15004, 24009, 12298, 15151, 18492, 9871, 14046, 13117, 18838, 10495,
  19463, 14452, 14072, 14097, 14122, 23453, 23770, 14142, 15684, 14168, 17365, 14199, 23255, 12474, 22076, 8318, 8318,
  12491, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 10474, 14217, 11716, 23286, 17815, 12420, 13884, 14237,
  21014, 12474, 12474, 14259, 8318, 10385, 10409, 24366, 22607, 22437, 12474, 19514, 14431, 16165, 14286, 18826, 14313,
  10510, 14333, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 14373, 21523, 10508, 20715, 22112, 13012, 23250, 18473,
  10680, 18670, 14420, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693,
  8318, 10840, 14451, 9887, 14468, 14625, 14509, 14524, 14540, 14556, 14569, 10047, 19339, 14606, 14641, 14661, 14687,
  14724, 14764, 16103, 14792, 14822, 14857, 10566, 10039, 20828, 14645, 10404, 16271, 23095, 20736, 14873, 14894, 22892,
  14929, 17610, 14979, 15048, 17336, 15084, 15138, 15180, 19432, 15218, 15265, 19551, 15303, 15329, 15367, 15407, 15423,
  15449, 24336, 20000, 14183, 13773, 20027, 15469, 15510, 15530, 15552, 8318, 15598, 10320, 20598, 22381, 12340, 23407,
  15624, 15659, 22042, 18352, 18115, 15682, 14913, 17950, 22812, 24074, 15700, 15742, 15758, 15787, 15828, 17092, 20895,
  15870, 21642, 14106, 13012, 15917, 15938, 15954, 15978, 16014, 13696, 16055, 16092, 21701, 16119, 18927, 14944, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 16163, 9887, 8949, 8318, 16181, 16196, 16207, 16223, 16236,
  10047, 18152, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 20661, 12246, 10495, 8624, 17237, 14616, 24013, 16263,
  10408, 8318, 10626, 13884, 13885, 13014, 16287, 12474, 12474, 22076, 8318, 8318, 12491, 10407, 12983, 13884, 19795,
  13884, 13145, 12474, 23726, 10474, 12511, 8318, 23286, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 15882, 12704,
  12298, 14297, 23798, 24372, 20157, 12474, 19721, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291,
  13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500,
  17734, 12348, 16312, 22197, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 11745, 11745,
  9917, 16346, 16351, 16367, 16380, 10047, 8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495,
  8624, 8318, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318,
  17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884,
  23250, 12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884,
  10510, 12474, 18472, 15842, 23291, 13884, 10508, 12474, 14433, 20118, 16409, 18901, 16447, 9509, 14700, 16470, 16505,
  10680, 18670, 10511, 10505, 10500, 17734, 20274, 16521, 16564, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693,
  8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 8318, 16029, 24009, 19980, 15068, 8318,
  8318, 16602, 16594, 22409, 15287, 20480, 8318, 16623, 16648, 10404, 10408, 8318, 20736, 13884, 13885, 19168, 12473,
  12474, 16673, 22076, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 16694, 8318,
  17091, 17815, 14739, 13884, 13884, 12138, 12474, 12474, 21412, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474,
  14431, 24040, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508,
  13277, 22112, 13012, 16715, 21973, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 17693, 16766, 8318, 16736, 9887, 16755, 19010, 9917, 16787, 16802, 16818, 16831, 10047,
  8318, 15004, 24009, 12298, 16860, 12861, 12866, 22000, 12430, 22733, 10495, 8624, 8318, 16039, 24013, 10404, 16893,
  9673, 16923, 20850, 21483, 13014, 16962, 16985, 15514, 21850, 17479, 17005, 17090, 19940, 12983, 13884, 21544, 17021,
  13145, 12474, 16147, 17041, 8318, 23591, 17091, 17815, 23798, 13884, 22863, 15279, 12474, 12474, 22683, 17061, 17086,
  10409, 23798, 13884, 20157, 12474, 12474, 15379, 14081, 17108, 16907, 13099, 17991, 21778, 17124, 8318, 17186, 23206,
  16422, 17214, 17260, 17092, 20895, 10508, 13277, 17279, 13012, 23250, 18473, 10680, 13068, 17308, 10505, 10500, 13401,
  17352, 15962, 18927, 17393, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 12094, 12094, 11849,
  17419, 17430, 17446, 17459, 10047, 23906, 15004, 24009, 15666, 17495, 22155, 22149, 17531, 14056, 17931, 15643, 8624,
  17554, 22753, 24013, 19395, 10408, 8318, 20797, 21065, 22583, 17574, 17602, 17626, 15771, 22076, 17644, 21920, 18085,
  10407, 12983, 17713, 13884, 13884, 17377, 18255, 12474, 22743, 8318, 8318, 17755, 15191, 23798, 17839, 17777, 23250,
  14201, 16720, 14431, 17795, 12298, 17813, 12234, 13884, 20157, 18306, 12474, 14431, 11934, 19932, 17831, 13884, 23838,
  12474, 18472, 10146, 23291, 13884, 10508, 12474, 14433, 17855, 20895, 18178, 20562, 22112, 13012, 23250, 18473, 10680,
  18670, 10511, 10505, 19109, 18436, 17890, 17919, 17966, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17170, 8318,
  8318, 18007, 9887, 8318, 8319, 9917, 18027, 18038, 18054, 18067, 10047, 10718, 15004, 24009, 17244, 18101, 18149,
  10719, 18168, 14152, 19067, 20295, 8624, 11308, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 13108, 18211, 18247,
  13149, 23400, 22076, 22037, 8318, 17090, 10407, 12983, 13884, 13884, 14708, 15726, 18271, 12474, 14429, 8318, 18330,
  18349, 17815, 14493, 13884, 14243, 18368, 18389, 15249, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474,
  14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 18408, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508,
  13277, 22112, 13012, 23250, 21611, 18425, 18452, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 17693, 9503, 8318, 18510, 18489, 10664, 18508, 9983, 18526, 18533, 18549, 18562, 18589,
  9649, 20541, 18616, 18333, 17292, 11349, 18636, 18652, 18686, 13043, 16946, 8624, 19921, 14616, 19608, 10404, 10408,
  8318, 20736, 13884, 13885, 18702, 18718, 12474, 12474, 24289, 9889, 8318, 17090, 10407, 12983, 13884, 13884, 13884,
  13145, 12474, 12474, 15313, 8318, 8318, 10310, 12578, 18739, 23212, 18761, 16069, 12474, 18781, 14431, 18797, 21926,
  18813, 18854, 18883, 23242, 20966, 18917, 14431, 18943, 17758, 13738, 13884, 18971, 18988, 18472, 19006, 19026, 19055,
  14404, 18286, 15343, 24135, 22855, 19083, 21603, 22112, 23466, 10596, 18473, 10680, 22418, 19099, 19125, 19161, 17734,
  20274, 19184, 18927, 14994, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 22140, 9887, 23915, 19210, 19230,
  19245, 19261, 19277, 19290, 19328, 19362, 15004, 24009, 19384, 19418, 9745, 19448, 19491, 19537, 19567, 19583, 8624,
  8318, 14616, 19599, 10404, 10408, 8318, 20736, 13884, 19624, 21039, 12473, 12474, 19688, 22076, 8318, 22107, 17090,
  14126, 20877, 13884, 19737, 19755, 13145, 15922, 12474, 19773, 12630, 8318, 17091, 17815, 23798, 19791, 13884, 23250,
  20985, 12474, 14431, 9554, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 19811, 17758, 17509, 13884, 16139,
  12474, 16454, 8318, 15608, 19828, 10683, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 16873, 19847, 21578, 19869,
  13931, 18662, 10505, 10500, 17734, 20274, 15962, 18927, 15484, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 20492,
  8318, 8318, 9887, 14841, 19885, 19906, 22529, 19890, 19956, 19969, 10047, 12513, 15004, 24009, 12298, 10408, 8318,
  15097, 20895, 14177, 13272, 10495, 8624, 20531, 14616, 20636, 20088, 10408, 8318, 20736, 20016, 13885, 17903, 20043,
  15637, 13670, 10759, 8318, 8318, 17090, 10407, 12983, 13884, 21072, 17779, 13145, 12474, 20977, 14429, 8318, 8318,
  20082, 20104, 23798, 20154, 13884, 23250, 15241, 12474, 14431, 13336, 12298, 10409, 23798, 13884, 20759, 12474, 20173,
  14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508,
  13277, 22112, 13012, 23250, 16296, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047,
  8318, 15004, 24009, 12298, 20193, 20227, 20231, 20247, 16578, 19503, 16969, 8624, 8318, 14616, 24013, 10404, 10408,
  8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884,
  13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298,
  10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884,
  10508, 12474, 14433, 17092, 20895, 20270, 20290, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734,
  20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 9534, 20311, 8318, 13649, 20361,
  20376, 20387, 20403, 20416, 19301, 11959, 20451, 20467, 11505, 23374, 8318, 20518, 13536, 20592, 20557, 20578, 8624,
  8318, 20627, 20614, 17761, 10408, 8318, 20736, 21236, 20652, 20677, 12473, 20693, 20712, 22076, 8318, 10266, 23364,
  10407, 20731, 18765, 13884, 20752, 18223, 17942, 12474, 20775, 9449, 20813, 17091, 20866, 20893, 22367, 16129, 15232,
  23860, 20912, 20937, 8318, 12298, 10409, 12329, 21243, 20157, 18297, 18231, 17226, 10164, 17758, 23797, 17515, 10510,
  12474, 15802, 8318, 13867, 13884, 20138, 12474, 14837, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 20953,
  21001, 10511, 17198, 10500, 17734, 20274, 21055, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318,
  8318, 13439, 21088, 8318, 11990, 21128, 21143, 21154, 21170, 21183, 15582, 8318, 15004, 19312, 21210, 21678, 17659,
  12076, 21226, 19194, 13751, 10495, 21259, 15023, 14616, 15032, 21275, 21301, 10242, 21316, 21353, 13885, 16548, 21400,
  22795, 12474, 23751, 21435, 21453, 17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 8147, 15574,
  17091, 23642, 21478, 19831, 23551, 21499, 13846, 20921, 14431, 22689, 12298, 13725, 21521, 21539, 18745, 12474, 21560,
  19137, 17697, 17758, 23797, 13884, 21594, 21627, 18472, 8318, 23291, 13884, 10508, 12474, 17045, 10822, 22481, 10508,
  16076, 21665, 13012, 23250, 18473, 21694, 21717, 10511, 21765, 17739, 12552, 16535, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 19214, 9887, 8318, 8318, 9917, 21794, 21810, 21826, 21839, 15351,
  8318, 21866, 17323, 23002, 24351, 21892, 10857, 18133, 21942, 21958, 21989, 8624, 22022, 22058, 18620, 10404, 22092,
  22128, 22174, 16607, 22231, 22272, 22288, 23143, 22310, 22076, 22069, 8318, 19346, 22330, 22353, 22397, 22434, 21337,
  22453, 19701, 18392, 14429, 23533, 16699, 17091, 21285, 22479, 13884, 22497, 23250, 12474, 20696, 19775, 8318, 22516,
  22557, 22573, 22599, 14317, 22623, 21743, 13306, 8318, 11820, 13469, 13480, 22639, 22655, 21376, 13169, 23291, 15991,
  22671, 22705, 10557, 23924, 22721, 16936, 22769, 24226, 20131, 22785, 22828, 10680, 18670, 10511, 10505, 16481, 22844,
  22879, 15962, 23153, 22941, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 22998, 9917,
  23018, 23031, 23047, 23060, 10047, 21419, 15494, 24009, 12298, 10408, 8318, 8318, 20895, 18125, 13272, 10495, 8624,
  23094, 14616, 24013, 10404, 10408, 8318, 20736, 13884, 23816, 13014, 12473, 12474, 12475, 21907, 13906, 8318, 17090,
  23989, 15202, 17538, 17980, 20254, 13145, 23111, 23133, 14429, 15014, 8318, 9698, 17815, 12125, 13884, 13884, 23250,
  23169, 12474, 14345, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 10429, 8318, 17758, 23797, 17025, 14748,
  12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 15164, 21730, 18473, 10680,
  18670, 10511, 10505, 10647, 16330, 20274, 23191, 23228, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318,
  8318, 16739, 9887, 11764, 23319, 23271, 23307, 23324, 23340, 23353, 10047, 8318, 15004, 24009, 12298, 10408, 8318,
  8318, 22248, 22240, 21365, 15536, 8624, 8318, 14616, 24013, 19991, 10408, 10617, 17874, 13884, 13885, 13014, 23390,
  12474, 12474, 22076, 8318, 23071, 17090, 13200, 17869, 13884, 23423, 13884, 13145, 23175, 12474, 14429, 8318, 8318,
  17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474,
  10608, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508,
  13277, 23440, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 10804, 23482, 23493, 23509, 23522, 10047,
  8318, 15004, 24009, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8624, 8318, 14616, 24013, 10404, 10408,
  8318, 20736, 13884, 13885, 13014, 12473, 12474, 12474, 22076, 8318, 8318, 17090, 10407, 12983, 13884, 13884, 13884,
  13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250, 12474, 12474, 14431, 8318, 12298,
  10409, 23798, 23549, 16877, 17628, 18990, 14431, 8318, 17758, 23797, 13884, 10510, 12474, 18472, 8318, 23291, 13884,
  10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734,
  20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318, 8318, 8318, 9887, 8318, 8318, 9917,
  12979, 22158, 23567, 23580, 10047, 8318, 15812, 24009, 12298, 23614, 8761, 8765, 23669, 22925, 22186, 19853, 8624,
  8318, 14616, 20788, 10404, 10408, 8318, 20736, 13884, 13885, 20211, 12473, 12474, 18314, 21112, 8318, 8318, 17090,
  10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250,
  12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510,
  12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680,
  18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 17693, 8318,
  8318, 8318, 9887, 8318, 8318, 9917, 12979, 17263, 14908, 22208, 10047, 23702, 15004, 24009, 12298, 10408, 8318, 8318,
  20895, 14177, 23720, 21027, 8624, 8318, 23742, 24013, 10404, 10408, 8318, 20736, 13884, 22006, 13014, 12473, 12474,
  23117, 22076, 23767, 8318, 17090, 10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 13228, 8318, 17091,
  23786, 23798, 23814, 22500, 23250, 20056, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 23832, 23854, 12474, 23876,
  8318, 17758, 23797, 13884, 10510, 12474, 18195, 8318, 23291, 14878, 10508, 20177, 14433, 17092, 20895, 10508, 13277,
  22112, 13012, 23250, 18473, 10680, 18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 9577, 8318, 8318, 14435, 23896, 23940, 23949, 23965, 24005, 13342, 24029, 24063, 10047, 8318,
  15004, 15453, 24108, 8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260,
  10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915,
  9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740,
  8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211,
  9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318, 9917, 14270, 24090, 24106, 24124, 10047, 8318, 15004, 8318, 24108,
  8372, 8318, 8318, 9349, 8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396,
  8301, 8887, 8317, 8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654,
  8474, 9332, 8501, 8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834,
  8859, 9012, 8843, 8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317,
  9379, 8389, 9348, 8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318,
  8318, 24151, 8318, 8318, 18600, 24169, 24180, 24196, 24215, 10047, 8318, 15004, 23704, 24108, 8372, 8318, 8318, 9349,
  8897, 9392, 8600, 17558, 8189, 14616, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317, 8318,
  24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501, 8545,
  8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843, 8940,
  8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 9211, 9242, 9285, 9301, 9317, 9379, 8389, 9348, 8556,
  8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8143, 8318, 8318, 8318, 9887, 8318, 8318,
  9917, 8318, 8318, 8318, 12657, 10047, 8318, 15004, 8318, 12298, 10408, 8318, 8318, 20895, 14177, 13272, 10495, 8318,
  8318, 14616, 8318, 10404, 10408, 8318, 14488, 13884, 13885, 20896, 13276, 12474, 12474, 8318, 8318, 8318, 17090,
  10407, 12983, 13884, 13884, 13884, 13145, 12474, 12474, 14429, 8318, 8318, 17091, 17815, 23798, 13884, 13884, 23250,
  12474, 12474, 14431, 8318, 12298, 10409, 23798, 13884, 20157, 12474, 12474, 14431, 8318, 17758, 23797, 13884, 10510,
  12474, 18472, 8318, 23291, 13884, 10508, 12474, 14433, 17092, 20895, 10508, 13277, 22112, 13012, 23250, 18473, 10680,
  18670, 10511, 10505, 10500, 17734, 20274, 15962, 18927, 14944, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 12201,
  8318, 8318, 24242, 8318, 8318, 12203, 24261, 24266, 24245, 24282, 8318, 8318, 8318, 8318, 24108, 8372, 8318, 8318,
  9349, 8897, 9392, 8600, 17558, 8189, 8318, 8318, 8244, 12800, 8231, 8260, 10073, 8285, 8906, 9396, 8301, 8887, 8317,
  8318, 24153, 8335, 8362, 8818, 8529, 8416, 8388, 8594, 8405, 8421, 8915, 9627, 8437, 16657, 8654, 8474, 9332, 8501,
  8545, 8485, 8581, 8724, 8616, 8640, 11878, 8670, 9269, 8686, 8711, 8740, 8756, 8781, 8803, 8834, 8859, 9012, 8843,
  8940, 8965, 8458, 9001, 9049, 9065, 9130, 9100, 9116, 9146, 9175, 24305, 9242, 9285, 24321, 9317, 9256, 8389, 9348,
  8556, 8565, 9365, 9023, 9033, 9412, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318,
  8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 8318, 28866, 28866, 0, 0, 0, 0, 30920, 30920,
  28866, 28866, 30920, 30920, 30920, 30920, 30920, 30920, 24576, 26624, 30920, 30920, 30920, 30920, 30920, 30920, 22528,
  30920, 30920, 232, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920,
  30920, 30920, 30920, 0, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920, 30920,
  30920, 0, 30920, 30920, 30920, 30920, 0, 28866, 0, 0, 30920, 28866, 30920, 30920, 30920, 30920, 30920, 30920, 30920,
  30920, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 998, 0, 0, 0, 28866, 0, 0, 0, 0, 0, 30920, 0, 202, 203,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 718848, 0, 0, 0, 0, 0, 0, 679936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 757760, 0, 794624, 0, 0, 0, 0,
  0, 1005, 0, 0, 0, 0, 0, 1010, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 258, 215, 0, 0, 215, 22528, 266, 745472, 749568,
  765952, 772096, 778240, 786432, 847872, 0, 0, 0, 0, 0, 772096, 0, 798720, 0, 559104, 559104, 559104, 559104, 559104,
  559104, 559104, 559104, 727040, 559104, 559104, 745472, 749568, 0, 0, 0, 798720, 0, 0, 0, 757760, 0, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 532480, 611, 561152, 561152, 561152, 786432,
  798720, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 847872, 561152, 561152, 561152, 561152, 561152,
  665600, 561152, 745472, 749568, 561152, 753664, 561152, 561152, 765952, 561152, 772096, 778240, 561152, 561152,
  786432, 561152, 798720, 534528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 193, 0, 0, 0, 0, 739328, 776192, 0, 0,
  0, 663552, 663552, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104,
  559104, 559104, 559104, 53248, 710656, 559104, 559104, 559104, 739328, 559104, 559104, 559104, 776192, 780288, 559104,
  559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 559104, 0,
  851968, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 0, 561152, 710656, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 739328, 561152, 561152,
  561152, 561152, 561152, 776192, 780288, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 851968, 0, 0, 0, 0, 845824, 0, 0, 0, 0, 0, 741376, 0, 0, 0, 0, 0, 0, 0, 448,
  0, 0, 0, 0, 0, 0, 559104, 559104, 559104, 702464, 559104, 559104, 559104, 559104, 0, 0, 0, 561152, 0, 0, 0, 0, 561152,
  561152, 681984, 684032, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 718848, 561152, 561152, 561152,
  561152, 751616, 561152, 561152, 561152, 768000, 561152, 561152, 833536, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 768000, 561152, 561152, 561152, 561152, 561152,
  561152, 854016, 790528, 0, 0, 0, 0, 1501, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 710656,
  561152, 561152, 561152, 561152, 561152, 561152, 739328, 792576, 561152, 561152, 843776, 561152, 561152, 561152,
  561152, 561152, 681984, 684032, 561152, 561152, 561152, 561152, 561152, 0, 0, 0, 561152, 561152, 561152, 561152,
  714752, 561152, 561152, 561152, 561152, 561152, 561152, 677888, 0, 829440, 561152, 561152, 561152, 792576, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 831488, 833536, 561152, 843776, 561152, 561152, 561152, 0,
  561152, 663552, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 532480, 0, 561152,
  561152, 561152, 0, 0, 0, 720896, 0, 0, 0, 800768, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 619, 621, 0, 0, 0, 0, 0, 0, 0, 774144,
  0, 0, 839680, 0, 0, 0, 0, 0, 866304, 0, 559104, 559104, 751616, 559104, 559104, 559104, 559104, 559104, 559104,
  559104, 559104, 559104, 684032, 0, 751616, 0, 0, 0, 849920, 856064, 561152, 561152, 561152, 688128, 690176, 561152,
  561152, 561152, 561152, 561152, 720896, 729088, 561152, 866304, 561152, 561152, 561152, 561152, 561152, 561152,
  720896, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 532480, 114688, 561152,
  561152, 561152, 561152, 561152, 688128, 690176, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 720896,
  729088, 561152, 561152, 561152, 561152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 688128, 0, 0, 561152, 561152, 561152, 561152,
  800768, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 849920, 561152, 856064, 561152, 561152,
  866304, 561152, 782336, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0, 0, 0, 0, 0, 796672, 0, 821248, 825344,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 129024, 129024, 129024, 129024, 0, 835584, 837632, 0, 0, 0, 559104, 559104,
  559104, 559104, 559104, 731136, 559104, 559104, 821248, 559104, 0, 710656, 0, 0, 0, 0, 780288, 0, 0, 780288, 0, 0,
  561152, 561152, 663552, 835584, 0, 731136, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  731136, 561152, 755712, 561152, 561152, 782336, 561152, 561152, 806912, 561152, 561152, 561152, 561152, 561152,
  782336, 561152, 806912, 561152, 561152, 821248, 561152, 835584, 561152, 561152, 868352, 561152, 675840, 561152,
  561152, 561152, 561152, 561152, 561152, 854016, 790528, 0, 0, 0, 0, 47104, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 847872, 561152, 561152, 561152, 561152, 561152, 561152, 0, 0, 0, 0, 561152, 561152,
  561152, 561152, 561152, 561152, 753664, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 0, 536576, 681984, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 211, 212, 213, 214, 0, 0, 0, 821248, 561152, 561152, 835584, 561152, 561152, 561152, 868352,
  759808, 0, 0, 0, 0, 0, 0, 0, 0, 0, 219, 0, 239, 219, 219, 0, 0, 0, 702464, 716800, 0, 0, 0, 0, 0, 864256, 0, 0, 0,
  815104, 0, 802816, 0, 0, 0, 0, 0, 104737, 104737, 104737, 104737, 104737, 104737, 104737, 104737, 104737, 104737,
  104737, 104737, 104737, 0, 104737, 104737, 561152, 561152, 561152, 700416, 702464, 561152, 561152, 561152, 561152,
  561152, 802816, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 675840, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 661504, 561152, 561152, 561152, 561152,
  827392, 561152, 737280, 811008, 561152, 561152, 737280, 811008, 561152, 706560, 561152, 561152, 694272, 561152,
  716800, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 694272, 700416, 702464,
  561152, 561152, 716800, 561152, 561152, 561152, 561152, 561152, 802816, 561152, 561152, 561152, 561152, 561152,
  561152, 0, 536576, 681984, 0, 0, 0, 0, 0, 202, 0, 0, 0, 0, 0, 0, 202, 202, 202, 202, 733184, 724992, 747520, 0, 0, 0,
  0, 0, 559104, 686080, 559104, 559104, 761856, 559104, 559104, 686080, 761856, 0, 659456, 561152, 686080, 561152,
  561152, 561152, 712704, 561152, 761856, 561152, 561152, 819200, 561152, 561152, 0, 0, 813056, 673792, 0, 0, 0, 0,
  743424, 0, 804864, 0, 862208, 0, 860160, 561152, 712704, 561152, 561152, 561152, 561152, 561152, 561152, 659456,
  561152, 561152, 686080, 561152, 561152, 561152, 561152, 0, 0, 0, 0, 0, 202, 203, 0, 0, 688128, 0, 0, 712704, 561152,
  561152, 761856, 561152, 561152, 561152, 561152, 819200, 561152, 561152, 561152, 561152, 561152, 860160, 0, 0, 0, 0, 0,
  119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 119074, 0, 119074,
  119074, 0, 0, 692224, 0, 0, 784384, 0, 823296, 858112, 0, 667648, 0, 1421, 667648, 692224, 559104, 0, 710656, 0, 0, 0,
  0, 780288, 0, 0, 780288, 0, 0, 561152, 561657, 664057, 763904, 823296, 763904, 561152, 667648, 692224, 561152, 561152,
  735232, 763904, 808960, 823296, 858112, 671744, 561152, 561152, 561152, 561152, 561152, 561152, 854016, 790528, 0, 0,
  0, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 800768, 561152, 561152, 561152, 561152, 561152, 561152,
  849920, 856064, 561152, 784384, 561152, 561152, 561152, 561152, 561152, 667648, 671744, 692224, 561152, 561152,
  561152, 561152, 735232, 763904, 784384, 808960, 561152, 823296, 561152, 561152, 561152, 858112, 788480, 0, 0, 0, 0,
  841728, 0, 708608, 1421, 708608, 561152, 704512, 708608, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  854016, 561152, 704512, 708608, 561152, 561152, 561152, 561152, 751616, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 831488, 696320, 0, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 722944, 561152, 561152, 829440, 561152, 561152,
  722944, 561152, 561152, 561152, 561152, 829440, 698368, 561152, 561152, 561152, 561152, 561152, 561152, 854016,
  790528, 0, 0, 0, 0, 1421, 561152, 561152, 561152, 561152, 0, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 561152, 561152, 727040, 561152, 561152, 706560, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 817152, 817152, 0, 0, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 692, 0, 0, 0, 0, 0, 0, 0,
  288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1000, 0, 0, 0, 288, 288, 288, 288, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 28866, 28866, 0, 611, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 669696, 0, 0, 0, 0, 197, 198, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1471, 1421, 271, 271, 1473, 0, 0, 55296, 0, 0, 0, 0, 202, 55296, 0, 0, 0, 0, 0, 0, 0, 0, 0, 226,
  0, 0, 0, 0, 0, 0, 0, 232, 202, 202, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1145, 0, 0, 202, 202, 202, 0, 0, 0, 202,
  6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346112, 0, 0, 6145, 0, 567482, 4, 188, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 0, 0,
  0, 0, 204, 204, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 845, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 718848, 0, 0, 0, 0, 0, 6145,
  0, 3, 4, 0, 59392, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 412, 0, 0, 0, 0, 0, 232, 0, 0, 0, 59392, 59392, 59392, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 693, 0, 0, 0, 0, 0, 0, 0, 61440, 0, 0, 0, 0, 203, 61440, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271,
  271, 1026, 271, 271, 0, 232, 203, 203, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1158, 271, 271, 203, 203, 203, 0, 0, 0,
  203, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 494, 6145, 0, 3, 4, 0, 0, 189, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 212, 0, 0, 0, 0, 0, 201, 233, 201, 201, 201, 201, 201, 201, 63689, 235, 201, 201, 201, 201, 201, 201, 201,
  201, 201, 201, 201, 201, 201, 201, 201, 201, 24576, 26624, 201, 201, 201, 201, 201, 201, 22528, 201, 201, 0, 201, 201,
  201, 201, 201, 63689, 63689, 201, 63689, 63689, 201, 201, 201, 201, 201, 201, 63689, 201, 63689, 63689, 63689, 201, 0,
  63689, 63689, 201, 63689, 0, 0, 0, 63488, 201, 0, 201, 201, 201, 201, 63689, 63723, 63723, 63723, 63689, 201, 63689,
  63689, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 491, 0, 491, 0, 0, 0, 0, 0, 0, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 837, 0, 232, 0, 0, 0, 69632, 0, 0, 0, 0, 69632, 69632, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 0,
  22528, 0, 0, 69632, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 0, 69632, 69632, 69632, 0, 0, 69632, 0, 0, 69632, 69632,
  69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 69632, 0, 69632, 69632, 0, 0, 0, 69632, 69632, 69632,
  69632, 6145, 0, 0, 4, 57344, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 221, 22528, 0, 71680, 71680, 71680, 71680,
  73728, 71680, 71680, 71680, 71680, 71680, 71680, 71680, 73728, 0, 71680, 73728, 0, 71680, 0, 0, 49509, 0, 0, 0, 0, 0,
  0, 71680, 49509, 49509, 49509, 49509, 71680, 71680, 71680, 49509, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 629, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 202, 203, 0, 0, 0, 0, 0, 49152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152, 561152,
  561152, 561152, 561152, 727040, 561152, 561152, 561152, 745472, 749568, 561152, 561152, 561152, 765952, 772096,
  778240, 561152, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 77824, 0, 75776,
  77824, 0, 75776, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776, 75776,
  75776, 75776, 75776, 75776, 75776, 75776, 75776, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 657, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1345, 0, 0, 0, 0, 0, 534528, 807, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1264, 0, 232, 0, 0, 0, 0, 0, 0, 0,
  0, 79872, 0, 79872, 79872, 79872, 0, 0, 0, 0, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872, 79872,
  79872, 79872, 79872, 0, 79872, 79872, 0, 79872, 0, 0, 79872, 0, 24576, 26624, 79872, 79872, 0, 0, 79872, 0, 22528,
  79872, 0, 0, 0, 79872, 79872, 79872, 79872, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 690, 0, 0, 0, 694, 0, 0, 0, 0, 184, 0,
  3, 4, 0, 0, 0, 190, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 848, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920,
  81920, 81920, 81920, 81920, 81920, 81920, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 39097, 3, 4, 0, 0,
  387, 0, 0, 0, 0, 0, 1019, 0, 0, 0, 1023, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1169, 271, 271, 271, 0, 0,
  0, 81920, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 81920, 0, 807, 664,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 988, 0, 0, 0, 0, 993, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1156, 0,
  0, 0, 1159, 271, 1265, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,
  0, 0, 358, 358, 1327, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1248, 0, 0, 0, 0, 0, 1428, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 914, 323, 323, 323, 1439, 323, 323, 323, 323, 323, 323, 1446, 358,
  358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 986, 1452, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0,
  1491, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 271, 323, 1503, 323, 323, 323, 323, 323, 1508, 323,
  323, 323, 358, 1512, 358, 358, 0, 0, 0, 0, 0, 0, 1412, 0, 0, 0, 0, 0, 0, 0, 0, 617, 0, 619, 621, 0, 0, 0, 0, 358, 358,
  358, 1517, 358, 358, 358, 0, 0, 0, 0, 0, 1421, 1524, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 1488, 358,
  358, 358, 358, 0, 0, 0, 0, 1244, 0, 0, 0, 0, 0, 0, 0, 0, 691, 0, 0, 0, 0, 0, 0, 0, 0, 702, 323, 323, 323, 323, 323,
  711, 323, 323, 358, 1575, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 1572, 88064,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 197, 271, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 358,
  358, 358, 358, 1390, 358, 358, 0, 0, 0, 195, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 0, 0, 0, 565673, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 410, 0, 0, 0, 0, 0, 0, 0, 0, 90409, 0, 0, 0, 0, 0, 195, 0, 0, 0, 0, 0, 90409, 90409, 90409, 90409, 90409, 90409,
  0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 813, 0, 0, 619, 0, 621, 0, 0, 0, 609, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 204, 609, 808, 0, 0, 0, 0, 0, 0, 0, 815, 0, 817, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 0, 0, 263, 263, 0, 22528, 263,
  657, 853, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 1426, 0, 817, 987, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 216, 217, 205, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 399, 0, 234, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  205, 0, 0, 0, 0, 0, 0, 0, 798720, 0, 0, 0, 757760, 0, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561713,
  561713, 561713, 676401, 561713, 561713, 561713, 561713, 561713, 786937, 799225, 561657, 561657, 561657, 561657,
  561657, 561657, 561657, 848377, 561657, 561657, 561657, 561657, 561657, 665600, 0, 561657, 561657, 561657, 561657,
  561657, 561657, 754169, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 0, 0, 0, 0, 561657, 561657, 561657,
  561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 711161, 561657, 561657,
  561657, 561657, 561657, 561657, 739833, 0, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713,
  561713, 561713, 561713, 727601, 561713, 561713, 0, 0, 813056, 673792, 0, 0, 0, 0, 743424, 0, 804864, 0, 862208, 0,
  561713, 746033, 750129, 561713, 754225, 561713, 561713, 766513, 561713, 772657, 778801, 561713, 561713, 786993,
  561713, 799281, 852473, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657,
  561657, 561657, 561657, 561657, 560, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713,
  561713, 0, 532480, 0, 561657, 561657, 561657, 561713, 711217, 561713, 561713, 561713, 561713, 561713, 561713, 561713,
  739889, 561713, 561713, 561713, 561713, 561713, 776753, 780849, 561713, 561713, 561713, 561713, 561713, 561713,
  561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 852529, 0, 0, 0, 0, 561657, 561657, 682489, 684537,
  561657, 561657, 561657, 561657, 561657, 561657, 561657, 719353, 834041, 561657, 561657, 561657, 561657, 561657,
  561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 768505, 561657, 561713, 561713, 715313, 561713,
  561713, 561713, 561713, 561713, 561713, 677888, 0, 829440, 561657, 561657, 561657, 561657, 776697, 780793, 561657,
  561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 801273, 561657, 561657, 561657, 561657,
  561657, 561657, 850425, 856569, 561657, 793081, 561657, 561657, 844281, 561657, 561713, 561713, 561713, 561713,
  682545, 684593, 561713, 561713, 561713, 561713, 561713, 0, 0, 0, 561657, 561657, 561657, 561657, 715257, 561657,
  561657, 561657, 793137, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 832049, 834097, 561713,
  844337, 561713, 561713, 561713, 561713, 0, 0, 0, 0, 0, 0, 0, 0, 0, 688128, 0, 0, 0, 0, 849920, 856064, 561657, 561657,
  561657, 688633, 690681, 561657, 561657, 561657, 561657, 561657, 721401, 729593, 561657, 866809, 561657, 561657,
  561657, 561657, 561657, 561657, 721401, 561657, 561657, 561657, 561657, 561713, 561713, 561713, 561713, 561713,
  561713, 662009, 561657, 561657, 561657, 561657, 827897, 561713, 561713, 688689, 690737, 561713, 561713, 561713,
  561713, 561713, 561713, 561713, 721457, 729649, 561713, 561713, 561713, 561713, 561713, 561713, 854577, 790528, 0, 0,
  0, 0, 1421, 561657, 561657, 561657, 0, 561713, 664113, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713,
  561713, 561713, 848433, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 866865, 561713, 782336, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 633, 0, 0, 0, 835584, 0, 731136, 0, 0, 561657, 561657, 561657, 561657, 561657, 561657,
  561657, 561657, 731641, 561657, 756217, 821809, 561713, 561713, 836145, 561713, 561713, 561713, 868913, 759808, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 451, 0, 0, 0, 492, 0, 0, 703025, 561713, 561713, 717361, 561713, 561713, 561713, 561713, 561713,
  803377, 561713, 561713, 561713, 561713, 561713, 561713, 0, 536576, 681984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 438, 0, 0, 441,
  0, 0, 0, 761856, 0, 659961, 561657, 686585, 561657, 561657, 561657, 713209, 561657, 762361, 561657, 561657, 819705,
  561657, 561657, 561657, 700921, 702969, 561657, 561657, 561657, 561657, 561657, 803321, 561657, 561657, 561657,
  561657, 561657, 752121, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 831993,
  860665, 561657, 713209, 561657, 561657, 561657, 561657, 561657, 561657, 660017, 561713, 561713, 686641, 561713,
  561713, 561713, 561713, 731697, 561713, 756273, 561713, 561713, 782897, 561713, 561713, 807473, 561713, 561713,
  561713, 561713, 719409, 561713, 561713, 561713, 561713, 752177, 561713, 561713, 561713, 768561, 561713, 561713,
  713265, 561713, 561713, 762417, 561713, 561713, 561713, 561713, 819761, 561713, 561713, 561713, 561713, 561713,
  860721, 0, 0, 0, 0, 206, 207, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 0, 0, 271, 271, 763904, 823296, 763904, 561657,
  668153, 692729, 561657, 561657, 735737, 764409, 809465, 823801, 858617, 672249, 561657, 561657, 561657, 727545,
  561657, 561657, 561657, 745977, 750073, 561657, 561657, 561657, 766457, 772601, 778745, 561657, 784889, 561657,
  561657, 561657, 561657, 561713, 668209, 672305, 692785, 561713, 561713, 561713, 561713, 735793, 764465, 784945,
  809521, 561713, 823857, 561713, 561713, 561713, 858673, 788480, 0, 0, 0, 0, 841728, 0, 708608, 1421, 708608, 561657,
  705017, 709113, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 854521, 561713, 705073, 709169, 561713,
  561713, 561713, 561713, 801329, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 561713, 850481, 561713,
  856625, 696320, 0, 0, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561657, 561713, 561713, 561713,
  561713, 561713, 561713, 561713, 561713, 561713, 0, 561657, 723449, 561657, 561657, 829945, 561713, 561713, 723505,
  561713, 561713, 561713, 561713, 830001, 698368, 561657, 561657, 782841, 561657, 807417, 561657, 561657, 821753,
  561657, 836089, 561657, 561657, 868857, 561657, 676345, 561657, 662065, 561713, 561713, 561713, 561713, 827953,
  561657, 737785, 811513, 561657, 561713, 737841, 811569, 561713, 707065, 561657, 694777, 561657, 717305, 561657,
  561657, 561657, 561657, 561657, 561713, 561713, 561713, 561713, 561713, 694833, 700977, 707121, 561713, 561657,
  561713, 561657, 561713, 561657, 561713, 817657, 817713, 0, 0, 0, 0, 0, 0, 0, 192, 212, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1009, 0, 0, 0, 0, 0, 1014, 0, 232, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 0, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 241, 0, 0, 102400, 102400, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 0, 0, 102400, 0, 0, 0, 0, 102400, 102400,
  102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 102400, 0, 102400, 102400, 0, 0,
  102400, 102400, 102400, 102400, 102400, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 1153, 0, 0, 0, 0, 0, 0, 271, 271, 271,
  1272, 271, 271, 271, 271, 271, 271, 534528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 203, 0, 0, 0, 0, 0, 250, 24576, 26624,
  0, 0, 0, 262, 262, 0, 22528, 262, 32768, 0, 0, 0, 739328, 776192, 0, 0, 0, 663552, 663552, 559104, 559104, 559104,
  559104, 559104, 720896, 559104, 559104, 559104, 800768, 559104, 559104, 559104, 849920, 856064, 866304, 0, 0, 0, 0, 0,
  0, 32768, 0, 0, 0, 0, 559104, 681984, 684032, 559104, 559104, 559104, 718848, 0, 104737, 0, 0, 0, 104829, 0, 0, 0, 0,
  0, 0, 104829, 104829, 104829, 104829, 104737, 104737, 104737, 104834, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 1256, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 202, 203, 0, 0, 0, 0, 400, 110592, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 416, 0, 110592,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 669696, 0, 0, 0, 0, 245, 0, 0, 0, 0, 246, 0, 0, 0, 0, 0, 248, 6145, 0, 3, 4,
  0, 0, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736, 116736,
  116736, 116736, 116736, 0, 116736, 116736, 0, 0, 116736, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116736,
  116736, 116736, 116736, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 483, 0, 483, 0, 0, 0,
  0, 0, 442, 112640, 120832, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 0, 0, 112640, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 665600, 669696, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 1052, 323, 323, 323, 323, 323, 358, 358, 358,
  358, 358, 358, 1091, 358, 358, 358, 358, 0, 0, 0, 0, 0, 986, 987, 0, 1131, 0, 0, 0, 118784, 0, 0, 118784, 0, 0, 0, 0,
  0, 118784, 0, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119074, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 51200, 0, 0, 0, 0, 0, 0, 51200, 0, 0, 0, 119074, 119074, 119074, 119074, 6145, 0, 3, 0, 0, 0, 0, 126976, 0,
  0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 1179, 323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 358, 358, 358, 581,
  358, 358, 0, 0, 94208, 0, 0, 0, 0, 0, 0, 202, 203, 0, 0, 0, 0, 0, 0, 0, 6145, 0, 3, 569531, 0, 0, 0, 0, 0, 0, 191, 0,
  0, 0, 0, 0, 0, 122880, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 0, 0, 83968, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  665600, 669696, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 1178, 323, 323, 323, 323, 323, 323, 1201, 323, 323, 323,
  323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 0, 1595, 323, 0, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  271, 1160, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 0, 0, 0, 0, 0, 124928, 0, 0, 124928, 0, 114688, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 665600, 669696, 0, 0, 0, 0, 323, 323, 323, 323, 323, 1049, 323, 323, 323, 323, 323, 323, 0, 0,
  0, 0, 323, 547, 323, 512, 323, 323, 129024, 129024, 129024, 0, 0, 0, 129024, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 6145,
  0, 567482, 4, 0, 65536, 0, 0, 0, 702, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  806, 0, 853, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 1274, 271, 271, 271, 0, 987, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 1352, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 323, 323, 1547, 1548,
  323, 323, 323, 1552, 323, 358, 358, 358, 358, 358, 358, 1579, 358, 358, 0, 1582, 0, 323, 1584, 323, 0, 853, 0, 0, 0,
  0, 0, 0, 857, 0, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1037, 271, 0, 0, 0, 0, 610, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 619, 0, 621, 0, 0, 0, 0, 0, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 288, 0, 288, 288, 0,
  131072, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 999, 0, 0, 0, 0, 131072, 131072, 131072, 0, 6145, 0, 3, 4, 0, 0, 0,
  0, 0, 0, 0, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 0, 71680, 71680, 0, 71680, 71680, 71680, 71680, 71680, 71680, 733184,
  724992, 747520, 0, 0, 0, 0, 1421, 559104, 686080, 559104, 559104, 761856, 559104, 559104, 686080, 0, 0, 0, 133120, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1146, 0, 133120, 0, 0, 0, 0, 133120, 133120, 0, 0, 133120, 0, 0, 133120,
  133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 133120, 0, 133120, 133120, 0, 0, 0,
  133120, 133120, 133120, 133120, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 90409, 90409, 0, 90409, 90409, 0, 0, 0, 0, 90409,
  90409, 90409, 90409, 90409, 90409, 90409, 0, 0, 90409, 0, 0, 0, 692224, 0, 0, 784384, 0, 823296, 858112, 0, 667648, 0,
  1472, 667648, 692224, 559104, 559104, 765952, 772096, 778240, 559104, 786432, 798720, 559104, 559104, 559104, 847872,
  559104, 559104, 559104, 727040, 808960, 561152, 823296, 561152, 561152, 561152, 858112, 788480, 0, 0, 0, 0, 841728, 0,
  708608, 1501, 0, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 206, 0, 0, 206, 247, 206, 0, 0, 0, 207, 0, 206, 206, 207,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 489, 0, 0, 0, 0, 489, 0, 0, 0, 0, 270, 272, 272, 272, 272, 270, 270, 298, 298, 270,
  298, 298, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 320, 324, 272, 320, 324, 343, 347, 347, 359, 347,
  347, 347, 347, 347, 347, 347, 359, 359, 359, 359, 347, 347, 347, 359, 6145, 39097, 3, 4, 0, 0, 0, 0, 388, 0, 0, 403,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 413, 0, 0, 0, 0, 0, 0, 0, 0, 0, 488, 0, 0, 501, 502, 0, 0, 0, 400, 0, 0, 0, 0, 0, 388, 0,
  0, 0, 426, 0, 271, 271, 271, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 702, 323, 323, 454, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 271, 474, 271, 271, 271, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  49908, 534, 323, 323, 541, 323, 323, 0, 0, 438, 426, 323, 323, 508, 323, 323, 323, 323, 0, 358, 562, 358, 358, 358,
  358, 358, 358, 583, 358, 358, 554, 531, 534, 323, 0, 358, 358, 358, 566, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0,
  0, 0, 1421, 323, 323, 1526, 589, 358, 593, 358, 596, 358, 358, 606, 358, 358, 0, 0, 0, 323, 554, 323, 323, 323, 323,
  323, 1292, 323, 323, 1294, 323, 323, 323, 323, 323, 323, 323, 734, 323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323,
  323, 323, 323, 323, 522, 654, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 49908, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 786, 358, 358, 358, 0, 0, 0, 825, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1347, 0, 0, 0, 853, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 862, 271, 271, 271, 271, 271, 867, 271, 271,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 874, 271, 0, 987, 0, 0, 0, 991, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 996, 0, 0, 0, 0, 271, 271, 271, 1030, 271, 271, 271, 271, 271, 271, 271, 271, 1039, 0, 0, 1041, 0, 0, 0, 1039,
  323, 323, 323, 1047, 323, 323, 1050, 1051, 323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 0, 1196, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1206, 323, 358, 358, 358, 358, 0,
  1241, 0, 0, 0, 0, 0, 0, 0, 0, 1250, 1251, 358, 1239, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1249, 0, 0, 0, 0, 0, 1138,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 346112, 346112, 0, 346112, 346112, 0, 1253, 0, 0, 0, 0, 0, 0, 0, 0, 1259, 0, 0, 0, 0,
  0, 0, 0, 106496, 0, 0, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 686, 271, 271, 271, 271, 0, 323, 323, 323,
  1302, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323, 1585, 358, 1391, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 1403, 358, 358, 0, 0, 0, 0, 1410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 227, 228,
  0, 0, 0, 0, 259, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 271, 0, 0, 0, 0, 323, 323, 323, 323, 323, 1285, 323, 323,
  323, 323, 323, 323, 1293, 323, 323, 323, 323, 1296, 323, 323, 323, 1298, 323, 323, 323, 1198, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 358, 358, 1210, 358, 1212, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  974, 358, 1558, 1559, 358, 1561, 358, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 530, 532, 323,
  0, 212, 212, 0, 212, 0, 24576, 26624, 0, 212, 260, 0, 0, 260, 22528, 265, 273, 273, 273, 273, 265, 265, 299, 299, 265,
  299, 299, 265, 265, 265, 265, 315, 265, 318, 319, 318, 319, 319, 319, 319, 319, 319, 319, 265, 325, 273, 265, 325,
  319, 349, 349, 361, 349, 349, 349, 349, 349, 349, 349, 361, 361, 361, 361, 349, 349, 349, 361, 6145, 39097, 3, 4, 0,
  0, 0, 0, 0, 0, 0, 114688, 0, 0, 0, 0, 0, 0, 559104, 559104, 0, 0, 419, 0, 0, 0, 0, 232, 232, 232, 0, 0, 0, 0, 0, 0, 0,
  226, 0, 0, 226, 0, 0, 0, 0, 0, 323, 323, 557, 323, 0, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 801, 358,
  358, 358, 358, 358, 358, 358, 358, 597, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323, 323, 323, 1549, 323, 323, 323,
  323, 358, 358, 1556, 358, 0, 0, 0, 271, 668, 271, 271, 271, 271, 271, 271, 271, 676, 271, 271, 271, 271, 271, 271,
  1166, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 1287, 323, 323, 323, 323, 0,
  358, 563, 358, 358, 358, 358, 358, 358, 584, 358, 358, 714, 323, 323, 323, 323, 718, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 1065, 1066, 323, 323, 323, 702, 757, 759, 358, 358, 358, 358, 358, 767, 358, 771, 358, 358,
  358, 358, 776, 0, 853, 0, 855, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 863, 323, 323, 889, 323, 323, 323, 323, 894,
  323, 323, 323, 323, 323, 323, 323, 323, 908, 323, 323, 323, 323, 323, 323, 323, 946, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 1108, 0, 0, 0, 1018, 853, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271,
  271, 0, 0, 0, 1363, 1289, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0,
  0, 1340, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 834, 0, 0, 0, 323, 323, 323, 323, 323, 1381, 323, 323, 323, 358, 358,
  358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 1421, 323, 1525, 323, 0, 1543, 0, 323, 323, 323, 323, 323, 1550, 323, 323,
  323, 358, 358, 358, 1557, 266, 274, 274, 274, 274, 266, 266, 300, 300, 266, 300, 300, 311, 311, 311, 311, 316, 311,
  311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 311, 326, 274, 311, 326, 311, 350, 350, 362, 326, 350, 350, 350,
  350, 350, 350, 362, 362, 362, 362, 350, 350, 350, 362, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 0, 131072, 131072, 0,
  131072, 131072, 0, 0, 0, 0, 0, 131072, 131072, 131072, 131072, 131072, 131072, 0, 0, 131072, 0, 0, 491, 323, 323, 323,
  323, 323, 323, 323, 522, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323, 550, 323, 636, 0, 0, 0, 0, 0,
  0, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1258, 0, 0, 0, 0, 0, 0, 650, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 1470, 0, 0, 1421, 271, 271, 271, 0, 635, 666, 667, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,
  271, 271, 875, 0, 699, 0, 636, 0, 0, 0, 0, 702, 704, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323,
  551, 523, 323, 727, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 1053, 323, 323, 702, 758, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 1107, 358, 0, 987, 0, 989, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 0, 0, 323, 323, 323, 323, 1072, 1073,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1079, 323, 323, 323, 323, 1121, 1122, 358, 358, 0, 0, 0, 0, 0,
  986, 987, 0, 0, 0, 0, 0, 0, 0, 350208, 350208, 0, 350208, 350208, 0, 350208, 350208, 350208, 0, 0, 0, 0, 1267, 0, 271,
  271, 271, 271, 1273, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1168, 271, 271, 271, 271, 0, 0, 323, 323, 323, 1291,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1208, 358, 358, 1314, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 1322, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 1130, 0, 0, 0, 0, 0, 0, 24576, 26624, 102400, 0, 0,
  0, 0, 0, 22528, 102400, 0, 0, 0, 1417, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 0, 323, 323, 323, 323, 323,
  1477, 323, 1478, 323, 323, 323, 323, 323, 323, 893, 323, 323, 323, 323, 323, 323, 323, 323, 323, 358, 1387, 358, 358,
  358, 358, 358, 323, 1528, 323, 323, 323, 323, 358, 358, 1535, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 346112, 218, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 635, 237, 0, 238, 0, 0, 0, 0, 0, 0, 216,
  237, 0, 0, 0, 0, 0, 0, 0, 565672, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  1054, 323, 0, 218, 216, 0, 218, 0, 24576, 26624, 0, 218, 0, 0, 0, 0, 22528, 267, 275, 275, 275, 275, 291, 291, 301,
  301, 291, 301, 301, 291, 291, 313, 313, 301, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 313, 321, 327, 275,
  321, 327, 313, 351, 351, 363, 382, 351, 351, 351, 351, 351, 351, 363, 363, 363, 363, 351, 351, 351, 363, 6145, 39097,
  3, 4, 0, 0, 0, 0, 0, 0, 0, 565672, 565672, 232, 0, 0, 0, 0, 0, 0, 0, 0, 67584, 202, 203, 98304, 0, 0, 0, 0, 0, 418, 0,
  0, 0, 0, 423, 232, 232, 232, 0, 0, 0, 0, 0, 0, 0, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 216, 0, 237, 0, 237, 0, 0, 0,
  432, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 663, 0, 0, 443, 0, 0, 0, 446, 0, 0, 0, 449, 0, 0, 0, 0, 271,
  271, 271, 271, 271, 271, 1358, 271, 0, 0, 1362, 323, 271, 456, 271, 271, 463, 271, 468, 271, 471, 271, 473, 271, 271,
  271, 271, 0, 323, 323, 323, 323, 1476, 323, 323, 323, 323, 323, 323, 323, 323, 923, 323, 925, 323, 927, 323, 323, 323,
  0, 0, 0, 481, 0, 484, 486, 0, 0, 0, 0, 0, 0, 0, 493, 0, 0, 0, 0, 323, 323, 323, 323, 1048, 323, 323, 323, 323, 323,
  323, 323, 358, 358, 1308, 358, 358, 358, 358, 358, 358, 486, 0, 0, 0, 0, 0, 449, 0, 0, 0, 0, 407, 0, 0, 0, 0, 0, 0,
  24576, 26624, 133120, 0, 0, 0, 0, 0, 22528, 133120, 535, 323, 323, 323, 323, 323, 0, 0, 484, 0, 323, 323, 323, 511,
  323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 1090, 358, 358, 1093, 358, 1095, 529, 323, 535, 558, 0, 358, 358,
  358, 358, 569, 358, 358, 578, 358, 586, 358, 358, 0, 1409, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 590, 358,
  358, 595, 598, 601, 358, 358, 358, 358, 0, 610, 0, 323, 529, 558, 323, 323, 323, 323, 717, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 1374, 323, 323, 323, 323, 323, 323, 729, 323, 323, 323, 323, 323, 323, 736, 323,
  323, 741, 323, 0, 323, 323, 358, 323, 323, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 1312, 358, 702,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 772, 358, 358, 775, 358, 358, 323, 358, 323, 358, 323, 358, 323,
  358, 0, 0, 0, 0, 0, 0, 0, 0, 92160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 395, 396, 0, 0, 0, 0, 0, 358, 790, 358, 358, 358, 358,
  358, 358, 358, 358, 799, 358, 358, 358, 805, 358, 358, 323, 358, 323, 358, 1625, 1626, 323, 358, 0, 0, 0, 0, 0, 0, 0,
  232, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 994, 0, 0, 0, 0, 0, 0, 0, 0, 630, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 660, 0, 0, 0,
  0, 0, 610, 0, 0, 809, 0, 811, 0, 0, 0, 0, 619, 0, 621, 819, 0, 0, 0, 0, 0, 1268, 271, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 271, 271, 271, 479, 0, 0, 0, 0, 841, 0, 0, 0, 0, 0, 847, 0, 0, 850, 0, 0, 0, 0, 0, 415, 0, 0, 0,
  0, 0, 0, 415, 0, 0, 0, 0, 0, 422, 0, 232, 232, 232, 0, 426, 0, 0, 0, 0, 0, 0, 24576, 26624, 0, 0, 259, 0, 0, 259,
  22528, 0, 0, 853, 854, 0, 0, 0, 0, 0, 0, 0, 271, 858, 859, 271, 271, 271, 271, 271, 465, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1480, 271, 864, 271, 866, 271, 271, 271,
  869, 271, 271, 870, 271, 271, 271, 271, 271, 271, 271, 271, 1035, 271, 271, 271, 0, 0, 0, 0, 0, 0, 0, 0, 0, 810, 0, 0,
  702, 323, 323, 886, 887, 323, 323, 323, 323, 323, 323, 323, 323, 896, 323, 323, 899, 323, 323, 323, 323, 323, 358,
  358, 358, 1089, 358, 358, 358, 358, 358, 358, 358, 1102, 358, 358, 358, 358, 358, 358, 358, 358, 1116, 358, 358, 358,
  358, 358, 358, 358, 323, 323, 323, 904, 323, 323, 906, 907, 323, 323, 323, 323, 323, 913, 323, 323, 323, 323, 323,
  358, 358, 1088, 358, 358, 358, 358, 358, 358, 358, 358, 607, 358, 0, 0, 0, 323, 323, 323, 931, 323, 933, 49908, 934,
  358, 935, 358, 358, 938, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 983, 0, 0, 0, 0, 358, 358, 358, 358, 949, 358,
  358, 952, 358, 358, 358, 358, 358, 957, 358, 358, 0, 0, 0, 0, 0, 1411, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 203, 0, 0, 0,
  399, 0, 358, 960, 961, 962, 963, 358, 358, 358, 358, 969, 358, 971, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 1247, 0,
  0, 0, 0, 0, 0, 24576, 61696, 0, 0, 0, 0, 0, 0, 22528, 0, 975, 358, 358, 358, 358, 980, 0, 0, 0, 0, 0, 0, 0, 985, 0,
  986, 0, 987, 0, 0, 0, 0, 0, 0, 0, 995, 0, 0, 0, 0, 0, 0, 0, 232, 232, 0, 0, 0, 0, 0, 0, 649, 0, 0, 0, 1004, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348160, 0, 0, 323, 1083, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  1094, 358, 358, 323, 358, 1623, 1624, 323, 358, 323, 358, 0, 0, 0, 0, 0, 0, 0, 232, 232, 232, 0, 0, 0, 0, 429, 0, 358,
  1097, 358, 1099, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 802, 358, 358, 358, 358, 358, 358, 1111,
  1112, 1113, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 517, 323, 323, 358, 358, 1123, 358, 1125, 0, 0,
  1128, 0, 986, 987, 0, 0, 0, 0, 0, 0, 0, 565673, 67584, 565673, 67584, 0, 0, 0, 0, 0, 0, 0, 1007, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 202, 203, 0, 0, 398, 0, 0, 0, 0, 1150, 0, 1151, 1152, 0, 0, 1154, 0, 0, 0, 0, 0, 271, 271, 1355, 271, 271, 271,
  271, 271, 0, 0, 0, 323, 358, 358, 1226, 358, 1228, 358, 358, 358, 358, 358, 358, 358, 1236, 358, 358, 358, 358, 358,
  780, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 550, 323, 323, 1238, 358, 358, 358, 0, 0, 1242, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 409, 0, 0, 0, 271, 271, 323, 1290, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 726, 1349, 0, 0, 0, 271, 1354, 271, 271, 271, 1357, 271, 1359, 1360, 1361, 0, 323, 323, 323, 746, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 49908, 358, 358, 358, 358, 358, 358, 358, 358, 358, 943, 358, 358, 323,
  1365, 323, 323, 323, 323, 323, 323, 1371, 323, 323, 323, 323, 1375, 1376, 1377, 323, 323, 323, 323, 1380, 323, 323,
  1384, 323, 358, 358, 358, 1389, 358, 358, 358, 358, 358, 795, 358, 358, 358, 358, 358, 358, 358, 804, 358, 358, 358,
  358, 358, 358, 1394, 358, 1396, 358, 358, 358, 358, 358, 358, 1402, 1404, 358, 358, 358, 358, 358, 1329, 358, 358, 0,
  1331, 0, 0, 0, 0, 0, 0, 0, 232, 232, 232, 0, 0, 427, 0, 0, 0, 1406, 1407, 0, 0, 0, 0, 0, 0, 0, 1413, 0, 1414, 0, 1415,
  0, 0, 0, 0, 0, 1341, 0, 0, 0, 0, 0, 1346, 0, 0, 0, 0, 0, 0, 55548, 26624, 0, 0, 0, 0, 0, 0, 22528, 0, 323, 1438, 323,
  323, 1441, 323, 323, 323, 323, 358, 358, 1448, 358, 358, 358, 358, 0, 0, 0, 0, 0, 986, 987, 0, 0, 0, 0, 0, 0, 0, 829,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 0, 0, 0, 665600, 669696, 0, 323, 323, 323, 1483, 323, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 955, 358, 358, 358, 358, 358, 358, 358, 358, 1494, 358, 358, 0, 1496, 0, 0, 0, 0, 0, 0, 1421,
  271, 323, 323, 323, 323, 323, 323, 1507, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 323, 323, 323, 323, 323,
  323, 1514, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 1523, 1421, 323, 323, 323, 323, 323, 323, 1369, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 1372, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1532, 358, 358, 358, 358,
  358, 358, 358, 358, 1541, 0, 0, 0, 0, 421, 0, 0, 232, 232, 232, 0, 0, 0, 0, 0, 0, 0, 232, 232, 0, 0, 0, 0, 647, 0, 0,
  358, 358, 358, 358, 358, 1563, 1564, 0, 1566, 323, 323, 323, 323, 1570, 323, 323, 323, 323, 323, 358, 1087, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 1459, 358, 358, 358, 358, 358, 0, 323, 1574, 358, 358, 1576, 358, 358, 358, 358,
  358, 0, 0, 0, 323, 323, 323, 511, 323, 323, 520, 323, 526, 323, 529, 323, 323, 533, 323, 323, 323, 1600, 358, 1602,
  358, 358, 358, 1606, 323, 323, 323, 323, 323, 323, 323, 1075, 323, 1077, 323, 323, 323, 323, 323, 323, 323, 1306, 358,
  358, 358, 358, 358, 358, 358, 358, 968, 358, 358, 358, 358, 358, 358, 358, 0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1263, 0, 0, 0, 219, 219, 0, 239, 24576, 26624, 0, 0, 0, 261, 261, 0, 22528, 261, 276, 276, 276, 276, 261, 261,
  0, 0, 261, 0, 219, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 261, 328, 276, 261, 328, 344, 328, 328, 364,
  328, 328, 328, 328, 328, 328, 328, 364, 364, 364, 364, 328, 328, 328, 364, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 201,
  201, 0, 0, 201, 201, 63689, 201, 201, 201, 628, 0, 0, 271, 271, 271, 271, 671, 271, 271, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 687, 271, 689, 0, 702, 358, 358, 358, 358, 358, 358, 358, 768, 358, 358, 358, 358, 358, 358, 358,
  0, 0, 1497, 0, 1499, 0, 0, 0, 1421, 323, 323, 323, 323, 1601, 358, 358, 358, 358, 358, 323, 323, 323, 323, 323, 323,
  323, 1383, 323, 358, 358, 358, 358, 358, 358, 358, 1580, 358, 0, 0, 0, 323, 323, 323, 0, 277, 277, 277, 277, 292, 292,
  292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 292, 329, 277, 292, 329, 292, 329, 329, 365, 329, 329, 329, 329,
  329, 329, 329, 365, 365, 365, 365, 329, 329, 329, 365, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 202, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 323, 1429, 323, 323, 323, 323, 323, 1433, 323, 323, 1435, 323, 323, 323, 323, 323, 323, 1382, 323,
  323, 358, 358, 358, 358, 358, 358, 358, 0, 1520, 0, 1522, 0, 1421, 323, 323, 323, 358, 358, 1454, 358, 358, 358, 1457,
  358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 1336, 0, 323, 1481, 323, 323, 323, 358, 358, 358, 358, 358,
  1487, 358, 358, 358, 358, 358, 0, 0, 1565, 323, 323, 323, 323, 323, 323, 323, 323, 1203, 323, 323, 323, 323, 358, 358,
  358, 358, 1492, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 323, 323, 323, 323, 358, 358, 358, 358, 358,
  358, 323, 323, 1608, 1609, 323, 323, 323, 323, 323, 358, 1590, 358, 358, 358, 358, 358, 358, 0, 323, 323, 323, 323,
  715, 323, 323, 323, 323, 323, 323, 323, 323, 323, 49908, 358, 358, 1612, 1613, 358, 358, 323, 323, 323, 323, 358, 358,
  358, 358, 323, 323, 323, 323, 323, 543, 0, 0, 0, 0, 323, 323, 323, 323, 516, 323, 323, 323, 323, 323, 542, 323, 0, 0,
  0, 0, 323, 323, 509, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 724, 323, 725, 323, 323, 0, 0, 638, 0, 0,
  0, 0, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14730, 203, 0, 0, 0, 0, 0, 0, 0, 0, 653, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 559104, 681984, 684032, 559104, 559104, 559104, 718848, 358, 358, 358, 358, 794, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 1105, 358, 358, 358, 358, 0, 0, 0, 0, 990, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1011,
  1012, 0, 0, 323, 323, 323, 323, 1484, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1117, 358, 358, 358, 358,
  0, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 230, 231, 0, 0, 0, 0, 220, 0, 220, 0, 0, 0, 0, 0, 0, 0, 0, 0, 196,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1144, 0, 0, 0, 0, 278, 278, 278, 278, 293, 293, 302, 302, 293, 302, 302, 312, 312,
  314, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 322, 330, 278, 322, 330, 302, 352, 352, 366, 330,
  352, 352, 352, 352, 352, 352, 366, 366, 366, 366, 352, 352, 352, 366, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 203, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 457, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 1474, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1207, 358, 358, 358, 678, 271, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 271, 688, 271, 0, 0, 0, 0, 323, 1281, 323, 1283, 323, 323, 323, 323, 323, 1288, 323, 698, 0, 0, 0,
  0, 0, 0, 0, 702, 323, 323, 323, 708, 323, 323, 323, 323, 323, 323, 1443, 323, 323, 358, 358, 358, 358, 358, 358, 358,
  605, 358, 358, 358, 0, 0, 0, 323, 323, 323, 702, 358, 358, 358, 358, 358, 764, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 608, 0, 0, 0, 516, 323, 323, 358, 358, 358, 779, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 972,
  358, 358, 358, 838, 0, 840, 0, 0, 0, 0, 0, 0, 0, 0, 849, 0, 0, 0, 852, 323, 323, 323, 918, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 1297, 323, 323, 358, 358, 358, 978, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1416, 0, 0, 0, 0, 1137, 0, 0, 0, 1140, 0, 0, 0, 0, 0, 0, 0, 0, 204, 0, 204, 0, 205, 0, 0, 205, 1148, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 0, 1266, 0, 0, 1269, 271, 1271, 271, 271, 271,
  271, 271, 271, 1276, 358, 1326, 358, 358, 1328, 358, 358, 358, 0, 0, 0, 0, 1334, 0, 0, 0, 0, 0, 436, 0, 419, 0, 0, 0,
  0, 441, 0, 0, 0, 0, 0, 380, 0, 0, 0, 0, 0, 0, 380, 380, 380, 380, 0, 0, 0, 380, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0,
  0, 0, 193, 0, 0, 0, 0, 0, 1351, 0, 271, 271, 271, 271, 1356, 271, 271, 271, 0, 0, 0, 323, 1546, 323, 323, 323, 323,
  323, 323, 323, 358, 1555, 358, 358, 358, 1392, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1400, 358, 358, 358, 358,
  0, 0, 0, 0, 0, 1245, 1246, 0, 0, 0, 0, 0, 0, 628, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 410, 0, 0, 0, 271, 271, 358, 358,
  1408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 323, 271, 0, 0, 0, 0, 1467, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 271, 271, 271,
  271, 271, 466, 271, 271, 271, 271, 271, 271, 271, 478, 271, 0, 1527, 323, 323, 1530, 1531, 323, 358, 358, 358, 358,
  1537, 1538, 1539, 1540, 358, 0, 0, 0, 0, 435, 0, 399, 420, 437, 0, 439, 0, 441, 0, 0, 0, 0, 0, 827, 0, 0, 830, 0, 832,
  833, 0, 835, 0, 0, 1586, 323, 323, 323, 323, 358, 358, 358, 1591, 1592, 358, 358, 358, 0, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 751, 323, 323, 323, 323, 49908, 358, 358, 358, 358, 358, 358, 358, 941, 942, 358, 944, 358, 358,
  358, 1621, 1622, 323, 358, 323, 358, 323, 358, 0, 0, 0, 0, 0, 0, 0, 232, 232, 0, 0, 645, 0, 0, 0, 0, 262, 279, 279,
  279, 279, 294, 294, 303, 303, 294, 303, 303, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 331, 279,
  294, 331, 345, 331, 331, 367, 331, 331, 331, 331, 331, 331, 331, 367, 367, 367, 367, 331, 331, 331, 367, 6145, 39097,
  3, 4, 0, 0, 0, 0, 0, 0, 208, 209, 210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 831, 0, 0, 0, 0, 0, 0, 271, 271, 458, 271, 271, 271,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 0, 1280, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1295,
  323, 323, 323, 323, 323, 409, 0, 323, 323, 323, 323, 514, 323, 323, 323, 323, 323, 323, 323, 323, 323, 895, 323, 323,
  323, 323, 323, 323, 0, 0, 0, 625, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 665600, 669696, 0, 0, 323, 323, 709, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 49908, 358, 358, 358, 358, 937, 358, 358, 358, 358, 358, 358, 945,
  702, 358, 358, 358, 358, 358, 358, 765, 358, 358, 358, 358, 358, 358, 358, 358, 783, 358, 358, 358, 358, 358, 358,
  358, 777, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1222, 358, 822, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 836, 0, 0, 0, 0, 483, 0, 0, 0, 0, 0, 0, 0, 0, 483, 0, 0, 0, 0, 0, 86395, 0, 0, 0, 0, 0, 0, 86401,
  86401, 86401, 86401, 0, 0, 0, 86401, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1262, 0, 0, 323, 323,
  323, 890, 891, 892, 323, 323, 323, 323, 323, 323, 323, 323, 900, 323, 323, 323, 323, 323, 1304, 323, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323, 323, 323, 323, 323, 1571, 323, 0, 0, 1017, 0, 0, 0, 0, 0, 0, 271,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 677, 271, 271, 323, 1069, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 909, 0, 1135, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 79872, 0, 271, 1162, 271, 271,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 0, 271, 1277, 0, 0, 0, 323, 323, 1282, 323, 323, 323, 323,
  323, 323, 323, 323, 1062, 323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 1418, 0, 0, 0, 271, 271, 271, 271, 271, 271,
  271, 0, 0, 0, 879, 0, 0, 0, 0, 0, 0, 0, 0, 702, 323, 323, 323, 323, 323, 323, 713, 323, 323, 323, 323, 323, 1589, 358,
  358, 358, 358, 358, 358, 358, 0, 323, 323, 323, 323, 323, 748, 323, 323, 323, 323, 323, 323, 323, 755, 49908, 323,
  323, 323, 323, 358, 358, 358, 358, 358, 358, 323, 1607, 323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 572, 358, 358,
  358, 358, 358, 358, 951, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1320, 358, 358, 358, 358, 358, 358, 358, 358,
  1611, 358, 358, 358, 358, 323, 323, 323, 323, 358, 358, 358, 358, 323, 323, 323, 323, 323, 905, 323, 323, 323, 323,
  910, 323, 323, 323, 323, 323, 323, 1305, 358, 1307, 358, 358, 358, 1310, 358, 358, 358, 0, 0, 0, 193, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 203, 665600, 669696, 0, 0, 280, 280, 280, 280, 0, 0, 304, 304, 0, 309, 304, 304, 304, 304, 304,
  304, 304, 304, 304, 304, 304, 304, 304, 332, 280, 304, 332, 304, 332, 332, 368, 332, 332, 332, 332, 332, 332, 332,
  368, 368, 368, 368, 332, 332, 332, 368, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 210, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271,
  271, 271, 861, 271, 271, 271, 271, 459, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 1279,
  323, 323, 323, 323, 1284, 323, 323, 323, 323, 323, 323, 0, 429, 0, 0, 323, 323, 323, 323, 323, 323, 521, 323, 527,
  323, 323, 323, 323, 323, 0, 0, 410, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 414, 0, 0, 410, 0, 323, 323, 323, 323, 515,
  323, 323, 523, 323, 323, 323, 323, 323, 323, 323, 1444, 323, 358, 358, 358, 358, 358, 358, 358, 797, 358, 358, 358,
  358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 1335, 0, 0, 0, 323, 323, 745, 323, 323, 323, 323, 323, 750, 323, 323, 323,
  323, 323, 49908, 358, 358, 358, 936, 358, 358, 358, 358, 358, 358, 358, 358, 1232, 358, 358, 358, 358, 358, 358, 358,
  702, 358, 358, 358, 358, 358, 358, 766, 358, 358, 358, 358, 358, 358, 358, 358, 953, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 948, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 958, 358, 358, 358, 358, 358, 1395, 358,
  358, 358, 358, 1399, 358, 358, 358, 358, 358, 358, 1215, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1216, 358, 358,
  358, 358, 358, 358, 358, 358, 798, 358, 358, 358, 358, 358, 358, 358, 0, 0, 1003, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 451, 271, 452, 0, 1016, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 1275, 271, 271, 323, 323, 1084,
  323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1220, 358, 358, 358, 358, 358, 358, 1098, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 973, 358, 358, 1338, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 664, 271, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1510, 323, 358, 358, 358, 358, 1577, 1578, 358, 358, 358, 0,
  0, 0, 1583, 323, 323, 358, 358, 358, 358, 358, 1519, 358, 0, 0, 0, 0, 0, 1421, 323, 323, 323, 323, 323, 323, 1533,
  358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 0, 232, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 491, 0, 0, 198, 0, 0, 0, 0, 0, 221, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 281, 281, 281, 281, 295, 295, 305, 295,
  295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 295, 333, 281, 295, 333, 295, 353, 353, 369, 383, 353, 353, 353,
  353, 353, 353, 369, 369, 369, 369, 353, 353, 353, 369, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 253, 253, 0, 0, 0, 0, 0,
  0, 253, 0, 0, 0, 0, 390, 0, 0, 0, 0, 0, 202, 203, 0, 0, 0, 0, 0, 0, 255, 255, 352256, 0, 0, 0, 0, 0, 255, 352256, 0,
  0, 0, 434, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 662, 0, 0, 0, 0, 0, 497, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 451,
  0, 504, 323, 506, 323, 323, 323, 323, 323, 524, 323, 323, 323, 323, 323, 323, 358, 1534, 358, 358, 358, 358, 358, 358,
  358, 0, 0, 0, 0, 0, 1421, 323, 323, 323, 323, 323, 540, 323, 323, 323, 451, 0, 0, 0, 506, 323, 323, 323, 323, 524, 0,
  323, 744, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 49908, 702, 358, 358, 358, 761, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 1235, 358, 358, 358, 358, 0, 0, 1044, 0, 323, 1046, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 1205, 323, 323, 358, 358, 358, 323, 323, 323, 1071, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 898, 323, 323, 323, 358, 358, 1110, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  1120, 1134, 0, 1136, 0, 0, 0, 1139, 0, 0, 1141, 0, 0, 0, 0, 0, 1147, 271, 271, 1163, 271, 271, 1165, 271, 271, 1167,
  271, 271, 271, 271, 271, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 1286, 323, 323, 323, 323, 0, 358, 358, 358, 358,
  358, 358, 358, 358, 580, 358, 358, 1172, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 1180, 323, 323, 323, 323,
  323, 358, 358, 358, 358, 358, 358, 358, 358, 1490, 358, 358, 323, 323, 323, 1185, 323, 323, 323, 323, 323, 323, 1192,
  323, 323, 323, 323, 323, 323, 1060, 323, 323, 323, 323, 323, 323, 323, 323, 323, 358, 1447, 358, 358, 358, 358, 358,
  1224, 358, 358, 358, 358, 358, 358, 358, 358, 1233, 358, 358, 358, 358, 358, 358, 323, 323, 323, 323, 358, 358, 358,
  358, 323, 323, 0, 0, 0, 1254, 0, 0, 0, 0, 1257, 0, 0, 1260, 0, 0, 0, 0, 0, 203, 0, 0, 0, 0, 0, 0, 203, 203, 203, 203,
  1299, 323, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1542, 358, 1315, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1237, 358, 0, 0, 0, 1339, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220,
  0, 0, 0, 0, 1350, 0, 0, 1353, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 323, 323, 508, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 531, 323, 1364, 323, 323, 323, 323, 323, 323, 1370, 323, 323, 323, 1373, 323, 323, 323, 323, 0, 358,
  358, 358, 358, 358, 573, 358, 358, 582, 358, 358, 323, 323, 323, 323, 323, 1442, 323, 323, 323, 358, 358, 358, 358,
  1449, 1450, 1451, 323, 323, 1529, 323, 323, 323, 358, 358, 358, 1536, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323,
  1568, 1569, 323, 323, 323, 323, 0, 0, 1544, 323, 323, 323, 323, 323, 323, 1551, 323, 1553, 358, 358, 358, 358, 0, 0,
  0, 1243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 203, 0, 100352, 0, 0, 0, 358, 358, 1560, 358, 1562, 0, 0, 0, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 753, 323, 323, 49908, 1597, 1598, 323, 323, 358, 358, 1603, 1604, 358, 358,
  323, 323, 323, 323, 323, 323, 544, 0, 0, 0, 507, 323, 323, 323, 323, 525, 0, 222, 224, 243, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 229, 0, 0, 0, 224, 0, 224, 223, 0, 0, 24576, 26624, 0, 0, 225, 224, 224, 225, 22528, 268, 282, 282, 282, 282,
  268, 268, 306, 306, 268, 306, 310, 268, 268, 268, 268, 317, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268, 268,
  268, 334, 282, 268, 334, 268, 334, 334, 370, 334, 334, 334, 334, 334, 334, 334, 370, 370, 370, 370, 334, 334, 334,
  370, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 393, 0, 0, 202, 203, 0, 0, 0, 0, 0, 0, 398, 0, 0, 0, 0, 0, 441, 0, 0, 0,
  389, 0, 0, 0, 391, 392, 0, 0, 0, 202, 203, 0, 0, 0, 0, 0, 0, 407, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 860, 271,
  271, 271, 401, 0, 0, 404, 405, 406, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18432, 0, 0, 0, 0, 0, 0, 401, 444, 445, 0, 0, 0,
  404, 0, 0, 0, 0, 0, 271, 271, 271, 670, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1170, 0,
  455, 271, 271, 462, 271, 271, 271, 470, 271, 271, 271, 271, 476, 271, 271, 0, 0, 878, 0, 0, 881, 0, 0, 0, 0, 809, 809,
  702, 885, 323, 0, 0, 487, 0, 498, 0, 0, 0, 0, 0, 444, 0, 0, 404, 404, 0, 0, 0, 0, 613, 0, 0, 0, 0, 0, 619, 621, 0, 0,
  0, 0, 0, 0, 24576, 26624, 69632, 0, 0, 0, 0, 0, 22528, 69632, 0, 0, 323, 323, 510, 513, 323, 519, 323, 323, 323, 528,
  323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 574, 358, 358, 358, 358, 358, 358, 1230, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 1321, 358, 358, 358, 358, 358, 536, 538, 323, 323, 323, 323, 0, 445, 0, 0, 323, 323, 548, 549,
  323, 323, 323, 323, 323, 920, 323, 323, 323, 323, 323, 323, 323, 928, 929, 323, 555, 323, 536, 538, 0, 358, 358, 358,
  568, 571, 358, 577, 358, 358, 358, 588, 591, 358, 358, 358, 599, 602, 358, 358, 358, 358, 0, 0, 0, 323, 323, 538, 0,
  651, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 626, 0, 0, 0, 0, 323, 323, 323, 730, 323, 323, 323,
  323, 323, 323, 323, 739, 323, 323, 323, 0, 348, 348, 360, 348, 348, 348, 348, 348, 348, 348, 360, 360, 360, 360, 348,
  348, 348, 360, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 559104, 559104, 559104, 702464,
  559104, 559104, 559104, 559104, 0, 0, 0, 561657, 358, 791, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 803, 358,
  358, 358, 358, 358, 950, 358, 358, 358, 358, 358, 358, 956, 358, 358, 358, 358, 358, 964, 965, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 1234, 358, 358, 358, 358, 358, 323, 902, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 915, 323, 916, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 930, 358, 976, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1132, 0, 323, 323, 323, 1058, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 912, 323, 323, 323, 1252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  665, 323, 323, 1366, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1068, 323, 323, 323, 323,
  323, 323, 1485, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 518, 323, 323, 271, 323, 323, 323, 323,
  323, 1506, 323, 323, 323, 323, 323, 358, 358, 358, 1513, 199, 0, 0, 0, 199, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  335, 271, 0, 0, 0, 0, 240, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 0, 22528, 0, 0, 0, 0, 626, 0, 0, 0, 0, 0, 632, 0, 0, 0,
  0, 0, 0, 271, 1270, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 872, 271, 271, 271, 335, 0, 354, 354,
  371, 354, 354, 354, 354, 354, 354, 354, 371, 371, 371, 371, 354, 354, 354, 371, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0,
  447, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 673, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1038,
  0, 0, 0, 0, 323, 323, 716, 323, 323, 323, 323, 323, 323, 323, 722, 323, 323, 323, 323, 323, 323, 1074, 323, 323, 323,
  1078, 323, 1080, 323, 323, 323, 702, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 774, 358, 358, 358, 358,
  358, 1100, 1101, 358, 358, 358, 358, 358, 358, 358, 358, 358, 808, 808, 0, 0, 0, 0, 0, 0, 815, 986, 1015, 0, 0, 0, 0,
  0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 675, 271, 271, 271, 271, 271, 271, 1029, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 0, 1040, 0, 0, 0, 0, 0, 1419, 0, 0, 1422, 271, 271, 271, 271, 271, 271, 0, 323, 323, 323, 1475,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 1386, 358, 358, 358, 358, 358, 358, 323, 323, 1057, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 1227, 358, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 1401, 358, 358, 358, 271, 271, 460, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271,
  271, 0, 0, 1278, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 754, 323, 49908, 0, 0, 480, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 480, 0, 0, 0, 0, 0, 0, 0, 480, 0, 323, 323, 323, 323, 516, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 924, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1440, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358,
  358, 358, 0, 323, 323, 358, 1453, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 515, 323,
  323, 0, 232, 0, 0, 0, 0, 226, 0, 0, 0, 0, 0, 0, 226, 0, 0, 0, 0, 0, 59392, 0, 0, 59392, 0, 59392, 0, 59392, 59392,
  59392, 59392, 0, 0, 0, 59392, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 118784, 0, 0, 0, 0, 0, 0, 226, 226, 0, 0, 226, 0, 24576,
  26624, 0, 226, 0, 226, 226, 0, 22528, 226, 283, 283, 283, 283, 226, 226, 0, 0, 226, 0, 0, 226, 226, 226, 226, 226,
  226, 226, 226, 226, 226, 226, 226, 336, 283, 226, 336, 226, 336, 336, 372, 336, 336, 336, 336, 336, 336, 336, 372,
  372, 372, 372, 336, 336, 336, 372, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 615, 616, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1142,
  0, 0, 0, 0, 0, 417, 0, 0, 0, 0, 0, 0, 232, 232, 232, 0, 0, 0, 0, 0, 430, 431, 0, 433, 0, 0, 0, 0, 0, 0, 0, 0, 0, 441,
  0, 0, 0, 0, 0, 614, 0, 0, 0, 0, 619, 621, 0, 0, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59392, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 495, 496, 0, 0, 495, 0, 0, 0, 0, 0, 0, 500, 0, 0, 0, 0, 0, 627, 0, 0, 0, 631, 0, 0, 0, 0, 0, 0, 0, 232,
  232, 232, 0, 0, 0, 428, 0, 0, 323, 556, 323, 539, 0, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1461, 358,
  358, 358, 0, 358, 592, 594, 358, 358, 603, 358, 358, 358, 358, 0, 0, 0, 323, 323, 539, 323, 323, 323, 323, 0, 0, 0, 0,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 1181, 323, 323, 0, 0, 652, 0, 0, 0, 656, 0, 441, 0, 0, 0, 661, 0, 0, 0,
  0, 0, 641, 642, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 627, 0, 0, 0, 0, 323, 323, 728, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323, 323, 552, 656, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 49908, 778, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 1118, 358, 358, 789, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1463, 358, 0,
  876, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 702, 323, 323, 323, 323, 323, 323, 323, 323, 323, 917, 323, 919, 323, 921,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 1204, 323, 323, 323, 358, 358, 358, 358, 358, 977, 358, 979, 358, 0, 0,
  0, 0, 982, 0, 984, 0, 0, 0, 0, 0, 655, 0, 658, 441, 0, 0, 0, 0, 0, 0, 0, 0, 702, 323, 323, 323, 323, 709, 323, 323,
  1001, 1002, 0, 0, 0, 0, 0, 0, 1008, 0, 0, 0, 0, 0, 1013, 0, 0, 0, 0, 640, 0, 0, 232, 232, 0, 0, 0, 0, 0, 648, 0, 0, 0,
  0, 323, 323, 1176, 323, 323, 323, 323, 323, 323, 323, 323, 323, 721, 323, 323, 323, 323, 323, 323, 271, 271, 271, 271,
  1031, 1032, 1033, 271, 271, 271, 271, 271, 0, 0, 0, 0, 0, 0, 0, 0, 883, 0, 0, 0, 702, 323, 323, 1042, 0, 0, 0, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 0, 358, 1109, 358, 358, 358, 358, 1114, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 1115, 358, 358, 358, 358, 358, 358, 1119, 358, 358, 358, 358, 1124, 0, 0, 0, 0,
  1129, 0, 0, 0, 0, 0, 0, 1133, 271, 1502, 323, 323, 323, 323, 323, 323, 323, 1509, 323, 323, 1511, 358, 358, 358, 358,
  358, 1214, 358, 358, 1217, 358, 1219, 358, 358, 358, 358, 358, 358, 966, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  1103, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1518, 358, 358, 0, 0, 0, 0, 0, 1421, 323, 323, 323, 323,
  323, 358, 358, 358, 358, 358, 358, 358, 1092, 358, 358, 358, 358, 358, 604, 358, 358, 358, 358, 0, 0, 0, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 752, 323, 323, 323, 49908, 323, 323, 1599, 323, 358, 358, 358, 358, 1605, 358,
  323, 323, 323, 323, 323, 323, 719, 323, 323, 323, 323, 323, 323, 323, 323, 323, 909, 323, 323, 323, 323, 323, 323, 0,
  232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 236, 0, 0, 0, 0, 654, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0, 0, 0, 816, 619, 818,
  621, 0, 0, 0, 249, 0, 0, 0, 0, 251, 24576, 26624, 0, 0, 0, 249, 249, 0, 22528, 269, 284, 284, 284, 284, 269, 269, 0,
  0, 269, 248, 0, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 337, 284, 269, 337, 346, 355, 355, 373,
  337, 355, 355, 355, 355, 355, 355, 373, 373, 373, 373, 355, 355, 355, 373, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 692,
  0, 702, 703, 705, 323, 323, 323, 710, 323, 442, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 442, 271, 453, 0, 483, 323, 507,
  323, 323, 323, 323, 323, 525, 323, 323, 323, 323, 323, 323, 720, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1191,
  323, 323, 323, 323, 323, 323, 0, 0, 0, 612, 0, 0, 0, 0, 0, 0, 619, 621, 0, 0, 0, 622, 660, 0, 0, 271, 271, 669, 271,
  672, 271, 674, 271, 271, 271, 271, 271, 271, 271, 271, 271, 1036, 271, 271, 0, 0, 0, 0, 271, 679, 271, 271, 271, 271,
  271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 0, 700, 701, 0, 694, 702, 323, 323, 706, 323, 323, 712, 323,
  323, 323, 323, 323, 1367, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 926, 323, 323, 323, 323, 323, 715,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 723, 323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 575, 358, 358, 358,
  358, 358, 358, 1330, 358, 0, 0, 0, 0, 0, 0, 0, 0, 0, 202, 14733, 0, 0, 0, 0, 0, 702, 358, 358, 358, 358, 762, 358,
  358, 769, 358, 358, 773, 358, 358, 358, 358, 0, 0, 1127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 411, 0, 0, 0, 0, 0, 0, 823, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104712, 0, 0, 839, 0, 0, 0, 0, 0, 0, 846, 0, 0, 0, 0, 0, 0, 0, 0, 441, 659, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 1045, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 738, 323, 323, 323, 0, 323,
  323, 323, 323, 1085, 1086, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 609, 0, 323, 323, 323, 0, 1173, 0, 0,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1437, 323, 323, 323, 323, 1186, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 911, 323, 323, 323, 323, 358, 1225, 358, 358, 358, 358, 358, 1231, 358, 358, 358,
  358, 358, 358, 358, 358, 1397, 1398, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 1498, 0, 0, 0, 0, 1421, 323, 323,
  1301, 323, 1303, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1458, 358, 358, 358, 358, 358, 358, 358, 0, 0,
  0, 0, 0, 0, 1500, 0, 1421, 358, 358, 358, 1317, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1324, 358, 358, 358,
  358, 358, 1456, 358, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 1337, 0, 1466, 0, 0, 1468, 0, 0, 0,
  0, 0, 0, 0, 1421, 271, 271, 271, 271, 271, 467, 271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 271, 323, 323, 323,
  1504, 1505, 323, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 358, 0, 323, 1596, 358, 1515, 1516, 358,
  358, 358, 358, 0, 0, 0, 0, 0, 1421, 323, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 358, 1489, 358, 358, 358,
  358, 358, 1229, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 609, 380, 0, 323, 323, 323, 0, 0, 0, 1545, 323, 323,
  323, 323, 323, 323, 323, 323, 1554, 358, 358, 358, 358, 358, 1318, 358, 358, 358, 358, 358, 358, 358, 1323, 358, 358,
  0, 285, 285, 285, 285, 0, 296, 307, 307, 296, 307, 307, 296, 296, 296, 296, 307, 307, 307, 307, 307, 307, 307, 307,
  307, 307, 307, 307, 296, 338, 285, 296, 338, 307, 356, 356, 374, 384, 356, 356, 356, 356, 356, 356, 374, 374, 374,
  374, 356, 356, 356, 374, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 812, 0, 0, 0, 619, 0, 621, 0, 0, 0, 0, 0, 0, 420, 0, 0,
  0, 232, 232, 232, 0, 0, 0, 0, 0, 0, 0, 232, 232, 232, 65536, 0, 0, 0, 0, 0, 0, 0, 0, 482, 0, 485, 0, 0, 0, 0, 0, 0, 0,
  0, 485, 0, 0, 0, 0, 810, 0, 0, 0, 0, 0, 619, 0, 621, 0, 0, 0, 0, 0, 843, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1157, 0, 0,
  271, 271, 537, 323, 323, 323, 323, 323, 0, 0, 485, 545, 546, 323, 323, 323, 323, 553, 323, 323, 537, 323, 0, 358, 564,
  358, 358, 358, 358, 358, 579, 585, 587, 358, 358, 358, 358, 358, 1495, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 358, 358,
  358, 358, 600, 358, 358, 358, 358, 358, 0, 0, 0, 323, 323, 323, 512, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  737, 323, 323, 323, 323, 0, 0, 0, 624, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 634, 0, 0, 0, 0, 826, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 1261, 0, 0, 0, 0, 637, 0, 0, 0, 0, 0, 232, 232, 643, 644, 0, 0, 0, 0, 0, 0, 828, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 619, 0, 621, 0, 0, 0, 271, 680, 271, 681, 271, 271, 271, 271, 684, 685, 271, 271, 271, 271, 271, 0, 0, 0, 0,
  842, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 271, 271, 271, 0, 0, 0, 662, 0, 0, 0, 0, 0, 0, 0, 695, 0, 0, 0, 0, 0,
  222, 223, 224, 225, 0, 0, 0, 0, 0, 0, 0, 0, 409, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 342, 271, 0, 0, 0, 695, 0, 0,
  0, 644, 695, 702, 323, 323, 707, 323, 323, 323, 323, 0, 358, 358, 358, 358, 358, 576, 358, 358, 358, 358, 358, 358,
  1615, 323, 323, 323, 1617, 358, 358, 358, 323, 323, 323, 358, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0,
  323, 323, 323, 323, 731, 732, 323, 323, 323, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323, 517, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 1445, 358, 358, 358, 358, 358, 358, 358, 0, 743, 323, 323, 323, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 49908, 702, 358, 358, 760, 358, 763, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 0, 610, 0, 323, 323, 323, 358, 358, 792, 793, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1462,
  358, 358, 0, 271, 271, 865, 271, 271, 271, 868, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 873,
  271, 271, 271, 877, 0, 0, 0, 880, 0, 0, 0, 0, 0, 884, 877, 702, 323, 323, 323, 323, 323, 1059, 323, 1061, 323, 1063,
  323, 323, 323, 1067, 323, 323, 323, 323, 323, 1187, 1188, 323, 323, 323, 323, 323, 1194, 323, 323, 1195, 323, 888,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 897, 323, 323, 323, 323, 0, 358, 358, 358, 567, 358, 358, 358, 358, 358,
  358, 358, 0, 0, 1521, 0, 0, 1421, 323, 323, 323, 323, 323, 903, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 323, 358, 1209, 358, 323, 932, 323, 49908, 358, 358, 358, 358, 358, 939, 358, 358, 358, 358, 358, 358, 323, 323,
  323, 1616, 358, 358, 358, 1618, 323, 323, 0, 1043, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  1436, 323, 323, 323, 1070, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1081, 323, 323, 0, 1149,
  0, 0, 0, 0, 0, 0, 0, 1155, 0, 0, 0, 0, 271, 271, 271, 271, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 206, 24576, 26624, 0,
  257, 0, 0, 0, 0, 22528, 257, 1161, 271, 271, 271, 1164, 271, 271, 271, 271, 271, 271, 271, 271, 271, 0, 1171, 0, 0, 0,
  0, 1174, 323, 323, 323, 323, 1177, 323, 323, 323, 323, 323, 323, 733, 323, 323, 323, 323, 323, 740, 323, 323, 0, 1182,
  323, 1184, 323, 323, 323, 323, 1189, 323, 323, 323, 323, 323, 323, 323, 323, 1190, 323, 323, 323, 323, 323, 323, 323,
  358, 358, 358, 358, 1213, 358, 358, 358, 358, 358, 358, 358, 358, 1221, 358, 1223, 323, 1300, 323, 323, 323, 323, 323,
  358, 358, 358, 358, 358, 358, 1311, 358, 1313, 358, 358, 1316, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 1325, 1378, 323, 1379, 323, 323, 323, 323, 323, 1385, 358, 358, 1388, 358, 358, 358, 358, 0, 1126, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 1143, 0, 0, 0, 0, 358, 358, 1393, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1405,
  0, 1427, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1434, 323, 323, 323, 323, 0, 358, 358, 565, 358, 570, 358, 358,
  358, 358, 358, 358, 0, 0, 0, 981, 0, 0, 0, 0, 0, 0, 0, 232, 232, 0, 0, 0, 646, 0, 0, 0, 358, 358, 358, 358, 1455, 358,
  358, 358, 358, 358, 1460, 358, 358, 358, 358, 1464, 323, 323, 1482, 323, 323, 358, 358, 358, 358, 1486, 358, 358, 358,
  358, 358, 358, 781, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1319, 358, 358, 358, 358, 358, 358, 358, 358, 0, 0,
  1332, 1333, 0, 0, 0, 0, 358, 358, 358, 1493, 358, 358, 358, 0, 0, 0, 0, 0, 0, 0, 0, 1421, 1573, 358, 358, 358, 358,
  358, 358, 358, 358, 1581, 0, 0, 0, 323, 323, 323, 1430, 1431, 1432, 323, 323, 323, 323, 323, 323, 323, 323, 1076, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 1587, 1588, 323, 358, 358, 358, 358, 358, 1593, 1594, 358, 0, 323, 323, 323,
  323, 747, 323, 323, 749, 323, 323, 729, 323, 323, 323, 49908, 358, 358, 358, 358, 358, 358, 940, 358, 358, 358, 358,
  358, 0, 0, 0, 323, 1567, 323, 323, 323, 323, 323, 323, 0, 0, 0, 0, 323, 323, 323, 323, 518, 323, 358, 1620, 323, 358,
  323, 358, 323, 358, 323, 358, 0, 0, 0, 0, 0, 0, 0, 232, 232, 96256, 0, 0, 0, 0, 0, 0, 0, 0, 69632, 69632, 0, 0, 0, 0,
  0, 0, 0, 0, 79872, 0, 79872, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20480, 0, 0, 0, 244, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 437, 0, 271, 271, 0, 286, 286, 286, 286, 0, 0, 308, 308, 0, 308, 308, 0, 308, 308, 308, 308, 308, 308,
  308, 308, 308, 308, 308, 308, 308, 339, 286, 308, 339, 308, 339, 339, 375, 339, 339, 339, 339, 339, 339, 339, 375,
  375, 375, 375, 339, 339, 339, 375, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 844, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 619, 0,
  621, 0, 0, 821, 623, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 697, 358, 358, 947, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 800, 358, 358, 358, 358, 358, 959, 358, 358, 358, 358, 358, 358, 967, 358, 358,
  358, 358, 358, 358, 358, 358, 782, 358, 358, 784, 358, 358, 358, 358, 358, 358, 323, 323, 323, 323, 358, 358, 358,
  358, 323, 1619, 1096, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 954, 358, 358, 358,
  358, 358, 323, 323, 323, 323, 358, 358, 358, 358, 358, 358, 323, 323, 323, 323, 1610, 323, 323, 323, 323, 323, 1368,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1064, 323, 323, 323, 323, 323, 358, 358, 358, 358, 1614, 358, 323,
  323, 323, 323, 358, 358, 358, 358, 323, 323, 323, 323, 323, 1200, 323, 1202, 323, 323, 323, 323, 323, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 358, 358, 785, 358, 358, 787, 788, 0, 0, 0, 230, 0, 0, 24576, 26624, 0, 0, 0, 0, 0, 0,
  22528, 0, 0, 0, 0, 853, 0, 0, 0, 0, 271, 271, 271, 271, 271, 271, 271, 271, 0, 0, 0, 323, 0, 271, 271, 271, 271, 0, 0,
  0, 231, 0, 0, 230, 0, 0, 0, 0, 0, 230, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 340, 271, 0, 340, 0, 340, 340, 376, 340,
  340, 340, 340, 340, 340, 340, 376, 376, 376, 376, 340, 340, 340, 376, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 856, 0, 0,
  0, 271, 271, 271, 271, 271, 271, 271, 271, 271, 472, 271, 271, 477, 271, 271, 0, 702, 358, 358, 358, 358, 358, 358,
  358, 358, 770, 358, 358, 358, 358, 358, 358, 796, 358, 358, 358, 358, 358, 358, 358, 358, 358, 1218, 358, 358, 358,
  358, 358, 358, 901, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 659, 1465, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1421, 271, 271, 271, 271, 271, 682, 271, 683, 271, 271, 271, 271, 271, 271, 271, 0, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 1479, 323, 263, 287, 287, 287, 287, 263, 263, 0, 0, 263, 0, 0, 263, 263,
  263, 263, 263, 263, 263, 263, 263, 263, 263, 263, 341, 287, 263, 341, 263, 341, 341, 377, 341, 341, 341, 341, 341,
  341, 341, 377, 377, 377, 377, 341, 341, 341, 377, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 992, 0, 0, 0, 0, 0, 997, 0, 0,
  0, 323, 1183, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1082, 342, 0, 342, 342, 378,
  342, 342, 342, 342, 342, 342, 342, 378, 378, 378, 378, 342, 342, 342, 378, 6145, 39097, 3, 4, 0, 0, 0, 0, 0, 0, 1006,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 618, 620, 0, 665600, 669696, 0, 271, 271, 461, 271, 271, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 0, 0, 0, 0, 853, 0, 0, 0, 0, 271, 271, 1024, 1025, 271, 271, 271, 271, 271, 271, 271, 1034, 271,
  271, 271, 271, 0, 0, 0, 0, 0, 0, 0, 882, 0, 0, 0, 0, 702, 323, 323, 503, 0, 323, 323, 323, 323, 518, 323, 323, 323,
  323, 323, 323, 323, 323, 323, 922, 323, 323, 323, 323, 323, 323, 323, 323, 735, 323, 323, 323, 323, 323, 323, 0, 0,
  402, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 354304, 0, 323, 323, 323, 559, 0, 358, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 970, 358, 358, 358, 358, 358, 0, 0, 0, 639, 0, 0, 0, 232, 232, 0, 0, 0, 0, 0, 0, 0, 0, 814, 0,
  619, 0, 621, 0, 0, 0, 0, 0, 824, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 696, 0, 0, 1028, 271, 271, 271, 271, 271, 271,
  271, 271, 271, 271, 271, 0, 0, 0, 0, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 1055, 1056, 323, 323,
  323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323, 742, 0, 323, 323, 1197, 323, 1199, 323, 323, 323, 323,
  323, 323, 323, 323, 358, 358, 358, 358, 1309, 358, 358, 358, 358, 1211, 358, 358, 358, 358, 358, 358, 358, 358, 358,
  358, 358, 358, 358, 358, 358, 1104, 358, 1106, 358, 358, 358, 358, 358, 358, 1240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  440, 0, 0, 0, 0, 232, 0, 346112, 0, 0, 0, 346112, 346112, 346112, 0, 0, 0, 0, 0, 0, 0, 408, 409, 0, 0, 0, 0, 0, 0, 0,
  0, 224, 0, 0, 0, 0, 0, 0, 0, 0, 271, 271, 271, 271, 271, 1425, 271, 0, 0, 0, 0, 0, 346112, 0, 346112, 0, 0, 0, 346112,
  346112, 0, 0, 0, 0, 346112, 0, 0, 0, 0, 0, 346112, 346112, 0, 0, 0, 0, 0, 346112, 346112, 346366, 346366, 0, 0, 0, 0,
  0, 0, 346366, 0, 0, 0, 0, 853, 0, 0, 0, 1022, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 271, 871, 271, 271,
  271, 271, 0, 0, 0, 346112, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0, 0, 346112, 0, 0, 0, 0, 0, 0,
  0, 346112, 346112, 0, 0, 0, 0, 0, 0, 1255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 488, 0, 0, 0, 0, 0, 346112, 0, 0, 346112,
  346112, 346112, 0, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 1342, 1343, 0, 1344, 0, 0, 0, 0, 0, 1348, 350208, 350208, 350208,
  350208, 350208, 350208, 350208, 350208, 350208, 350208, 350208, 350208, 350208, 0, 350208, 350208, 0, 350208, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 559104, 559104, 0, 0, 0, 350208, 350208, 350208, 350208, 6145, 0, 3, 4, 0, 0, 0, 0,
  0, 0, 1420, 0, 271, 271, 1423, 1424, 271, 271, 271, 0, 352256, 232, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 770048,
  0, 352256, 0, 0, 0, 0, 352256, 352256, 0, 0, 352256, 0, 0, 352256, 352256, 352256, 352256, 352256, 352256, 352256,
  352256, 352256, 352256, 352256, 352256, 0, 352256, 352256, 0, 352256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 851,
  0, 0, 0, 352256, 0, 352256, 352256, 352256, 352256, 6145, 0, 3, 4, 0, 0, 0, 0, 0, 0, 1469, 0, 0, 0, 0, 0, 1421, 271,
  271, 271, 0, 0, 0, 0, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51200, 0, 51200, 0, 0, 0, 0, 51200, 51200, 51200,
  51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 0, 51200, 51200, 0, 0, 51200, 51200, 51200,
  51200, 51200, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 619, 0, 621, 0, 820, 0, 0, 0, 692224, 0, 0, 784384, 0, 823296, 858112, 0,
  667648, 0, 0, 667648, 692224, 559104, 808960, 561152, 823296, 561152, 561152, 561152, 858112, 788480, 0, 0, 0, 0,
  841728, 0, 708608, 0, 0, 0, 0, 853, 0, 1020, 1021, 0, 271, 271, 271, 271, 271, 1027, 271, 271, 271, 271, 464, 271,
  469, 271, 271, 271, 271, 475, 271, 271, 271, 0, 0, 0, 0, 323, 1175, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,
  323, 1193, 323, 323, 323, 323
);

(:~
 : The DFA-state to expected-token-set mapping.
 :)
declare variable $p:EXPECTED as xs:integer+ :=
(
  39, 71, 134, 165, 197, 102, 229, 261, 321, 1101, 1101, 1101, 1110, 415, 352, 447, 796, 509, 541, 573, 605, 637, 477,
  669, 701, 733, 765, 828, 1016, 859, 383, 891, 954, 985, 1048, 922, 289, 1081, 1077, 1142, 2435, 1146, 1150, 1164,
  1164, 1164, 1164, 1159, 1163, 1164, 1164, 1165, 1164, 2473, 1169, 1173, 1177, 1181, 1185, 1189, 1193, 1197, 1201,
  1210, 2511, 2434, 2434, 2567, 1215, 2434, 1643, 2204, 1951, 1262, 2215, 2434, 2434, 2434, 2434, 1615, 2228, 2229,
  1615, 1230, 1222, 1222, 1227, 1239, 1244, 2434, 2434, 2567, 1418, 2543, 1271, 2213, 1262, 1262, 1263, 2434, 2434,
  2434, 2228, 2228, 2228, 1293, 1222, 1222, 1288, 2434, 2204, 1263, 1615, 2228, 2228, 1293, 1222, 1298, 2434, 1823,
  1303, 2228, 1235, 1222, 1298, 2204, 2343, 1306, 1298, 1760, 1305, 1298, 2226, 1306, 2228, 2228, 2228, 1616, 2227,
  2344, 1222, 1222, 1222, 1222, 1222, 1222, 1250, 1244, 2434, 2434, 2434, 2434, 1256, 1261, 1262, 1262, 1267, 2225,
  2228, 2228, 2228, 2228, 2228, 2228, 2503, 1222, 1222, 1222, 1222, 1223, 1289, 1275, 2434, 2434, 2434, 1734, 1825,
  1262, 1281, 1614, 2228, 2228, 2228, 2228, 2228, 1235, 1222, 1222, 1222, 1222, 1222, 1287, 2511, 2434, 2434, 2434,
  2205, 1262, 1826, 1614, 2228, 2228, 2228, 2228, 1235, 1222, 1222, 1222, 1222, 1287, 2434, 2434, 2434, 2205, 1262,
  2500, 2228, 2228, 2228, 1234, 1222, 1222, 1222, 1222, 2434, 2434, 2434, 2206, 1827, 2505, 2228, 1293, 1311, 1235,
  1299, 1306, 1233, 1294, 1307, 1315, 1318, 1323, 2270, 1329, 1333, 1336, 1336, 1336, 1345, 1338, 1342, 1336, 1336,
  1349, 1352, 1924, 1356, 1360, 1363, 1367, 1371, 1375, 1379, 1383, 1325, 2497, 2434, 2434, 2434, 2149, 2434, 2434,
  2434, 1388, 2434, 2434, 2159, 1795, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2182, 2170, 2434, 2434,
  2434, 2434, 1887, 2434, 2434, 2571, 2433, 2434, 2434, 2434, 2434, 1498, 2434, 2566, 2434, 2434, 2257, 2577, 2434,
  2571, 2433, 2434, 2434, 2434, 2421, 2565, 2434, 2434, 2420, 2434, 2434, 2434, 2434, 1393, 2434, 2434, 2434, 2434,
  2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 1416, 2434, 2434, 2434,
  2434, 2434, 2434, 1393, 2434, 1788, 1792, 1790, 2434, 2434, 1494, 2434, 1461, 1465, 2434, 2434, 2434, 1457, 1704,
  1502, 2434, 2434, 2434, 1533, 2434, 1506, 1510, 2434, 2434, 2434, 1588, 1517, 2309, 1514, 1216, 2434, 1805, 2375,
  2316, 2434, 2434, 1817, 2381, 2295, 1384, 2302, 1678, 2391, 2434, 1883, 2315, 2434, 2434, 2397, 2066, 2401, 2198,
  1662, 2434, 1490, 1211, 2434, 2005, 2405, 2245, 2111, 2392, 1930, 1408, 2434, 2086, 1423, 1427, 1431, 1435, 1439,
  1442, 1446, 1450, 1451, 1455, 1496, 2434, 1461, 1465, 2434, 2434, 2434, 1469, 1155, 2188, 1476, 2434, 2573, 2387,
  2434, 1480, 1484, 1488, 2434, 2434, 2357, 2434, 1523, 1404, 2434, 2434, 1154, 2448, 1528, 2434, 1532, 2554, 1537,
  1581, 2434, 2434, 2434, 1472, 2434, 1556, 1560, 1950, 2434, 2434, 2434, 1794, 1778, 1464, 2434, 2434, 1989, 1985,
  2434, 2434, 2422, 1205, 2434, 2329, 1257, 1548, 2434, 1217, 2458, 2273, 2434, 1683, 1993, 2434, 2434, 1997, 2434,
  2434, 2407, 2002, 2434, 2434, 2241, 2434, 2329, 1252, 2434, 2434, 2434, 1798, 1414, 2434, 1251, 1958, 1573, 1656,
  1661, 2434, 1640, 2021, 1647, 2434, 2434, 2434, 1651, 2434, 2161, 1959, 1655, 1660, 1666, 2020, 1670, 2434, 2434,
  1674, 2434, 1688, 1574, 1692, 1978, 2020, 1699, 2434, 1628, 2011, 1708, 1715, 1722, 1711, 2434, 1551, 1728, 1732,
  1738, 1744, 1748, 1753, 1552, 1749, 1754, 1785, 2092, 2578, 1758, 1758, 1764, 1765, 1766, 1770, 1772, 2434, 2434,
  2195, 1204, 2434, 2434, 1550, 1776, 2434, 1777, 2112, 1782, 1802, 1809, 1814, 1821, 1831, 1842, 1835, 1839, 1846,
  1850, 1852, 1854, 2234, 1858, 2434, 2434, 1863, 2434, 1546, 2336, 2434, 1869, 2434, 1876, 2434, 1880, 1891, 1895,
  2595, 1283, 1899, 1519, 1906, 2434, 1910, 2434, 1543, 2241, 2434, 2434, 1863, 2434, 1547, 2429, 1869, 2434, 1914,
  1921, 2377, 1928, 1917, 2465, 2434, 1934, 1941, 2434, 2434, 1945, 2434, 2434, 2259, 1937, 1949, 2434, 2434, 2241,
  2434, 1610, 2434, 1955, 1963, 1869, 2434, 1972, 2434, 2494, 1976, 2434, 1982, 2018, 2434, 2434, 1998, 1549, 2434,
  2009, 1218, 2434, 2058, 2046, 2434, 2367, 2434, 2434, 2015, 2004, 2434, 2241, 2327, 2434, 2026, 2434, 2037, 2010,
  1411, 2196, 2434, 2370, 2434, 2044, 1777, 2513, 2434, 1612, 2026, 2567, 2276, 2040, 2434, 2369, 2434, 2052, 2434,
  2434, 2330, 1796, 2073, 2039, 2038, 2446, 2032, 2056, 2434, 2062, 2197, 2278, 2444, 2434, 2070, 2434, 2434, 1567,
  2383, 2434, 1717, 2151, 2077, 1718, 2033, 2434, 1568, 2385, 1724, 2033, 1268, 1269, 1270, 2560, 2562, 2434, 2434,
  2434, 2083, 2434, 2434, 2434, 1684, 2090, 1389, 1865, 2434, 1246, 2096, 2103, 2107, 2099, 2116, 2120, 2124, 2126,
  2130, 2133, 2134, 2434, 2065, 2434, 2434, 1684, 2090, 2138, 2142, 2307, 2434, 1623, 2434, 2146, 2422, 2434, 2156,
  2167, 2434, 1740, 2176, 2181, 2186, 2434, 2192, 2177, 2064, 1796, 2434, 2163, 1564, 2434, 1572, 1578, 1585, 2434,
  2434, 1471, 1635, 1592, 1596, 1950, 2434, 2434, 2434, 1797, 1524, 2434, 2434, 1154, 1600, 2434, 1626, 1604, 1608,
  2434, 1977, 1620, 2022, 1632, 1684, 2090, 2139, 2305, 2434, 2203, 2434, 1319, 2210, 2234, 2413, 1702, 2434, 2434,
  2434, 2219, 2223, 2233, 2238, 2434, 2434, 2434, 1859, 2249, 2255, 2064, 1796, 2434, 2263, 2350, 2267, 2434, 2334,
  2434, 2434, 2434, 2340, 2251, 2064, 1796, 1240, 2348, 2141, 2314, 1276, 2355, 1810, 2434, 1394, 2354, 2434, 2317,
  2434, 2434, 1395, 1540, 2064, 1796, 2361, 2302, 2365, 1636, 1965, 2411, 2453, 2434, 2417, 2426, 1871, 2458, 2439,
  2110, 2452, 2588, 2199, 2453, 2589, 1872, 2459, 1676, 2457, 2463, 2586, 2587, 2585, 2469, 2472, 1153, 1797, 2434,
  2434, 2434, 2434, 2434, 1217, 2572, 2433, 2553, 2434, 2079, 2243, 2434, 2434, 2434, 1967, 2031, 2563, 2434, 2434,
  2434, 2434, 2434, 1887, 2434, 2434, 2393, 2376, 1419, 2434, 2078, 1901, 2434, 2434, 2434, 2558, 2563, 2477, 2485,
  2371, 2491, 2481, 2479, 2172, 2509, 2517, 2521, 2525, 2527, 2531, 2535, 2538, 2542, 2434, 2434, 2434, 2434, 1217,
  2572, 2431, 1206, 1796, 2512, 2434, 1966, 2512, 2434, 1901, 2434, 2434, 2028, 2434, 2549, 2434, 2032, 2030, 2434,
  2434, 2434, 2434, 1217, 2572, 2432, 2434, 2512, 2434, 2434, 1966, 2512, 2434, 2244, 2434, 2434, 2434, 2434, 2048,
  2077, 2434, 2566, 2434, 2434, 2282, 2434, 1777, 2434, 2434, 1394, 2286, 1216, 2487, 2335, 2434, 2434, 2434, 1695,
  2290, 2434, 2294, 2434, 1240, 2299, 2140, 2313, 2434, 1277, 2356, 2063, 2434, 2434, 2321, 2325, 2434, 2434, 2434,
  2152, 2031, 2434, 2434, 2434, 2547, 1680, 2434, 2512, 2434, 2434, 2442, 1902, 2434, 2434, 2434, 2434, 1968, 2434,
  2564, 2434, 2434, 2434, 2434, 2434, 1886, 2434, 2434, 2434, 1218, 2582, 2434, 2434, 2434, 2593, 2565, 2434, 2257,
  2594, 1681, 2434, 1679, 2563, 2434, 2032, 1682, 2434, 2549, 2434, 2566, 2434, 2434, 2434, 2434, 2434, 2434, 2434,
  2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434, 2434,
  2434, 2434, 2434, 2434, 2434, 2434, 2357, 2434, 2434, 2032, 1399, 1403, 2434, 2434, 2434, 2599, 2790, 2961, 2870,
  2636, 2625, 2963, 2645, 2635, 2641, 2643, 2644, 2963, 2963, 2963, 2924, 2929, 2731, 2646, 2641, 2648, 2650, 2644,
  2644, 2644, 2644, 2647, 2655, 2644, 2644, 2654, 2671, 2680, 2682, 2696, 2697, 2702, 2698, 2698, 2697, 2698, 2698,
  2696, 2699, 2702, 2683, 2701, 2704, 2726, 3063, 2707, 2706, 2706, 2709, 2712, 2710, 2714, 2716, 2718, 2673, 2868,
  2870, 2963, 2600, 2963, 2963, 2963, 2675, 2861, 2963, 2963, 2730, 2789, 2788, 2870, 2963, 2963, 2963, 2608, 2789,
  3062, 3062, 3062, 3062, 2620, 3062, 2728, 2943, 2725, 2725, 2852, 3062, 2725, 2725, 2725, 3061, 3062, 2627, 2963,
  2963, 2963, 2609, 2628, 2629, 2610, 2963, 2607, 2964, 2743, 2963, 2963, 2963, 2615, 2872, 2664, 2963, 2963, 2963,
  2616, 2792, 2666, 2666, 2666, 2666, 2657, 2657, 2963, 2963, 2963, 2622, 2963, 2963, 2830, 2629, 2963, 2963, 2963,
  2628, 2667, 2666, 2666, 2963, 2963, 2612, 3105, 3062, 3062, 2963, 2963, 2963, 2629, 3061, 3062, 3062, 3062, 2725,
  3062, 3062, 3062, 2853, 2725, 2666, 2943, 2725, 2725, 2725, 3062, 3062, 2725, 3062, 2963, 2943, 2725, 3062, 3061,
  3061, 3061, 2963, 2963, 2963, 2633, 2658, 2932, 2841, 2963, 2607, 2963, 2754, 2988, 2754, 2747, 2777, 2781, 2753,
  2754, 2754, 2754, 2754, 2765, 2767, 2780, 2781, 2782, 2754, 2761, 2754, 2763, 2754, 2774, 2780, 2754, 2776, 2754,
  2768, 2797, 2798, 2754, 2748, 2749, 2751, 2750, 2805, 2804, 2805, 2807, 2756, 2820, 2820, 2758, 2757, 2755, 2963,
  2922, 2809, 2754, 2811, 2813, 2815, 2814, 2817, 2819, 2822, 2963, 2963, 2658, 2786, 2938, 2963, 2963, 2963, 2657,
  2787, 2963, 2963, 2963, 2661, 2735, 2609, 2691, 2836, 2802, 2800, 2918, 2870, 2963, 2963, 2609, 2838, 2840, 2963,
  2608, 3143, 2789, 2917, 2963, 2963, 2732, 2963, 2963, 2963, 2610, 2863, 2963, 2601, 2885, 2602, 2963, 2965, 2850,
  2849, 2604, 2888, 2893, 2889, 2890, 2891, 2895, 2898, 2898, 2897, 2900, 2905, 2905, 2905, 2902, 2901, 2903, 2907,
  2908, 2907, 2907, 2907, 2910, 2911, 2912, 2963, 2963, 2615, 3010, 2608, 2771, 2693, 2724, 2789, 2917, 2919, 2963,
  2963, 2921, 2963, 2963, 2631, 2847, 3050, 2623, 2623, 2948, 2940, 2963, 2949, 2940, 2967, 2759, 2969, 2940, 2639,
  2971, 2940, 2963, 2963, 2663, 2668, 2793, 2963, 2963, 2858, 2963, 2963, 2618, 2622, 2982, 2984, 2986, 2870, 3042,
  2963, 2883, 2990, 2667, 2992, 2996, 2870, 3007, 2832, 2992, 3000, 2870, 2963, 2963, 2678, 3110, 2658, 2723, 2802,
  2800, 3050, 2975, 3009, 2986, 2870, 2963, 2963, 3044, 2786, 2963, 3043, 2876, 2982, 2665, 2954, 3203, 2963, 2611,
  2940, 2963, 2616, 2632, 3209, 2963, 2963, 2963, 2722, 2789, 2873, 2876, 2621, 2974, 2665, 2944, 2791, 3013, 3028,
  3031, 3210, 2870, 2963, 2622, 2964, 2963, 2963, 2860, 2963, 2963, 2730, 2963, 3017, 3017, 2859, 2665, 2976, 3012,
  3014, 2919, 3012, 2996, 2870, 2963, 2626, 2733, 2998, 2875, 2621, 2676, 3045, 2667, 2945, 3012, 3028, 2963, 3018,
  3031, 3186, 3017, 2736, 2667, 2791, 3020, 2870, 2963, 2963, 2722, 2987, 2963, 2963, 2725, 2725, 2725, 2668, 3025,
  3028, 2870, 2963, 2633, 2853, 2963, 2638, 2963, 2963, 2722, 2802, 2944, 2791, 3027, 3050, 2963, 2963, 2963, 2667,
  2733, 3025, 3028, 2963, 2658, 2721, 2675, 2944, 2791, 3027, 2841, 2691, 2802, 2800, 2841, 2638, 2875, 3018, 2976,
  3012, 3012, 2956, 2963, 2963, 2963, 2668, 2963, 2963, 3152, 3028, 2687, 2945, 3012, 3028, 2658, 3030, 2789, 2963,
  2674, 2963, 2963, 2963, 2874, 2963, 2963, 2963, 2878, 2609, 2615, 2933, 3018, 3035, 2687, 3048, 2956, 2963, 2660,
  2662, 3206, 2687, 3048, 2848, 2963, 2669, 2963, 2963, 2937, 2879, 2615, 3035, 2963, 2873, 2621, 3213, 3036, 3038,
  3048, 2963, 2963, 2733, 2963, 2783, 2733, 2962, 2963, 2963, 2733, 2964, 2963, 2933, 2925, 3048, 2963, 2962, 2963,
  2963, 2737, 2963, 3047, 3036, 2963, 2963, 2741, 3184, 2963, 2963, 3052, 2674, 2873, 2942, 3215, 2963, 2963, 2963,
  3054, 2962, 2963, 2963, 2873, 2942, 2963, 2963, 2801, 2725, 2799, 3054, 2963, 2963, 3054, 2963, 2963, 2942, 2963,
  2942, 2942, 2963, 2840, 2987, 2963, 2963, 2963, 2691, 3060, 2943, 2963, 2722, 2674, 3054, 2963, 2729, 2963, 2973,
  2980, 2794, 2963, 2963, 2677, 2963, 2963, 2963, 2658, 3030, 2744, 2692, 3065, 2963, 2733, 2662, 2665, 2963, 2963,
  2987, 2963, 2963, 2615, 2688, 3067, 2963, 2733, 2662, 2736, 2692, 2886, 2963, 2963, 2831, 2666, 2666, 2666, 2963,
  2943, 3002, 3069, 3002, 3003, 3073, 3075, 3077, 3083, 3078, 3078, 3078, 3078, 3004, 3005, 3071, 3078, 3080, 3079,
  3081, 3085, 3086, 3085, 3085, 3085, 3085, 3088, 2963, 2784, 2963, 2963, 2963, 2719, 3030, 2987, 2963, 2963, 2842,
  2668, 2963, 3094, 2963, 2963, 2854, 2963, 2731, 3091, 2927, 2978, 2870, 2926, 2977, 2870, 2963, 2734, 2724, 2963,
  2769, 2618, 2630, 2963, 2963, 3097, 3099, 2940, 2963, 3022, 2823, 3101, 3107, 2870, 2963, 2963, 2871, 2963, 2963,
  2963, 2963, 3113, 2940, 3115, 3117, 3107, 2940, 2873, 2864, 2694, 2856, 3055, 2963, 3111, 2946, 2961, 2870, 2963,
  2779, 2754, 2768, 2946, 2869, 2963, 2608, 2628, 2608, 2873, 2880, 2613, 2637, 2665, 2867, 3128, 2866, 2946, 3021,
  2870, 2963, 2963, 3121, 3123, 3021, 2919, 2963, 2963, 2963, 2666, 2615, 3130, 2858, 2933, 3018, 3031, 2933, 2963,
  2963, 2963, 3040, 2963, 2963, 2963, 2871, 2618, 2630, 2608, 2772, 2789, 3095, 3022, 2963, 2963, 2963, 2733, 2848,
  2963, 2880, 2739, 2656, 2789, 3133, 3108, 2963, 2964, 2880, 2739, 2685, 2656, 2789, 2841, 2963, 2964, 3123, 2963,
  2963, 2843, 2800, 2918, 2963, 2963, 2963, 2735, 2963, 3138, 2674, 2963, 2963, 2924, 2964, 2880, 3143, 2789, 3134,
  2963, 2963, 2875, 2621, 2745, 2665, 2616, 2858, 2963, 2963, 2876, 2630, 2963, 2963, 2963, 2964, 2622, 2608, 2789,
  2963, 2963, 2963, 2738, 2789, 2964, 2685, 2843, 3058, 2963, 2963, 2875, 3156, 2963, 3142, 2789, 2987, 3146, 3149,
  2963, 2963, 2878, 2685, 2963, 3180, 2963, 2963, 2963, 2769, 2677, 2963, 2963, 3142, 3149, 2963, 2789, 2963, 2789,
  2622, 2963, 2963, 2963, 2770, 2963, 2963, 2963, 3154, 2963, 2792, 2845, 2684, 2865, 2785, 2962, 2963, 2873, 3055,
  3155, 2630, 3159, 2842, 3092, 3093, 2913, 2799, 2657, 2963, 3023, 3161, 3157, 3162, 2963, 2799, 2963, 2963, 2963,
  2882, 2914, 3171, 2915, 3164, 3165, 3168, 3166, 3166, 3170, 3171, 3171, 3171, 3173, 3172, 3174, 3176, 3177, 3176,
  3176, 3176, 3176, 3179, 2963, 2943, 2963, 2861, 2963, 2622, 2958, 3023, 2633, 3144, 3001, 2963, 2825, 2783, 2963,
  2963, 2964, 2876, 2615, 3001, 2626, 2963, 2827, 2963, 2963, 2615, 2933, 2615, 2859, 2963, 2963, 3182, 2963, 2834,
  2740, 2963, 2608, 2690, 3188, 2963, 2963, 2963, 2795, 2950, 2963, 2963, 2963, 2829, 3190, 3193, 2963, 2963, 2936,
  2940, 2719, 3191, 3193, 2963, 2841, 2963, 2963, 2963, 2674, 2963, 2614, 2633, 2963, 2963, 2963, 2830, 2666, 2666,
  2667, 3033, 2987, 2963, 2842, 2666, 2666, 2666, 3185, 2741, 3131, 2667, 2791, 3033, 2940, 2963, 2963, 2943, 2725,
  2725, 2725, 2725, 2963, 3214, 2963, 2963, 2963, 2841, 2963, 3197, 2955, 2963, 2846, 2963, 2963, 2872, 2963, 2963,
  2953, 3199, 2667, 2867, 3032, 2996, 2963, 3015, 2940, 2963, 2963, 2963, 3125, 2880, 2613, 2608, 2771, 2672, 3095,
  2733, 2957, 2959, 2941, 3049, 2988, 2963, 2608, 2731, 2674, 2787, 2674, 2963, 2963, 3148, 2963, 3201, 3039, 2987,
  2663, 2667, 2791, 3203, 2954, 2791, 2960, 2919, 2963, 2964, 3208, 2963, 2963, 2865, 2785, 2962, 2943, 2963, 2607,
  2622, 2958, 3040, 2942, 2963, 2963, 2883, 2621, 2958, 2931, 2963, 2963, 2963, 2856, 2963, 2963, 2738, 2662, 2665,
  2976, 3032, 2987, 2963, 2963, 2963, 3136, 2963, 2963, 2616, 3126, 2955, 2963, 2963, 2963, 2851, 2660, 2662, 2736,
  2667, 2725, 2725, 2725, 3039, 2865, 2785, 2963, 2668, 2963, 2607, 2663, 2667, 3203, 2963, 2963, 2963, 2858, 2963,
  2864, 2672, 2786, 2959, 2942, 2963, 2963, 2963, 3140, 2963, 2963, 2963, 2740, 3039, 2963, 2963, 2963, 2873, 2694,
  2667, 2930, 2963, 2963, 2963, 3151, 2963, 2963, 2878, 2952, 2963, 2943, 2963, 2963, 2963, 2881, 2733, 2735, 2724,
  2857, 2963, 2963, 3094, 2943, 2724, 2789, 2963, 2964, 2880, 2686, 2963, 3212, 2963, 2963, 2963, 3195, 2735, 2802,
  2674, 2964, 2618, 2963, 2963, 2963, 3089, 2872, 2963, 2993, 2963, 2851, 2963, 2963, 2873, 2963, 2963, 2963, 2963,
  2606, 2963, 2855, 2789, 2871, 2610, 2963, 2963, 2964, 2987, 2963, 2963, 2878, 2619, 2614, 2730, 2789, 2963, 2963,
  2614, 2731, 2674, 2963, 2963, 2855, 2854, 2731, 2674, 2963, 3119, 2963, 2855, 2963, 2855, 2730, 2644, 2644, 2644,
  2652, 2689, 2614, 2658, 2963, 2963, 2658, 2659, 2608, 2658, 2690, 2963, 2963, 2963, 3205, 2740, 2963, 2690, 2608,
  2731, 2994, 2963, 2783, 2934, 2657, 2963, 2943, 2725, 3039, 3062, 3062, 2853, 2963, 3217, 2614, 2628, 2610, 2963,
  2963, 2963, 2600, 3218, 3219, 3220, 3222, 3223, 3232, 3224, 3233, 3226, 3225, 3226, 3226, 3227, 3228, 3230, 3229,
  3237, 3238, 3237, 3235, 3236, 3237, 3240, 3242, 3243, 3245, 2963, 2963, 2963, 2934, 2963, 2881, 2963, 2963, 2964,
  2963, 2628, 2963, 2963, 2963, 3041, 2617, 3156, 2622, 2963, 2733, 2963, 2963, 2963, 2783, 2963, 2963, 2963, 2787,
  2608, 2882, 2963, 2963, 2963, 2940, 3247, 2963, 2963, 2963, 3057, 2603, 2963, 2873, 2963, 2854, 2731, 2963, 2854,
  2731, 2674, 2799, 2873, 2877, 2963, 2963, 2963, 3103, 4, 262144, 0, -2147352576, 16, 0, -1035857887, 134225920, 8192,
  0, 16, 64, 0, 28, 448, 2048, 0, 32, 2, 4, 8, 32, 32, 128, 0, 40, 603979776, 0, 48, 0, 64, 64, 128, 512, 0, 96,
  603987968, 8192, 8192, 16384, 0, 46, 16793600, 268451840, 1073758208, 16384, 16384, 16448, 16448, 268451840,
  268451840, 1073758208, -2147467264, 67144064, 536908416, 4228224, 16793600, 16384, 65536, 0, 256, 4, 192, 512, 3072,
  32768, 32768, 65536, 65536, 131072, 0, 288, 16793600, 65536, 262144, 1048576, 0, 512, 4096, 0, 768, 81920, 81920,
  81984, 50348032, 131072, 16, 192, 16384, 131072, 32, 256, 256, 1024, 1024, 2048, 8192, 50348032, 1124089856, 50348032,
  50348032, 1392525312, 1124155392, 1124089856, 1124089856, 147456, 1124089856, 268582912, 147456, 139264, 1350713464,
  -796770184, -796770184, -779992968, -796770184, -779992968, 1124220928, 50479104, 1124220928, 1401045112, 4, 224,
  32896, 0, 1024, 32768, 131072, 131072, 139264, 48, 56, 0, 16384, 524288, 0, 128, 3072, 16384, 32768, 0, 192, 256, 0,
  224, 48, 32, 512, 16384, 1, 3, 258342979, -1889134379, -1889134379, 258343123, 16777217, 1, 1, -1889134377,
  -1889134377, 526844139, 0, 151552, 1, 16385, 131073, 3, 67, 268435459, 131137, 65, 1, 2, 64, 256, 16384, 67, 3, 1, 65,
  32769, 131139, 65, 65537, 131073, 1, 0, 262144, 67108864, 0, 524288, 524288, 1048576, 2097152, 4194304, 0, -536870912,
  0, -402653184, 10223616, 131139, 0, 1048576, 4194304, 131072, 524288, -1889134379, 258343127, 258343127, 526778587,
  258349271, 1, 33562624, 1, 7, 1082918401, 1082924689, 1082924689, 1082924691, 1083055761, -1889134377, -1889101609,
  -1889101609, -1889134377, 1340999379, 0, 2113536, 1, 16384, 6291456, 201326592, 8912896, 0, 4194304, 65536, 393216,
  1024, 15204352, 2048, 32768, 2048, 4198400, 131072, 536870912, 0, 65536, 524288, 16, 536870912, 262144, 402653184, 0,
  5768448, 0, 8388608, 8519680, 0, 2048, 16384, 1572864, 0, 4096, 24576, 0, 8192, 80, 16, 256, 65536, 1572864, 2097152,
  134217728, -2147483648, 0, 2, 0, 4, 0, 6, 8, 0, 8, 8, 16, 32, 0, 14, 537001984, 0, 8389120, -1035857879, -968724440,
  -1035857879, 67133448, -1035857879, -968724440, -968724440, 67133448, 67133448, 72901896, -968749015, -968749015,
  -968732631, -968724439, -968748951, -807145426, -968724423, -968724439, -968724439, -1576274, -1576274, -270011730,
  -1576274, -1576273, -1576273, 0, 8585312, 1619198048, 8585312, 4194304, 536870912, 1073741824, -2147483648, 80, 0,
  9175552, 32, 33554432, 4, 10240, 3686400, 1280, 1572864, 8388608, 16777216, 33554432, 0, 32768, 135168, 37748736, 0,
  9961472, -1073741824, 0, 16777216, 0, 131072, 262144, 2097152, 83886080, 159744, 104857600, 0, 25296896, 24576,
  67108864, 131072, 1572864, 134217728, 0, 33554432, 1048576, 8388608, 134217728, 268435456, 0, 0, 1, -2113798112,
  1597440, 71303168, 159744, 104, 258048, 266338304, 174, 512, 28672, 131072, 2097152, 218103808, 268435456, 520192,
  534773760, 32, 28672, 131072, 37748736, 67108864, 1073741824, 0, 33562624, 32, 61440, 65011712, 67108864, 1048576,
  268435456, 134217728, 1073741824, 512, 393216, 402653184, 1610612736, 0, 67109120, -1657247468, -1927272188,
  -650614764, 512, 61440, 4194304, 33554432, 1572864, 4194304, 58720256, 67108864, 134217728, 536870912, 6, 32, 16384,
  58720256, 134217728, 805306368, 0, 67371008, 512, 262144, 58720256, 402653184, 536870912, 1024, 131072, 4194304,
  8388608, 536870912, 131072, 33554432, 268435456, 32, 131072, 8388608, 0, 20480, 28672, 0, 24576, 32768, 4, 25165824,
  33554432, 536870912, -2147483648, 1024, 524288, 4, 16777216, 268435456, 1024, 1048576, 536870912, 2, 131072, 8519680,
  8519680, 1342308472, 33558528, 262144, 33558528, 536870912, 67109120, 1073741824, -1724356588, -1927272188,
  -1187485676, -1724355564, -1658820348, -1658820348, -1657771756, -1657247468, -1657247468, -1657116364, -1120310820,
  -1648858348, -650613740, -1657247468, -42341923, -42341923, -46568996, -42341923, 0, 536870912, 20, 256, 8454208, 256,
  67108864, 268435456, 20, 3686400, 150994944, 268435456, 20, 3162112, 52, 3817472, 10240, 3751936, 218103808,
  805306368, 1073741824, 226492416, 0, 805306368, 29, 7979008, 29, 448, 10240, 7979008, 48, 1703936, 1, 32768, 4194304,
  1073741824, 1, 4, 16384, 4194304, 83886080, 2, 512, 35840, 4194304, 67108864, 805306368, 1024, 1073741824, 16, 524288,
  1, 1073741824, 1, 192, 65536, 8519680, 192, 524288, 192, 1048576, 1073741824, 1, 128, 262144, 1, 4098, 8, 64, 8208,
  33558528, 8192, 8454208, 65536, 16777216, 545456224, 1610612768, 545456224, 545456224, 1677983776, 1610620976,
  1610621232, 1619198048, 1619198048, 545456224, -521957664, 1635975264, -386150684, -386150684, -387723552, -386150684,
  0, 1073741824, 304, 0, 36352, 65536, 33554432, -2147483648, 14811136, -536870912, 4, 52736, 65536, 16384000,
  -402653184, 32, 1073741824, 4, 52224, 512, 52224, 64, 65536, 8388608, 1073741824, 4, 49152, 65536, 2, 4096, 33554432,
  1073741824, 3072, 131072, 25165824, 0, 268435456, 4864, 4864, 2112, 66, 322, 66, 2112, 1026, 1042, 3138, 3138, 3394,
  206, 3394, 3394, 1058, 2112, 3138, 207, 463, 207, 207, 206, 463, 2255, 207, 3535, 3535, 3279, 0, 8, 128
);

(:~
 : The token-string table.
 :)
declare variable $p:TOKEN as xs:string+ :=
(
  "EPSILON",
  "END",
  "DirCommentContents",
  "IntegerLiteral",
  "DecimalLiteral",
  "DoubleLiteral",
  "StringLiteral",
  "PredefinedEntityRef",
  "'""""'",
  "EscapeApos",
  "ElementContentChar",
  "QuotAttrContentChar",
  "AposAttrContentChar",
  "S",
  "S",
  "CharRef",
  "NCName",
  "QName",
  "PITarget",
  "CommentContents",
  "PragmaContents",
  "DirPIContents",
  "CDataSection",
  "Wildcard",
  "EOF",
  "'!='",
  "'""'",
  "'#)'",
  "'$'",
  "''''",
  "'('",
  "'(#'",
  "'(:'",
  "')'",
  "'*'",
  "'*'",
  "'+'",
  "'+'",
  "','",
  "'-'",
  "'-->'",
  "'.'",
  "'..'",
  "'/'",
  "'//'",
  "'/>'",
  "':)'",
  "'::'",
  "':='",
  "';'",
  "'<'",
  "'<!--'",
  "'</'",
  "'<<'",
  "'<='",
  "'<?'",
  "'='",
  "'>'",
  "'>='",
  "'>>'",
  "'?'",
  "'?>'",
  "'@'",
  "'['",
  "']'",
  "'ancestor'",
  "'ancestor-or-self'",
  "'and'",
  "'as'",
  "'ascending'",
  "'at'",
  "'attribute'",
  "'base-uri'",
  "'binary'",
  "'boundary-space'",
  "'by'",
  "'case'",
  "'cast'",
  "'castable'",
  "'catch'",
  "'child'",
  "'collation'",
  "'comment'",
  "'construction'",
  "'copy-namespaces'",
  "'declare'",
  "'default'",
  "'descendant'",
  "'descendant-or-self'",
  "'descending'",
  "'div'",
  "'document'",
  "'document-node'",
  "'element'",
  "'else'",
  "'empty'",
  "'empty-sequence'",
  "'encoding'",
  "'eq'",
  "'every'",
  "'except'",
  "'external'",
  "'following'",
  "'following-sibling'",
  "'for'",
  "'full'",
  "'function'",
  "'ge'",
  "'greatest'",
  "'gt'",
  "'idiv'",
  "'if'",
  "'import'",
  "'in'",
  "'inherit'",
  "'instance'",
  "'intersect'",
  "'is'",
  "'item'",
  "'lax'",
  "'le'",
  "'least'",
  "'let'",
  "'lt'",
  "'mod'",
  "'module'",
  "'namespace'",
  "'ne'",
  "'no-inherit'",
  "'no-preserve'",
  "'node'",
  "'of'",
  "'option'",
  "'or'",
  "'order'",
  "'ordered'",
  "'ordering'",
  "'parent'",
  "'preceding'",
  "'preceding-sibling'",
  "'preserve'",
  "'private'",
  "'processing-instruction'",
  "'property'",
  "'return'",
  "'satisfies'",
  "'schema'",
  "'schema-attribute'",
  "'schema-element'",
  "'self'",
  "'some'",
  "'stable'",
  "'strict'",
  "'strip'",
  "'stylesheet'",
  "'text'",
  "'then'",
  "'to'",
  "'treat'",
  "'try'",
  "'typeswitch'",
  "'union'",
  "'unordered'",
  "'validate'",
  "'variable'",
  "'version'",
  "'where'",
  "'xquery'",
  "'{'",
  "'{{'",
  "'|'",
  "'}'",
  "'}}'"
);

(:~
 : Match next token in input string, starting at given index, using
 : the DFA entry state for the set of tokens that are expected in
 : the current context.
 :
 : @param $input the input string.
 : @param $begin the index where to start in input string.
 : @param $token-set the expected token set id.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:match($input as xs:string,
                         $begin as xs:integer,
                         $token-set as xs:integer) as xs:integer+
{
 (: let $result := $p:INITIAL[1 + $token-set]:)
  let $result := fn:subsequence($p:INITIAL,1 + $token-set,1)
  return p:transition($input,
                      $begin,
                      $begin,
                      $begin,
                      $result,
                      $result mod 2048,
                      0)
};

(:~
 : The DFA state transition function. If we are in a valid DFA state, save
 : it's result annotation, consume one input codepoint, calculate the next
 : state, and use tail recursion to do the same again. Otherwise, return
 : any valid result or a negative DFA state id in case of an error.
 :
 : @param $input the input string.
 : @param $begin the begin index of the current token in the input string.
 : @param $current the index of the current position in the input string.
 : @param $end the end index of the result in the input string.
 : @param $result the result code.
 : @param $current-state the current DFA state.
 : @param $previous-state the  previous DFA state.
 : @return a sequence of three: the token code of the result token,
 : with input string begin and end positions. If there is no valid
 : token, return the negative id of the DFA state that failed, along
 : with begin and end positions of the longest viable prefix.
 :)
declare function p:transition($input as xs:string,
                              $begin as xs:integer,
                              $current as xs:integer,
                              $end as xs:integer,
                              $result as xs:integer,
                              $current-state as xs:integer,
                              $previous-state as xs:integer) as xs:integer+
{
  if ($current-state = 0) then
    let $result := $result idiv 2048
    return
      if ($result != 0) then
      (
        $result mod 256 - 1,
        $begin,
        $end - $result idiv 256
      )
      else
      (
        - $previous-state,
        $begin,
        $current - 1
      )
  else
    let $c0 := (string-to-codepoints(substring($input, $current, 1)), 0)[1]
    (:let $c0 := fn:subsequence($input-cp,$current,1):)
    let $c1 :=
      if ($c0 < 128) then
        (:$p:MAP0[1 + $c0]:)
         fn:subsequence($p:MAP0,1 + $c0,1) 
      else if ($c0 < 55296) then
        let $c1 := $c0 idiv 8
        let $c2 := $c1 idiv 32
        return (:$p:MAP1[1 + $c0 mod 8 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]:)
           fn:subsequence($p:MAP1,   
              1 + $c0 mod 8 + fn:subsequence($p:MAP1,1 + $c2 mod 32,1) + fn:subsequence($p:MAP1,1 + $c2,1)
           ,1)
      else
        p:map2($c0, 1, 2)
    let $current := $current + 1
    let $i0 := 2048 * $c1 + $current-state - 1
    let $i1 := $i0 idiv 16
(:    let $next-state := $p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]:)
      let $next-state := fn:subsequence($p:TRANSITION,$i0 mod 16 + fn:subsequence($p:TRANSITION,$i1 + 1,1) + 1,1)
    return
      if ($next-state > 2047) then
        p:transition($input, $begin, $current, $current, $next-state, $next-state mod 2048, $current-state)
      else
        p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
};

(:~
 : Recursively translate one 32-bit chunk of an expected token bitset
 : to the corresponding sequence of token strings.
 :
 : @param $result the result of previous recursion levels.
 : @param $chunk the 32-bit chunk of the expected token bitset.
 : @param $base-token-code the token code of bit 0 in the current chunk.
 : @return the set of token strings.
 :)
declare function p:token($result as xs:string*,
                         $chunk as xs:integer,
                         $base-token-code as xs:integer) as xs:string*
{
  if ($chunk = 0) then
    $result
  else
    p:token
    (
      ($result, if ($chunk mod 2 != 0) then (:$p:TOKEN[$base-token-code]:) fn:subsequence($p:TOKEN,$base-token-code,1) else ()),
      if ($chunk < 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
      $base-token-code + 1
    )
};

(:~
 : Calculate expected token set for a given DFA state as a sequence
 : of strings.
 :
 : @param $state the DFA state.
 : @return the set of token strings
 :)
declare function p:expected-token-set($state as xs:integer) as xs:string*
{
  if ($state > 0) then
    for $t in 0 to 5
    let $i0 := $t * 1626 + $state - 1
    let $i1 := $i0 idiv 2
    let $i2 := $i1 idiv 4
    let $i3 := $i2 idiv 32
    return p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 mod 32 + $p:EXPECTED[$i3 + 1] + 1] + 1] + 1], $t * 32 + 1)
  else
    ()
};

(:~
 : Classify codepoint by doing a tail recursive binary search for a
 : matching codepoint range entry in MAP2, the codepoint to charclass
 : map for codepoints above the surrogate block.
 :
 : @param $c the codepoint.
 : @param $lo the binary search lower bound map index.
 : @param $hi the binary search upper bound map index.
 : @return the character class.
 :)
declare function p:map2($c as xs:integer, $lo as xs:integer, $hi as xs:integer) as xs:integer
{
  if ($lo > $hi) then
    0
  else
    let $m := ($hi + $lo) idiv 2
    return
      if ($p:MAP2[$m] > $c) then
        p:map2($c, $lo, $m - 1)
      else if ($p:MAP2[2 + $m] < $c) then
        p:map2($c, $m + 1, $hi)
      else
        $p:MAP2[4 + $m]
};

(:~
 : The index of the parser state for accessing the combined
 : (i.e. level > 1) lookahead code.
 :)
declare variable $p:lk := 1;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the token that has been shifted.
 :)
declare variable $p:b0 := 2;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the token that has been shifted.
 :)
declare variable $p:e0 := 3;

(:~
 : The index of the parser state for accessing the code of the
 : level-1-lookahead token.
 :)
declare variable $p:l1 := 4;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-1-lookahead token.
 :)
declare variable $p:b1 := 5;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-1-lookahead token.
 :)
declare variable $p:e1 := 6;

(:~
 : The index of the parser state for accessing the code of the
 : level-2-lookahead token.
 :)
declare variable $p:l2 := 7;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-2-lookahead token.
 :)
declare variable $p:b2 := 8;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-2-lookahead token.
 :)
declare variable $p:e2 := 9;

(:~
 : The index of the parser state for accessing the code of the
 : level-3-lookahead token.
 :)
declare variable $p:l3 := 10;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the begin of the level-3-lookahead token.
 :)
declare variable $p:b3 := 11;

(:~
 : The index of the parser state for accessing the position in the
 : input string of the end of the level-3-lookahead token.
 :)
declare variable $p:e3 := 12;

(:~
 : The index of the parser state for accessing the token code that
 : was expected when an error was found.
 :)
declare variable $p:error := 13;

(:~
 : The index of the parser state that points to the first entry
 : used for collecting action results.
 :)
declare variable $p:result := 14;

(:~
 : Create a textual error message from a parsing error.
 :
 : @param $input the input string.
 : @param $error the parsing error descriptor.
 : @return the error message.
 :)
declare function p:error-message($input as xs:string, $error as element(error)) as xs:string
{
  let $begin := xs:integer($error/@b)
  let $context := string-to-codepoints(substring($input, 1, $begin - 1))
  let $linefeeds := index-of($context, 10)
  let $line := count($linefeeds) + 1
  let $column := ($begin - $linefeeds[last()], $begin)[1]
  return
    if ($error/@o) then
      concat
      (
        "syntax error, found ", $p:TOKEN[$error/@o + 1], "&#10;",
        "while expecting ", $p:TOKEN[$error/@x + 1], "&#10;",
        "after scanning ", string($error/@e - $begin), " characters at line ",
        string($line), ", column ", string($column), "&#10;",
        "...", substring($input, $begin, 32), "..."
      )
    else
      let $expected := p:expected-token-set($error/@s)
      return
        concat
        (
          "lexical analysis failed&#10;",
          "while expecting ",
          "["[exists($expected[2])],
          string-join($expected, ", "),
          "]"[exists($expected[2])],
          "&#10;",
          "after scanning ", string($error/@e - $begin), " characters at line ",
          string($line), ", column ", string($column), "&#10;",
          "...", substring($input, $begin, 32), "..."
        )
};

(:~
 : Shift one token, i.e. compare lookahead token 1 with expected
 : token and in case of a match, shift lookahead tokens down such that
 : l1 becomes the current token, and higher lookahead tokens move down.
 : When lookahead token 1 does not match the expected token, raise an
 : error by saving the expected token code in the error field of the
 : parser state.
 :
 : @param $code the expected token.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:shift($code as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else if ($state[$p:l1] = $code) then
  (
    (:$state[position() >= $p:l1 and position() <= $p:e3],:)
    fn:subsequence($state,$p:l1,$p:e3 - $p:l1 + 1),
    0,
    $state[$p:e3],
    $state[position() >= $p:e3],
    if ($state[$p:e0] != $state[$p:b1]) then
      text {
      (:substring($input, $state[$p:e0], $state[$p:b1] - $state[$p:e0]):)
        substring($input,subsequence($state,$p:e0,1), subsequence($state,$p:b1,1) - subsequence($state,$p:e0,1))
      }
    else
      (),
    (:let $name := $p:TOKEN[1 + $state[$p:l1]]:)
    let $name:= subsequence($p:TOKEN,1 + subsequence($state,$p:l1,1),1)
(:    let $content := substring($input, $state[$p:b1], $state[$p:e1] - $state[$p:b1]):)
    let $content := substring($input, fn:subsequence($state,$p:b1,1), fn:subsequence($state, $p:e1,1) - subsequence($state,$p:b1,1))
    return
      if (starts-with($name, "'")) then
		    element TOKEN {$content}
	    else
	      element {$name} {$content}
  )
  else
  (
    (:$state[position() < $p:error],:)
    subsequence($state,1,$p:error),
    element error
    {
      attribute b {
      (:$state[$p:b1]:)
       subsequence($state,$p:b1,1)
      },
      attribute e {
      (:$state[$p:e1]:)
      subsequence($state,$p:e1,1)
      },
      if ($state[$p:l1] < 0) then
        attribute s {- $state[$p:l1]}
      else
        (attribute o {$state[$p:l1]}, attribute x {$code})
    },
    subsequence($state,$p:error + 1)
    (:$state[position() > $p:error]:)
  )
};

(:~
 : Use p:match to fetch the next token, but skip any leading
 : whitespace.
 :
 : @param $input the input string.
 : @param $begin the index where to start.
 : @param $token-set the valid token set id.
 : @return a sequence of three values: the token code of the result
 : token, with input string positions of token begin and end.
 :)
declare function p:matchW($input as xs:string,
                          $begin as xs:integer,
                          $token-set as xs:integer) as xs:integer+
{
  let $match := p:match($input, $begin, $token-set)
  return
    if ($match[1] = 14) then                                (: S^WS :)
      p:matchW($input, $match[3], $token-set)
    else if ($match[1] = 32) then                           (: '(.' :)
      let $state := p:parse-Whitespace($input, (0, 0, 0, $match, 0, $match[3], 0, 0, 0, 0, false()))
      return p:matchW($input, $state[$p:e0], $token-set)
    else
      $match
};

(:~
 : Lookahead one token on level 1 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  (:if ($state[$p:l1] != 0) then:)
  if(fn:subsequence($state,$p:l1,1) != 0) then 
    $state
  else
    let $match := p:matchW($input, fn:subsequence($state,$p:b1,1), $set)
    return
    (
      $match[1],
      (:$state[position() > $p:lk and position() < $p:l1],:)
      fn:subsequence($state,$p:lk + 1,$p:l1 - $p:lk - 1) ,
      $match,
      0, $match[3], 0,
      (:$state[position() > $p:e2]:)
      fn:subsequence($state,$p:e2 + 1)
    )
};

(:~
 : Lookahead one token on level 2 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead2W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    (:if ($state[$p:l2] != 0) then:)
      if(subsequence($state,$p:l2,1) != 0) then 
        fn:subsequence($state,$p:l2, $p:e2 - $p:l2 + 1)
      (:$state[position() >= $p:l2 and position() <= $p:e2]:)
    else
      p:matchW($input, $state[$p:b2], $set)
  return
  (
    $match[1] * 256 + $state[$p:l1],
    (:$state[position() > $p:lk and position() < $p:l2],:)
    fn:subsequence($state,$p:lk + 1, $p:l2 - $p:lk -1),
    $match,
    0, $match[3], 0,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 3 with whitespace skipping.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead3W($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  let $match :=
    if ($state[$p:l3] != 0) then
      $state[position() >= $p:l3 and position() <= $p:e3]
    else
      p:matchW($input, $state[$p:b3], $set)
  return
  (
    $match[1] * 65536 + $state[$p:lk],
    $state[position() > $p:lk and position() < $p:l3],
    $match,
    $state[position() > $p:e3]
  )
};

(:~
 : Lookahead one token on level 1.
 :
 : @param $set the code of the DFA entry state for the set of valid tokens.
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:lookahead1($set as xs:integer, $input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:l1] != 0) then
    $state
  else
    let $match := p:match($input, $state[$p:b1], $set)
    return
    (
      $match[1],
      (:$state[position() > $p:lk and position() < $p:l1],:)
      fn:subsequence($state,$p:lk + 1, $p:l1 - $p:lk - 1),
      $match,
      0, $match[3], 0,
      $state[position() > $p:e2]
    )
};

declare variable $transitions := 
let $pm := map:map()
return 
(
   map:put($pm,"OrExpr",("or")),
   map:put($pm,"AndExpr",("and")),
   map:put($pm,"ComparisonExpr",("and","or","castable")),
   map:put($pm,"RangeExpr",("to")),
   map:put($pm,"AdditiveExpr",("+","-")),
   map:put($pm,"MultiplicativeExpr",("div","*","idiv","mod")),
   map:put($pm,"UnionExpr",("union")),
   map:put($pm,"IntersectExceptExpr",("intersect","except")),
   map:put($pm,"InstanceOfExp",("instance")),
   map:put($pm,"TreatExpr",("treat")),
   map:put($pm,"CastableExpr",("castable")),
   map:put($pm,"CastExpr",("cast")),
   map:put($pm,"UnaryExpr",("-","+")),
   map:put($pm,"ValueExpr",("/","//")),
   map:put($pm,"ValidateExpr",("validate")),
   map:put($pm,"RelativePathExpr",("/","//")),
   map:put($pm,"PathExpr",("parent","child","descendant","ancestor","ancestor-or-self","descendant-or-self","following-sibling","preceding-sibling","following","preceding")),
   map:put($pm,"StepExpr",()),
   map:put($pm,"FilterExpr",()),
   $pm
);

(:~
 : Reduce the result stack. Pop $count element, wrap them in a
 : new element named $name, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:reducex($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  fn:subsequence($state,1,$count),
  element {$name}
  {
      fn:subsequence($state,$count + 1)
  }
};
declare function p:reduce($state as item()+,$name as xs:string,$count as xs:integer) as item()+
{
   let $_ :=
     if(exists(map:get($transitions,$name) )) 
     then xdmp:log((
       "S=====",
       fn:concat("count(state)",fn:count($state)),
       fn:concat("$count:",$count),
       fn:concat("name:",$name),
       $state[$count - 1][1]
       ,"E====="
     ), "debug") 
     else ()
   return
  (: if(
     exists(map:get($transitions,$name)) and
     $state[$count] = map:get($transitions,$name)  
   ) then    (    
        fn:subsequence($state,1,$count),
        element {$name}
        {
            fn:subsequence($state,$count + 1)
        }   
     )
   else :)
        fn:subsequence($state,1,$count),
        element {$name}
        {
            fn:subsequence($state,$count + 1)
        }   
 
};
(:~
 : Reduce the result stack. Pop $count element, and pass-through element
 : used to handle left factoring for unecessary nesting of expressions, and push the new element.
 :
 : @param $state the parser state.
 : @param $name the name of the result node.
 : @param $count the number of child nodes.
 : @return the updated parser state.
 :)
declare function p:passthrough($state as item()+, $name as xs:string, $count as xs:integer) as item()+
{
  $state[position() <= $count],
  $state[position() > $count]
  
};
(:~
 : Parse the 1st loop of production Comment (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(66, $input, $state)          (: CommentContents | '(.' | '.)' :)
    return
      if ($state[$p:l1] = 46) then                          (: '.)' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 19) then                      (: CommentContents :)
            let $state := p:shift(19, $input, $state)       (: CommentContents :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Comment-1($input, $state)
};

(:~
 : Parse Comment.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Comment($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(32, $input, $state)                 (: '(.' :)
  let $state := p:parse-Comment-1($input, $state)
  let $state := p:shift(46, $input, $state)                 (: '.)' :)
  return p:reduce($state, "Comment", $count)
};

(:~
 : Parse the 1st loop of production Whitespace (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(23, $input, $state)          (: END | S^WS | '(.' :)
    return
      if ($state[$p:l1] = 1) then                           (: END :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 14) then                      (: S^WS :)
            let $state := p:shift(14, $input, $state)       (: S^WS :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Comment($input, $state)
            return $state
        return p:parse-Whitespace-1($input, $state)
};

(:~
 : Parse Whitespace.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Whitespace($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Whitespace-1($input, $state)
  return p:reduce($state, "Whitespace", $count)
};

(:~
 : Parse QueryBody.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QueryBody($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "QueryBody", $count)
};

(:~
 : Parse MainModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-QueryBody($input, $state)
  return p:reduce($state, "MainModule", $count)
};

(:~
 : Parse the 1st loop of production MainModuleSequence (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(69, $input, $state)         (: S^WS | EOF | '(.' | ';' :)
    let $state :=
      if ($state[$p:l1] = 49) then                          (: ';' :)
        let $state := p:lookahead2W(179, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '$' | '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | ';' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] = 24                                (: EOF :)
       or $state[$p:lk] = 6193                              (: ';' EOF :)
       or $state[$p:lk] = 12593) then                       (: ';' ';' :)
        $state
      else
        let $state := p:shift(49, $input, $state)           (: ';' :)
        let $state := p:lookahead1W(174, $input, $state)    (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:l1] = 167) then                     (: 'xquery' :)
            let $state := p:lookahead2W(137, $input, $state) (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                                '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                                '>=' | '>>' | '[' | 'and' | 'cast' | 'castable' |
                                                                'div' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                                'ne' | 'or' | 'to' | 'treat' | 'union' | 'version' | '|' :)
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:lk] = 42407) then              (: 'xquery' 'version' :)
            let $state := p:parse-VersionDecl($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-MainModule($input, $state)
        return p:parse-MainModuleSequence-1($input, $state)
};

(:~
 : Parse MainModuleSequence.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MainModuleSequence($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MainModule($input, $state)
  let $state := p:parse-MainModuleSequence-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 49) then                       (: ';' :)
      let $state := p:shift(49, $input, $state)             (: ';' :)
      return $state
    else
      $state
  return p:reduce($state, "MainModuleSequence", $count)
};

(:~
 : Parse OptionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OptionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(55, $input, $state)           (: S^WS | '(.' | 'option' :)
  let $state := p:shift(132, $input, $state)                (: 'option' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "OptionDecl", $count)
};

(:~
 : Parse Param.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Param($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(5, $input, $state)             (: '$' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(105, $input, $state)          (: S^WS | '(.' | ')' | ',' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "Param", $count)
};

(:~
 : Parse the 1st loop of production ParamList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-Param($input, $state)
        return p:parse-ParamList-1($input, $state)
};

(:~
 : Parse ParamList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParamList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Param($input, $state)
  let $state := p:parse-ParamList-1($input, $state)
  return p:reduce($state, "ParamList", $count)
};

(:~
 : Parse FunctionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(93, $input, $state)           (: S^WS | '(.' | 'function' | 'private' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 141) then                      (: 'private' :)
      let $state := p:shift(141, $input, $state)            (: 'private' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(50, $input, $state)           (: S^WS | '(.' | 'function' :)
  let $state := p:shift(106, $input, $state)                (: 'function' :)
  let $state := p:lookahead1W(161, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'property' |
                                                               'return' | 'satisfies' | 'self' | 'some' | 'stable' |
                                                               'to' | 'treat' | 'try' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(70, $input, $state)           (: S^WS | '$' | '(.' | ')' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:parse-ParamList($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(110, $input, $state)          (: S^WS | '(.' | 'as' | 'external' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(91, $input, $state)           (: S^WS | '(.' | 'external' | '{' :)
  let $state :=
    if ($state[$p:l1] = 168) then                           (: '{' :)
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(101, $input, $state)            (: 'external' :)
      return $state
  return p:reduce($state, "FunctionDecl", $count)
};

(:~
 : Parse TryCatchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TryCatchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(159, $input, $state)                (: 'try' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-EnclosedExpr($input, $state)
  let $state := p:lookahead1W(42, $input, $state)           (: S^WS | '(.' | 'catch' :)
  let $state := p:shift(79, $input, $state)                 (: 'catch' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "TryCatchExpr", $count)
};

(:~
 : Parse NodeComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 117) then                           (: 'is' :)
      let $state := p:shift(117, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 53) then                       (: '<<' :)
      let $state := p:shift(53, $input, $state)             (: '<<' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(59, $input, $state)             (: '>>' :)
      return $state
  return p:reduce($state, "NodeComp", $count)
};

(:~
 : Parse GeneralComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-GeneralComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 56) then                            (: '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:l1] = 25) then                       (: '!=' :)
      let $state := p:shift(25, $input, $state)             (: '!=' :)
      return $state
    else if ($state[$p:l1] = 50) then                       (: '<' :)
      let $state := p:shift(50, $input, $state)             (: '<' :)
      return $state
    else if ($state[$p:l1] = 54) then                       (: '<=' :)
      let $state := p:shift(54, $input, $state)             (: '<=' :)
      return $state
    else if ($state[$p:l1] = 57) then                       (: '>' :)
      let $state := p:shift(57, $input, $state)             (: '>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(58, $input, $state)             (: '>=' :)
      return $state
  return p:reduce($state, "GeneralComp", $count)
};

(:~
 : Parse ValueComp.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueComp($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 98) then                            (: 'eq' :)
      let $state := p:shift(98, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'ne' :)
      let $state := p:shift(127, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'lt' :)
      let $state := p:shift(123, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'le' :)
      let $state := p:shift(120, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'gt' :)
      let $state := p:shift(109, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(107, $input, $state)            (: 'ge' :)
      return $state
  return p:reduce($state, "ValueComp", $count)
};

(:~
 : Parse SingleType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SingleType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(163, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-AtomicType($input, $state)
  let $state := p:lookahead1W(149, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '*' | '+' | ',' |
                                                               '-' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' |
                                                               '?' | ']' | 'and' | 'ascending' | 'case' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 35                             (: '*' :)
          or $state[$p:l1] = 60) then                       (: '?' :)
      let $state :=
        if ($state[$p:l1] = 60) then                        (: '?' :)
          let $state := p:shift(60, $input, $state)         (: '?' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(35, $input, $state)         (: '*' :)
          return $state
      return $state
    else
      $state
  return p:reduce($state, "SingleType", $count)
};

(:~
 : Parse Pragma.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Pragma($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(6, $input, $state)             (: '(#' :)
  let $state := p:shift(31, $input, $state)                 (: '(#' :)
  let $state := p:lookahead1(164, $input, $state)           (: S | QName^Token | 'ancestor' | 'ancestor-or-self' |
                                                               'and' | 'ascending' | 'attribute' | 'binary' | 'case' |
                                                               'cast' | 'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      return $state
    else
      $state
  let $state := p:lookahead1(163, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1(14, $input, $state)            (: S | '#)' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      let $state := p:lookahead1(2, $input, $state)         (: PragmaContents :)
      let $state := p:shift(20, $input, $state)             (: PragmaContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(4, $input, $state)             (: '#)' :)
  let $state := p:shift(27, $input, $state)                 (: '#)' :)
  return p:reduce($state, "Pragma", $count)
};

(:~
 : Parse the 1st loop of production ExtensionExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:parse-Pragma($input, $state)
    let $state := p:lookahead1W(74, $input, $state)         (: S^WS | '(#' | '(.' | '{' :)
    return
      if ($state[$p:l1] != 31) then                         (: '(#' :)
        $state
      else
        p:parse-ExtensionExpr-1($input, $state)
};

(:~
 : Parse ExtensionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExtensionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExtensionExpr-1($input, $state)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "ExtensionExpr", $count)
};

(:~
 : Parse AbbrevForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 62) then                       (: '@' :)
      let $state := p:shift(62, $input, $state)             (: '@' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-NodeTest($input, $state)
  return p:reduce($state, "AbbrevForwardStep", $count)
};

(:~
 : Parse ForwardAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 80) then                            (: 'child' :)
      let $state := p:shift(80, $input, $state)             (: 'child' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'descendant' :)
      let $state := p:shift(87, $input, $state)             (: 'descendant' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:shift(71, $input, $state)             (: 'attribute' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'namespace' :)
      let $state := p:shift(126, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'self' :)
      let $state := p:shift(149, $input, $state)            (: 'self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'property' :)
      let $state := p:shift(143, $input, $state)            (: 'property' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'descendant-or-self' :)
      let $state := p:shift(88, $input, $state)             (: 'descendant-or-self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'following-sibling' :)
      let $state := p:shift(103, $input, $state)            (: 'following-sibling' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(102, $input, $state)            (: 'following' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ForwardAxis", $count)
};

(:~
 : Parse ForwardStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForwardStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 80                             (: 'descendant' :)
          or $state[$p:l1] = 87                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 88                             (: 'following' :)
          or $state[$p:l1] = 102                            (: 'following-sibling' :)
          or $state[$p:l1] = 103                            (: 'namespace' :)
          or $state[$p:l1] = 126                            (: 'property' :)
          or $state[$p:l1] = 143                            (: 'self' :)
          or $state[$p:l1] = 149) then                      (: 'self' :)
      let $state := p:lookahead2W(153, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 12103                               (: 'attribute' '::' :)
     or $state[$p:lk] = 12112                               (: 'child' '::' :)
     or $state[$p:lk] = 12119                               (: 'descendant' '::' :)
     or $state[$p:lk] = 12120                               (: 'descendant-or-self' '::' :)
     or $state[$p:lk] = 12134                               (: 'following' '::' :)
     or $state[$p:lk] = 12135                               (: 'following-sibling' '::' :)
     or $state[$p:lk] = 12158                               (: 'namespace' '::' :)
     or $state[$p:lk] = 12175                               (: 'property' '::' :)
     or $state[$p:lk] = 12181) then                         (: 'self' '::' :)
      let $state := p:parse-ForwardAxis($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AbbrevForwardStep($input, $state)
      return $state
  return p:reduce($state, "ForwardStep", $count)
};

(:~
 : Parse AbbrevReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AbbrevReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(42, $input, $state)                 (: '..' :)
  return p:reduce($state, "AbbrevReverseStep", $count)
};

(:~
 : Parse NameTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NameTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 23) then                            (: Wildcard :)
      let $state := p:shift(23, $input, $state)             (: Wildcard :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  return p:reduce($state, "NameTest", $count)
};

(:~
 : Parse NodeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NodeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(165, $input, $state)           (: QName^Token | Wildcard | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71                                  (: 'binary' :)
     or $state[$p:l1] = 73                                  (: 'comment' :)
     or $state[$p:l1] = 82                                  (: 'document-node' :)
     or $state[$p:l1] = 92                                  (: 'element' :)
     or $state[$p:l1] = 93                                  (: 'node' :)
     or $state[$p:l1] = 130                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 142                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 147                                 (: 'schema-element' :)
     or $state[$p:l1] = 148                                 (: 'text' :)
     or $state[$p:l1] = 155) then                           (: 'text' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7751                                (: 'attribute' '(' :)
     or $state[$p:lk] = 7753                                (: 'binary' '(' :)
     or $state[$p:lk] = 7762                                (: 'comment' '(' :)
     or $state[$p:lk] = 7772                                (: 'document-node' '(' :)
     or $state[$p:lk] = 7773                                (: 'element' '(' :)
     or $state[$p:lk] = 7810                                (: 'node' '(' :)
     or $state[$p:lk] = 7822                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 7827                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 7828                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 7835) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NameTest($input, $state)
      return $state
  return p:reduce($state, "NodeTest", $count)
};

(:~
 : Parse ReverseAxis.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseAxis($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 137) then                           (: 'parent' :)
      let $state := p:shift(137, $input, $state)            (: 'parent' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 65) then                       (: 'ancestor' :)
      let $state := p:shift(65, $input, $state)             (: 'ancestor' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'preceding-sibling' :)
      let $state := p:shift(139, $input, $state)            (: 'preceding-sibling' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'preceding' :)
      let $state := p:shift(138, $input, $state)            (: 'preceding' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(66, $input, $state)             (: 'ancestor-or-self' :)
      let $state := p:lookahead1W(32, $input, $state)       (: S^WS | '(.' | '::' :)
      let $state := p:shift(47, $input, $state)             (: '::' :)
      return $state
  return p:reduce($state, "ReverseAxis", $count)
};

(:~
 : Parse ReverseStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ReverseStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 42) then                            (: '..' :)
      let $state := p:parse-AbbrevReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ReverseAxis($input, $state)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-NodeTest($input, $state)
      return $state
  return p:reduce($state, "ReverseStep", $count)
};

(:~
 : Parse AxisStep.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AxisStep($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 65                                  (: 'ancestor-or-self' :)
     or $state[$p:l1] = 66                                  (: 'parent' :)
     or $state[$p:l1] = 137                                 (: 'preceding' :)
     or $state[$p:l1] = 138                                 (: 'preceding-sibling' :)
     or $state[$p:l1] = 139) then                           (: 'preceding-sibling' :)
      let $state := p:lookahead2W(153, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 42                                  (: '..' :)
     or $state[$p:lk] = 12097                               (: 'ancestor' '::' :)
     or $state[$p:lk] = 12098                               (: 'ancestor-or-self' '::' :)
     or $state[$p:lk] = 12169                               (: 'parent' '::' :)
     or $state[$p:lk] = 12170                               (: 'preceding' '::' :)
     or $state[$p:lk] = 12171) then                         (: 'preceding-sibling' '::' :)
      let $state := p:parse-ReverseStep($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ForwardStep($input, $state)
      return $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "AxisStep", $count)
};

(:~
 : Parse Predicate.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Predicate($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(63, $input, $state)                 (: '[' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(36, $input, $state)           (: S^WS | '(.' | ']' :)
  let $state := p:shift(64, $input, $state)                 (: ']' :)
  return p:reduce($state, "Predicate", $count)
};

(:~
 : Parse the 1st loop of production PredicateList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(151, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 63) then                         (: '[' :)
        $state
      else
        let $state := p:parse-Predicate($input, $state)
        return p:parse-PredicateList-1($input, $state)
};

(:~
 : Parse PredicateList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PredicateList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PredicateList-1($input, $state)
  return p:reduce($state, "PredicateList", $count)
};

(:~
 : Parse CompNamespaceConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompNamespaceConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(126, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 168) then                           (: '{' :)
      let $state := p:shift(168, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(171, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompNamespaceConstructor", $count)
};

(:~
 : Parse CompBinaryConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompBinaryConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(73, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompBinaryConstructor", $count)
};

(:~
 : Parse CompPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(142, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(132, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' :)
  let $state :=
    if ($state[$p:l1] = 168) then                           (: '{' :)
      let $state := p:shift(168, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(171, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NCName($input, $state)
      return $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "CompPIConstructor", $count)
};

(:~
 : Parse CompCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(82, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "CompCommentConstructor", $count)
};

(:~
 : Parse EnclosedExprExtended.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExprExtended($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExprExtended", $count)
};

(:~
 : Parse CompTextConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompTextConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(155, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-EnclosedExprExtended($input, $state)
  return p:reduce($state, "CompTextConstructor", $count)
};

(:~
 : Parse CompAttrConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompAttrConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 168) then                           (: '{' :)
      let $state := p:shift(168, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(171, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '}' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "CompAttrConstructor", $count)
};

(:~
 : Parse ContentExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContentExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Expr($input, $state)
  return p:reduce($state, "ContentExpr", $count)
};

(:~
 : Parse CompElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(93, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(170, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
  let $state :=
    if ($state[$p:l1] = 168) then                           (: '{' :)
      let $state := p:shift(168, $input, $state)            (: '{' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-Expr($input, $state)
      let $state := p:lookahead1W(65, $input, $state)       (: S^WS | '(.' | '}' :)
      let $state := p:shift(171, $input, $state)            (: '}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-QName($input, $state)
      return $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(178, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 171) then                     (: '}' :)
      let $state := p:parse-ContentExpr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "CompElemConstructor", $count)
};

(:~
 : Parse CompDocConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CompDocConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(91, $input, $state)                 (: 'document' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "CompDocConstructor", $count)
};

(:~
 : Parse ComputedConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComputedConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 91) then                            (: 'document' :)
      let $state := p:parse-CompDocConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'element' :)
      let $state := p:parse-CompElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:parse-CompAttrConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'text' :)
      let $state := p:parse-CompTextConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:parse-CompCommentConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'processing-instruction' :)
      let $state := p:parse-CompPIConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'binary' :)
      let $state := p:parse-CompBinaryConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CompNamespaceConstructor($input, $state)
      return $state
  return p:reduce($state, "ComputedConstructor", $count)
};

(:~
 : Parse DirPIConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirPIConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(55, $input, $state)                 (: '<?' :)
  let $state := p:lookahead1(1, $input, $state)             (: PITarget :)
  let $state := p:shift(18, $input, $state)                 (: PITarget :)
  let $state := p:lookahead1(17, $input, $state)            (: S | '?>' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 13) then                       (: S :)
      let $state := p:shift(13, $input, $state)             (: S :)
      let $state := p:lookahead1(3, $input, $state)         (: DirPIContents :)
      let $state := p:shift(21, $input, $state)             (: DirPIContents :)
      return $state
    else
      $state
  let $state := p:lookahead1(10, $input, $state)            (: '?>' :)
  let $state := p:shift(61, $input, $state)                 (: '?>' :)
  return p:reduce($state, "DirPIConstructor", $count)
};

(:~
 : Parse DirCommentConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirCommentConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(51, $input, $state)                 (: '<!--' :)
  let $state := p:lookahead1(0, $input, $state)             (: DirCommentContents :)
  let $state := p:shift(2, $input, $state)                  (: DirCommentContents :)
  let $state := p:lookahead1(7, $input, $state)             (: '-->' :)
  let $state := p:shift(40, $input, $state)                 (: '-->' :)
  return p:reduce($state, "DirCommentConstructor", $count)
};

(:~
 : Parse DirElemContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50                                  (: '<' :)
     or $state[$p:l1] = 51                                  (: '<!--' :)
     or $state[$p:l1] = 55) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 22) then                       (: CDataSection :)
      let $state := p:shift(22, $input, $state)             (: CDataSection :)
      return $state
    else if ($state[$p:l1] = 10) then                       (: ElementContentChar :)
      let $state := p:shift(10, $input, $state)             (: ElementContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "DirElemContent", $count)
};

(:~
 : Parse AposAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AposAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 12) then                            (: AposAttrContentChar :)
      let $state := p:shift(12, $input, $state)             (: AposAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "AposAttrValueContent", $count)
};

(:~
 : Parse EnclosedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EnclosedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(13, $input, $state)            (: '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "EnclosedExpr", $count)
};

(:~
 : Parse CommonContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommonContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 7) then                             (: PredefinedEntityRef :)
      let $state := p:shift(7, $input, $state)              (: PredefinedEntityRef :)
      return $state
    else if ($state[$p:l1] = 15) then                       (: CharRef :)
      let $state := p:shift(15, $input, $state)             (: CharRef :)
      return $state
    else if ($state[$p:l1] = 169) then                      (: '{{' :)
      let $state := p:shift(169, $input, $state)            (: '{{' :)
      return $state
    else if ($state[$p:l1] = 172) then                      (: '}}' :)
      let $state := p:shift(172, $input, $state)            (: '}}' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-EnclosedExpr($input, $state)
      return $state
  return p:reduce($state, "CommonContent", $count)
};

(:~
 : Parse QuotAttrValueContent.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuotAttrValueContent($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 11) then                            (: QuotAttrContentChar :)
      let $state := p:shift(11, $input, $state)             (: QuotAttrContentChar :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CommonContent($input, $state)
      return $state
  return p:reduce($state, "QuotAttrValueContent", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(119, $input, $state)         (: PredefinedEntityRef | EscapeQuot | QuotAttrContentChar |
                                                               CharRef | '"' | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 26) then                          (: '"' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 8) then                       (: EscapeQuot :)
            let $state := p:shift(8, $input, $state)        (: EscapeQuot :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-QuotAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-1($input, $state)
};

(:~
 : Parse the 2nd loop of production DirAttributeValue (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(120, $input, $state)         (: PredefinedEntityRef | EscapeApos | AposAttrContentChar |
                                                               CharRef | "'" | '{' | '{{' | '}}' :)
    return
      if ($state[$p:l1] = 29) then                          (: "'" :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 9) then                       (: EscapeApos :)
            let $state := p:shift(9, $input, $state)        (: EscapeApos :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-AposAttrValueContent($input, $state)
            return $state
        return p:parse-DirAttributeValue-2($input, $state)
};

(:~
 : Parse DirAttributeValue.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeValue($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(18, $input, $state)            (: '"' | "'" :)
  let $state :=
    if ($state[$p:l1] = 26) then                            (: '"' :)
      let $state := p:shift(26, $input, $state)             (: '"' :)
      let $state := p:parse-DirAttributeValue-1($input, $state)
      let $state := p:shift(26, $input, $state)             (: '"' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(29, $input, $state)             (: "'" :)
      let $state := p:parse-DirAttributeValue-2($input, $state)
      let $state := p:shift(29, $input, $state)             (: "'" :)
      return $state
  return p:reduce($state, "DirAttributeValue", $count)
};

(:~
 : Parse the 1st loop of production DirAttributeList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(26, $input, $state)          (: S | '/>' | '>' :)
    return
      if ($state[$p:l1] != 13) then                         (: S :)
        $state
      else
        let $state := p:shift(13, $input, $state)           (: S :)
        let $state := p:lookahead1(168, $input, $state)     (: S | QName^Token | '/>' | '>' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] != 13                      (: S :)
               and $state[$p:l1] != 45                      (: '/>' :)
               and $state[$p:l1] != 57) then                (: '>' :)
            let $state := p:parse-QName($input, $state)
            let $state := p:lookahead1(15, $input, $state)  (: S | '=' :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 13) then             (: S :)
                let $state := p:shift(13, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:lookahead1(8, $input, $state)   (: '=' :)
            let $state := p:shift(56, $input, $state)       (: '=' :)
            let $state := p:lookahead1(25, $input, $state)  (: S | '"' | "'" :)
            let $state :=
              if ($state[$p:error]) then
                $state
              else if ($state[$p:l1] = 13) then             (: S :)
                let $state := p:shift(13, $input, $state)   (: S :)
                return $state
              else
                $state
            let $state := p:parse-DirAttributeValue($input, $state)
            return $state
          else
            $state
        return p:parse-DirAttributeList-1($input, $state)
};

(:~
 : Parse DirAttributeList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirAttributeList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-DirAttributeList-1($input, $state)
  return p:reduce($state, "DirAttributeList", $count)
};

(:~
 : Parse the 1st loop of production DirElemConstructor (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1(127, $input, $state)         (: PredefinedEntityRef | ElementContentChar | CharRef |
                                                               CDataSection | '<' | '<!--' | '</' | '<?' | '{' | '{{' |
                                                               '}}' :)
    return
      if ($state[$p:l1] = 52) then                          (: '</' :)
        $state
      else
        let $state := p:parse-DirElemContent($input, $state)
        return p:parse-DirElemConstructor-1($input, $state)
};

(:~
 : Parse DirElemConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirElemConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(50, $input, $state)                 (: '<' :)
  let $state := p:lookahead1(163, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:parse-DirAttributeList($input, $state)
  let $state := p:lookahead1(19, $input, $state)            (: '/>' | '>' :)
  let $state :=
    if ($state[$p:l1] = 45) then                            (: '/>' :)
      let $state := p:shift(45, $input, $state)             (: '/>' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(57, $input, $state)             (: '>' :)
      let $state := p:parse-DirElemConstructor-1($input, $state)
      let $state := p:shift(52, $input, $state)             (: '</' :)
      let $state := p:lookahead1(163, $input, $state)       (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:parse-QName($input, $state)
      let $state := p:lookahead1(16, $input, $state)        (: S | '>' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 13) then                   (: S :)
          let $state := p:shift(13, $input, $state)         (: S :)
          return $state
        else
          $state
      let $state := p:lookahead1(9, $input, $state)         (: '>' :)
      let $state := p:shift(57, $input, $state)             (: '>' :)
      return $state
  return p:reduce($state, "DirElemConstructor", $count)
};

(:~
 : Parse DirectConstructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DirectConstructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50) then                            (: '<' :)
      let $state := p:parse-DirElemConstructor($input, $state)
      return $state
    else if ($state[$p:l1] = 51) then                       (: '<!--' :)
      let $state := p:parse-DirCommentConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-DirPIConstructor($input, $state)
      return $state
  return p:reduce($state, "DirectConstructor", $count)
};

(:~
 : Parse Constructor.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Constructor($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 50                                  (: '<' :)
     or $state[$p:l1] = 51                                  (: '<!--' :)
     or $state[$p:l1] = 55) then                            (: '<?' :)
      let $state := p:parse-DirectConstructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ComputedConstructor($input, $state)
      return $state
  return p:reduce($state, "Constructor", $count)
};

(:~
 : Parse UnorderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnorderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(162, $input, $state)                (: 'unordered' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "UnorderedExpr", $count)
};

(:~
 : Parse OrderedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(135, $input, $state)                (: 'ordered' :)
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "OrderedExpr", $count)
};

(:~
 : Parse the 1st loop of production FunctionCall (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(75, $input, $state)         (: S^WS | '(.' | ')' | ',' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-FunctionCall-1($input, $state)
};

(:~
 : Parse FunctionCall.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionCall($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FunctionName($input, $state)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | ')' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-ExprSingle($input, $state)
      let $state := p:parse-FunctionCall-1($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "FunctionCall", $count)
};

(:~
 : Parse ContextItemExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ContextItemExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(41, $input, $state)                 (: '.' :)
  return p:reduce($state, "ContextItemExpr", $count)
};

(:~
 : Parse ParenthesizedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ParenthesizedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(176, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | ')' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-Expr($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "ParenthesizedExpr", $count)
};

(:~
 : Parse VarRef.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarRef($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "VarRef", $count)
};

(:~
 : Parse NumericLiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NumericLiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 3) then                             (: IntegerLiteral :)
      let $state := p:shift(3, $input, $state)              (: IntegerLiteral :)
      return $state
    else if ($state[$p:l1] = 4) then                        (: DecimalLiteral :)
      let $state := p:shift(4, $input, $state)              (: DecimalLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(5, $input, $state)              (: DoubleLiteral :)
      return $state
  return p:reduce($state, "NumericLiteral", $count)
};

(:~
 : Parse Literal.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Literal($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 6) then                             (: StringLiteral :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-NumericLiteral($input, $state)
      return $state
  return p:reduce($state, "Literal", $count)
};

(:~
 : Parse PrimaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PrimaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(166, $input, $state)           (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | QName^Token | '$' | '(' | '.' | '<' |
                                                               '<!--' | '<?' | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'element' | 'else' | 'empty' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'namespace' | 'ne' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' | 'union' |
                                                               'unordered' | 'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 91                                  (: 'ordered' :)
     or $state[$p:l1] = 135                                 (: 'unordered' :)
     or $state[$p:l1] = 162) then                           (: 'unordered' :)
      let $state := p:lookahead2W(73, $input, $state)       (: S^WS | '(' | '(.' | '{' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6) then                             (: StringLiteral :)
      let $state := p:parse-Literal($input, $state)
      return $state
    else if ($state[$p:lk] = 28) then                       (: '$' :)
      let $state := p:parse-VarRef($input, $state)
      return $state
    else if ($state[$p:lk] = 30) then                       (: '(' :)
      let $state := p:parse-ParenthesizedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 41) then                       (: '.' :)
      let $state := p:parse-ContextItemExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43143) then                    (: 'ordered' '{' :)
      let $state := p:parse-OrderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43170) then                    (: 'unordered' '{' :)
      let $state := p:parse-UnorderedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 50                             (: '<' :)
          or $state[$p:lk] = 51                             (: '<!--' :)
          or $state[$p:lk] = 55                             (: '<?' :)
          or $state[$p:lk] = 71                             (: 'attribute' :)
          or $state[$p:lk] = 73                             (: 'binary' :)
          or $state[$p:lk] = 82                             (: 'comment' :)
          or $state[$p:lk] = 93                             (: 'element' :)
          or $state[$p:lk] = 126                            (: 'namespace' :)
          or $state[$p:lk] = 142                            (: 'processing-instruction' :)
          or $state[$p:lk] = 155                            (: 'text' :)
          or $state[$p:lk] = 43099) then                    (: 'document' '{' :)
      let $state := p:parse-Constructor($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionCall($input, $state)
      return $state
  return p:reduce($state, "PrimaryExpr", $count)
};

(:~
 : Parse FilterExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FilterExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-PrimaryExpr($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-PredicateList($input, $state)
  return p:reduce($state, "FilterExpr", $count)
};

(:~
 : Parse StepExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-StepExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(173, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(.' | '.' | '..' | '<' | '<!--' | '<?' | '@' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:lookahead2W(182, $input, $state)      (: S^WS | QName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' |
                                                               '<<' | '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' |
                                                               'ancestor' | 'ancestor-or-self' | 'and' | 'ascending' |
                                                               'attribute' | 'binary' | 'case' | 'cast' | 'castable' |
                                                               'catch' | 'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19527) then                     (: 'attribute' 'case' :)
          let $state := p:lookahead3W(171, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 20807) then                (: 'attribute' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22087) then                (: 'attribute' 'default' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 24391) then                (: 'attribute' 'empty' :)
          let $state := p:lookahead3W(111, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 29511) then                (: 'attribute' 'instance' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 34375) then                (: 'attribute' 'order' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 38727) then                (: 'attribute' 'stable' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17735                      (: 'attribute' 'descending' :)
              or $state[$p:lk] = 22855) then                (: 'attribute' 'descending' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26695                      (: 'attribute' 'let' :)
              or $state[$p:lk] = 31303) then                (: 'attribute' 'let' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19783                      (: 'attribute' 'castable' :)
              or $state[$p:lk] = 20039                      (: 'attribute' 'treat' :)
              or $state[$p:lk] = 40519) then                (: 'attribute' 'treat' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17223                      (: 'attribute' 'div' :)
              or $state[$p:lk] = 23111                      (: 'attribute' 'else' :)
              or $state[$p:lk] = 24135                      (: 'attribute' 'eq' :)
              or $state[$p:lk] = 25159                      (: 'attribute' 'except' :)
              or $state[$p:lk] = 25671                      (: 'attribute' 'ge' :)
              or $state[$p:lk] = 27463                      (: 'attribute' 'gt' :)
              or $state[$p:lk] = 27975                      (: 'attribute' 'idiv' :)
              or $state[$p:lk] = 28231                      (: 'attribute' 'intersect' :)
              or $state[$p:lk] = 29767                      (: 'attribute' 'is' :)
              or $state[$p:lk] = 30023                      (: 'attribute' 'le' :)
              or $state[$p:lk] = 30791                      (: 'attribute' 'lt' :)
              or $state[$p:lk] = 31559                      (: 'attribute' 'mod' :)
              or $state[$p:lk] = 31815                      (: 'attribute' 'ne' :)
              or $state[$p:lk] = 32583                      (: 'attribute' 'or' :)
              or $state[$p:lk] = 34119                      (: 'attribute' 'return' :)
              or $state[$p:lk] = 36935                      (: 'attribute' 'satisfies' :)
              or $state[$p:lk] = 37191                      (: 'attribute' 'to' :)
              or $state[$p:lk] = 40263                      (: 'attribute' 'union' :)
              or $state[$p:lk] = 41287                      (: 'attribute' 'where' :)
              or $state[$p:lk] = 42567) then                (: 'attribute' 'where' :)
          let $state := p:lookahead3W(177, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'element' :)
      let $state := p:lookahead2W(180, $input, $state)      (: S^WS | QName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19549) then                     (: 'element' 'case' :)
          let $state := p:lookahead3W(171, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 20829) then                (: 'element' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22109) then                (: 'element' 'default' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 24413) then                (: 'element' 'empty' :)
          let $state := p:lookahead3W(111, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 29533) then                (: 'element' 'instance' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 34397) then                (: 'element' 'order' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 38749) then                (: 'element' 'stable' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17757                      (: 'element' 'descending' :)
              or $state[$p:lk] = 22877) then                (: 'element' 'descending' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26717                      (: 'element' 'let' :)
              or $state[$p:lk] = 31325) then                (: 'element' 'let' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19805                      (: 'element' 'castable' :)
              or $state[$p:lk] = 20061                      (: 'element' 'treat' :)
              or $state[$p:lk] = 40541) then                (: 'element' 'treat' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17245                      (: 'element' 'div' :)
              or $state[$p:lk] = 23133                      (: 'element' 'else' :)
              or $state[$p:lk] = 24157                      (: 'element' 'eq' :)
              or $state[$p:lk] = 25181                      (: 'element' 'except' :)
              or $state[$p:lk] = 25693                      (: 'element' 'ge' :)
              or $state[$p:lk] = 27485                      (: 'element' 'gt' :)
              or $state[$p:lk] = 27997                      (: 'element' 'idiv' :)
              or $state[$p:lk] = 28253                      (: 'element' 'intersect' :)
              or $state[$p:lk] = 29789                      (: 'element' 'is' :)
              or $state[$p:lk] = 30045                      (: 'element' 'le' :)
              or $state[$p:lk] = 30813                      (: 'element' 'lt' :)
              or $state[$p:lk] = 31581                      (: 'element' 'mod' :)
              or $state[$p:lk] = 31837                      (: 'element' 'ne' :)
              or $state[$p:lk] = 32605                      (: 'element' 'or' :)
              or $state[$p:lk] = 34141                      (: 'element' 'return' :)
              or $state[$p:lk] = 36957                      (: 'element' 'satisfies' :)
              or $state[$p:lk] = 37213                      (: 'element' 'to' :)
              or $state[$p:lk] = 40285                      (: 'element' 'union' :)
              or $state[$p:lk] = 41309                      (: 'element' 'where' :)
              or $state[$p:lk] = 42589) then                (: 'element' 'where' :)
          let $state := p:lookahead3W(177, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'namespace' :)
      let $state := p:lookahead2W(181, $input, $state)      (: S^WS | QName^Token | EOF | '!=' | '(.' | ')' | '*' |
                                                               '+' | ',' | '-' | '/' | '//' | '::' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19582) then                     (: 'namespace' 'case' :)
          let $state := p:lookahead3W(171, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 20862) then                (: 'namespace' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22142) then                (: 'namespace' 'default' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 24446) then                (: 'namespace' 'empty' :)
          let $state := p:lookahead3W(111, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 29566) then                (: 'namespace' 'instance' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 34430) then                (: 'namespace' 'order' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 38782) then                (: 'namespace' 'stable' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17790                      (: 'namespace' 'descending' :)
              or $state[$p:lk] = 22910) then                (: 'namespace' 'descending' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26750                      (: 'namespace' 'let' :)
              or $state[$p:lk] = 31358) then                (: 'namespace' 'let' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19838                      (: 'namespace' 'castable' :)
              or $state[$p:lk] = 20094                      (: 'namespace' 'treat' :)
              or $state[$p:lk] = 40574) then                (: 'namespace' 'treat' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17278                      (: 'namespace' 'div' :)
              or $state[$p:lk] = 23166                      (: 'namespace' 'else' :)
              or $state[$p:lk] = 24190                      (: 'namespace' 'eq' :)
              or $state[$p:lk] = 25214                      (: 'namespace' 'except' :)
              or $state[$p:lk] = 25726                      (: 'namespace' 'ge' :)
              or $state[$p:lk] = 27518                      (: 'namespace' 'gt' :)
              or $state[$p:lk] = 28030                      (: 'namespace' 'idiv' :)
              or $state[$p:lk] = 28286                      (: 'namespace' 'intersect' :)
              or $state[$p:lk] = 29822                      (: 'namespace' 'is' :)
              or $state[$p:lk] = 30078                      (: 'namespace' 'le' :)
              or $state[$p:lk] = 30846                      (: 'namespace' 'lt' :)
              or $state[$p:lk] = 31614                      (: 'namespace' 'mod' :)
              or $state[$p:lk] = 31870                      (: 'namespace' 'ne' :)
              or $state[$p:lk] = 32638                      (: 'namespace' 'or' :)
              or $state[$p:lk] = 34174                      (: 'namespace' 'return' :)
              or $state[$p:lk] = 36990                      (: 'namespace' 'satisfies' :)
              or $state[$p:lk] = 37246                      (: 'namespace' 'to' :)
              or $state[$p:lk] = 40318                      (: 'namespace' 'union' :)
              or $state[$p:lk] = 41342                      (: 'namespace' 'where' :)
              or $state[$p:lk] = 42622) then                (: 'namespace' 'where' :)
          let $state := p:lookahead3W(177, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'processing-instruction' :)
      let $state := p:lookahead2W(159, $input, $state)      (: S^WS | NCName^Token | EOF | '!=' | '(' | '(.' | ')' |
                                                               '*' | '+' | ',' | '-' | '/' | '//' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | '[' | ']' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:lk] = 19598) then                     (: 'processing-instruction' 'case' :)
          let $state := p:lookahead3W(171, $input, $state)  (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else if ($state[$p:lk] = 20878) then                (: 'processing-instruction' 'collation' :)
          let $state := p:lookahead3W(68, $input, $state)   (: StringLiteral | S^WS | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 22158) then                (: 'processing-instruction' 'default' :)
          let $state := p:lookahead3W(104, $input, $state)  (: S^WS | '$' | '(.' | 'return' | '{' :)
          return $state
        else if ($state[$p:lk] = 24462) then                (: 'processing-instruction' 'empty' :)
          let $state := p:lookahead3W(111, $input, $state)  (: S^WS | '(.' | 'greatest' | 'least' | '{' :)
          return $state
        else if ($state[$p:lk] = 29582) then                (: 'processing-instruction' 'instance' :)
          let $state := p:lookahead3W(98, $input, $state)   (: S^WS | '(.' | 'of' | '{' :)
          return $state
        else if ($state[$p:lk] = 34446) then                (: 'processing-instruction' 'order' :)
          let $state := p:lookahead3W(87, $input, $state)   (: S^WS | '(.' | 'by' | '{' :)
          return $state
        else if ($state[$p:lk] = 38798) then                (: 'processing-instruction' 'stable' :)
          let $state := p:lookahead3W(99, $input, $state)   (: S^WS | '(.' | 'order' | '{' :)
          return $state
        else if ($state[$p:lk] = 17806                      (: 'processing-instruction' 'descending' :)
              or $state[$p:lk] = 22926) then                (: 'processing-instruction' 'descending' :)
          let $state := p:lookahead3W(117, $input, $state)  (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' |
                                                               '{' :)
          return $state
        else if ($state[$p:lk] = 26766                      (: 'processing-instruction' 'let' :)
              or $state[$p:lk] = 31374) then                (: 'processing-instruction' 'let' :)
          let $state := p:lookahead3W(72, $input, $state)   (: S^WS | '$' | '(.' | '{' :)
          return $state
        else if ($state[$p:lk] = 19854                      (: 'processing-instruction' 'castable' :)
              or $state[$p:lk] = 20110                      (: 'processing-instruction' 'treat' :)
              or $state[$p:lk] = 40590) then                (: 'processing-instruction' 'treat' :)
          let $state := p:lookahead3W(85, $input, $state)   (: S^WS | '(.' | 'as' | '{' :)
          return $state
        else if ($state[$p:lk] = 17294                      (: 'processing-instruction' 'div' :)
              or $state[$p:lk] = 23182                      (: 'processing-instruction' 'else' :)
              or $state[$p:lk] = 24206                      (: 'processing-instruction' 'eq' :)
              or $state[$p:lk] = 25230                      (: 'processing-instruction' 'except' :)
              or $state[$p:lk] = 25742                      (: 'processing-instruction' 'ge' :)
              or $state[$p:lk] = 27534                      (: 'processing-instruction' 'gt' :)
              or $state[$p:lk] = 28046                      (: 'processing-instruction' 'idiv' :)
              or $state[$p:lk] = 28302                      (: 'processing-instruction' 'intersect' :)
              or $state[$p:lk] = 29838                      (: 'processing-instruction' 'is' :)
              or $state[$p:lk] = 30094                      (: 'processing-instruction' 'le' :)
              or $state[$p:lk] = 30862                      (: 'processing-instruction' 'lt' :)
              or $state[$p:lk] = 31630                      (: 'processing-instruction' 'mod' :)
              or $state[$p:lk] = 31886                      (: 'processing-instruction' 'ne' :)
              or $state[$p:lk] = 32654                      (: 'processing-instruction' 'or' :)
              or $state[$p:lk] = 34190                      (: 'processing-instruction' 'return' :)
              or $state[$p:lk] = 37006                      (: 'processing-instruction' 'satisfies' :)
              or $state[$p:lk] = 37262                      (: 'processing-instruction' 'to' :)
              or $state[$p:lk] = 40334                      (: 'processing-instruction' 'union' :)
              or $state[$p:lk] = 41358                      (: 'processing-instruction' 'where' :)
              or $state[$p:lk] = 42638) then                (: 'processing-instruction' 'where' :)
          let $state := p:lookahead3W(177, $input, $state)  (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '{' :)
          return $state
        else
          $state
      return $state
    else if ($state[$p:l1] = 73                             (: 'comment' :)
          or $state[$p:l1] = 82                             (: 'document' :)
          or $state[$p:l1] = 91                             (: 'ordered' :)
          or $state[$p:l1] = 135                            (: 'text' :)
          or $state[$p:l1] = 155                            (: 'unordered' :)
          or $state[$p:l1] = 162) then                      (: 'unordered' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 65                             (: 'ancestor-or-self' :)
          or $state[$p:l1] = 66                             (: 'child' :)
          or $state[$p:l1] = 80                             (: 'descendant' :)
          or $state[$p:l1] = 87                             (: 'descendant-or-self' :)
          or $state[$p:l1] = 88                             (: 'following' :)
          or $state[$p:l1] = 102                            (: 'following-sibling' :)
          or $state[$p:l1] = 103                            (: 'parent' :)
          or $state[$p:l1] = 137                            (: 'preceding' :)
          or $state[$p:l1] = 138                            (: 'preceding-sibling' :)
          or $state[$p:l1] = 139                            (: 'property' :)
          or $state[$p:l1] = 143                            (: 'self' :)
          or $state[$p:l1] = 149) then                      (: 'self' :)
      let $state := p:lookahead2W(155, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | '::' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 17                             (: 'and' :)
          or $state[$p:l1] = 67                             (: 'ascending' :)
          or $state[$p:l1] = 69                             (: 'case' :)
          or $state[$p:l1] = 76                             (: 'cast' :)
          or $state[$p:l1] = 77                             (: 'castable' :)
          or $state[$p:l1] = 78                             (: 'catch' :)
          or $state[$p:l1] = 79                             (: 'collation' :)
          or $state[$p:l1] = 81                             (: 'declare' :)
          or $state[$p:l1] = 85                             (: 'default' :)
          or $state[$p:l1] = 86                             (: 'descending' :)
          or $state[$p:l1] = 89                             (: 'div' :)
          or $state[$p:l1] = 90                             (: 'else' :)
          or $state[$p:l1] = 94                             (: 'empty' :)
          or $state[$p:l1] = 95                             (: 'eq' :)
          or $state[$p:l1] = 98                             (: 'every' :)
          or $state[$p:l1] = 99                             (: 'except' :)
          or $state[$p:l1] = 100                            (: 'for' :)
          or $state[$p:l1] = 104                            (: 'ge' :)
          or $state[$p:l1] = 107                            (: 'gt' :)
          or $state[$p:l1] = 109                            (: 'idiv' :)
          or $state[$p:l1] = 110                            (: 'import' :)
          or $state[$p:l1] = 112                            (: 'instance' :)
          or $state[$p:l1] = 115                            (: 'intersect' :)
          or $state[$p:l1] = 116                            (: 'is' :)
          or $state[$p:l1] = 117                            (: 'le' :)
          or $state[$p:l1] = 120                            (: 'let' :)
          or $state[$p:l1] = 122                            (: 'lt' :)
          or $state[$p:l1] = 123                            (: 'mod' :)
          or $state[$p:l1] = 124                            (: 'module' :)
          or $state[$p:l1] = 125                            (: 'ne' :)
          or $state[$p:l1] = 127                            (: 'or' :)
          or $state[$p:l1] = 133                            (: 'order' :)
          or $state[$p:l1] = 134                            (: 'return' :)
          or $state[$p:l1] = 144                            (: 'satisfies' :)
          or $state[$p:l1] = 145                            (: 'some' :)
          or $state[$p:l1] = 150                            (: 'stable' :)
          or $state[$p:l1] = 151                            (: 'to' :)
          or $state[$p:l1] = 157                            (: 'treat' :)
          or $state[$p:l1] = 158                            (: 'try' :)
          or $state[$p:l1] = 159                            (: 'union' :)
          or $state[$p:l1] = 161                            (: 'validate' :)
          or $state[$p:l1] = 163                            (: 'where' :)
          or $state[$p:l1] = 166                            (: 'xquery' :)
          or $state[$p:l1] = 167) then                      (: 'xquery' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 3                                   (: IntegerLiteral :)
     or $state[$p:lk] = 4                                   (: DecimalLiteral :)
     or $state[$p:lk] = 5                                   (: DoubleLiteral :)
     or $state[$p:lk] = 6                                   (: StringLiteral :)
     or $state[$p:lk] = 28                                  (: '$' :)
     or $state[$p:lk] = 30                                  (: '(' :)
     or $state[$p:lk] = 41                                  (: '.' :)
     or $state[$p:lk] = 50                                  (: '<' :)
     or $state[$p:lk] = 51                                  (: '<!--' :)
     or $state[$p:lk] = 55                                  (: '<?' :)
     or $state[$p:lk] = 4238                                (: 'processing-instruction' NCName^Token :)
     or $state[$p:lk] = 4423                                (: 'attribute' QName^Token :)
     or $state[$p:lk] = 4445                                (: 'element' QName^Token :)
     or $state[$p:lk] = 4478                                (: 'namespace' QName^Token :)
     or $state[$p:lk] = 7697                                (: QName^Token '(' :)
     or $state[$p:lk] = 7745                                (: 'ancestor' '(' :)
     or $state[$p:lk] = 7746                                (: 'ancestor-or-self' '(' :)
     or $state[$p:lk] = 7747                                (: 'and' '(' :)
     or $state[$p:lk] = 7749                                (: 'ascending' '(' :)
     or $state[$p:lk] = 7756                                (: 'case' '(' :)
     or $state[$p:lk] = 7757                                (: 'cast' '(' :)
     or $state[$p:lk] = 7758                                (: 'castable' '(' :)
     or $state[$p:lk] = 7759                                (: 'catch' '(' :)
     or $state[$p:lk] = 7760                                (: 'child' '(' :)
     or $state[$p:lk] = 7761                                (: 'collation' '(' :)
     or $state[$p:lk] = 7765                                (: 'declare' '(' :)
     or $state[$p:lk] = 7766                                (: 'default' '(' :)
     or $state[$p:lk] = 7767                                (: 'descendant' '(' :)
     or $state[$p:lk] = 7768                                (: 'descendant-or-self' '(' :)
     or $state[$p:lk] = 7769                                (: 'descending' '(' :)
     or $state[$p:lk] = 7770                                (: 'div' '(' :)
     or $state[$p:lk] = 7771                                (: 'document' '(' :)
     or $state[$p:lk] = 7774                                (: 'else' '(' :)
     or $state[$p:lk] = 7775                                (: 'empty' '(' :)
     or $state[$p:lk] = 7778                                (: 'eq' '(' :)
     or $state[$p:lk] = 7779                                (: 'every' '(' :)
     or $state[$p:lk] = 7780                                (: 'except' '(' :)
     or $state[$p:lk] = 7782                                (: 'following' '(' :)
     or $state[$p:lk] = 7783                                (: 'following-sibling' '(' :)
     or $state[$p:lk] = 7784                                (: 'for' '(' :)
     or $state[$p:lk] = 7787                                (: 'ge' '(' :)
     or $state[$p:lk] = 7789                                (: 'gt' '(' :)
     or $state[$p:lk] = 7790                                (: 'idiv' '(' :)
     or $state[$p:lk] = 7792                                (: 'import' '(' :)
     or $state[$p:lk] = 7795                                (: 'instance' '(' :)
     or $state[$p:lk] = 7796                                (: 'intersect' '(' :)
     or $state[$p:lk] = 7797                                (: 'is' '(' :)
     or $state[$p:lk] = 7800                                (: 'le' '(' :)
     or $state[$p:lk] = 7802                                (: 'let' '(' :)
     or $state[$p:lk] = 7803                                (: 'lt' '(' :)
     or $state[$p:lk] = 7804                                (: 'mod' '(' :)
     or $state[$p:lk] = 7805                                (: 'module' '(' :)
     or $state[$p:lk] = 7807                                (: 'ne' '(' :)
     or $state[$p:lk] = 7813                                (: 'or' '(' :)
     or $state[$p:lk] = 7814                                (: 'order' '(' :)
     or $state[$p:lk] = 7815                                (: 'ordered' '(' :)
     or $state[$p:lk] = 7817                                (: 'parent' '(' :)
     or $state[$p:lk] = 7818                                (: 'preceding' '(' :)
     or $state[$p:lk] = 7819                                (: 'preceding-sibling' '(' :)
     or $state[$p:lk] = 7823                                (: 'property' '(' :)
     or $state[$p:lk] = 7824                                (: 'return' '(' :)
     or $state[$p:lk] = 7825                                (: 'satisfies' '(' :)
     or $state[$p:lk] = 7829                                (: 'self' '(' :)
     or $state[$p:lk] = 7830                                (: 'some' '(' :)
     or $state[$p:lk] = 7831                                (: 'stable' '(' :)
     or $state[$p:lk] = 7837                                (: 'to' '(' :)
     or $state[$p:lk] = 7838                                (: 'treat' '(' :)
     or $state[$p:lk] = 7839                                (: 'try' '(' :)
     or $state[$p:lk] = 7841                                (: 'union' '(' :)
     or $state[$p:lk] = 7842                                (: 'unordered' '(' :)
     or $state[$p:lk] = 7843                                (: 'validate' '(' :)
     or $state[$p:lk] = 7846                                (: 'where' '(' :)
     or $state[$p:lk] = 7847                                (: 'xquery' '(' :)
     or $state[$p:lk] = 16711                               (: 'attribute' 'ancestor' :)
     or $state[$p:lk] = 16733                               (: 'element' 'ancestor' :)
     or $state[$p:lk] = 16766                               (: 'namespace' 'ancestor' :)
     or $state[$p:lk] = 16967                               (: 'attribute' 'ancestor-or-self' :)
     or $state[$p:lk] = 16989                               (: 'element' 'ancestor-or-self' :)
     or $state[$p:lk] = 17022                               (: 'namespace' 'ancestor-or-self' :)
     or $state[$p:lk] = 18247                               (: 'attribute' 'attribute' :)
     or $state[$p:lk] = 18269                               (: 'element' 'attribute' :)
     or $state[$p:lk] = 18302                               (: 'namespace' 'attribute' :)
     or $state[$p:lk] = 18759                               (: 'attribute' 'binary' :)
     or $state[$p:lk] = 18781                               (: 'element' 'binary' :)
     or $state[$p:lk] = 18814                               (: 'namespace' 'binary' :)
     or $state[$p:lk] = 20295                               (: 'attribute' 'catch' :)
     or $state[$p:lk] = 20317                               (: 'element' 'catch' :)
     or $state[$p:lk] = 20350                               (: 'namespace' 'catch' :)
     or $state[$p:lk] = 20551                               (: 'attribute' 'child' :)
     or $state[$p:lk] = 20573                               (: 'element' 'child' :)
     or $state[$p:lk] = 20606                               (: 'namespace' 'child' :)
     or $state[$p:lk] = 21063                               (: 'attribute' 'comment' :)
     or $state[$p:lk] = 21085                               (: 'element' 'comment' :)
     or $state[$p:lk] = 21118                               (: 'namespace' 'comment' :)
     or $state[$p:lk] = 21831                               (: 'attribute' 'declare' :)
     or $state[$p:lk] = 21853                               (: 'element' 'declare' :)
     or $state[$p:lk] = 21886                               (: 'namespace' 'declare' :)
     or $state[$p:lk] = 22343                               (: 'attribute' 'descendant' :)
     or $state[$p:lk] = 22365                               (: 'element' 'descendant' :)
     or $state[$p:lk] = 22398                               (: 'namespace' 'descendant' :)
     or $state[$p:lk] = 22599                               (: 'attribute' 'descendant-or-self' :)
     or $state[$p:lk] = 22621                               (: 'element' 'descendant-or-self' :)
     or $state[$p:lk] = 22654                               (: 'namespace' 'descendant-or-self' :)
     or $state[$p:lk] = 23367                               (: 'attribute' 'document' :)
     or $state[$p:lk] = 23389                               (: 'element' 'document' :)
     or $state[$p:lk] = 23422                               (: 'namespace' 'document' :)
     or $state[$p:lk] = 23623                               (: 'attribute' 'document-node' :)
     or $state[$p:lk] = 23645                               (: 'element' 'document-node' :)
     or $state[$p:lk] = 23678                               (: 'namespace' 'document-node' :)
     or $state[$p:lk] = 23879                               (: 'attribute' 'element' :)
     or $state[$p:lk] = 23901                               (: 'element' 'element' :)
     or $state[$p:lk] = 23934                               (: 'namespace' 'element' :)
     or $state[$p:lk] = 24647                               (: 'attribute' 'empty-sequence' :)
     or $state[$p:lk] = 24669                               (: 'element' 'empty-sequence' :)
     or $state[$p:lk] = 24702                               (: 'namespace' 'empty-sequence' :)
     or $state[$p:lk] = 25415                               (: 'attribute' 'every' :)
     or $state[$p:lk] = 25437                               (: 'element' 'every' :)
     or $state[$p:lk] = 25470                               (: 'namespace' 'every' :)
     or $state[$p:lk] = 26183                               (: 'attribute' 'following' :)
     or $state[$p:lk] = 26205                               (: 'element' 'following' :)
     or $state[$p:lk] = 26238                               (: 'namespace' 'following' :)
     or $state[$p:lk] = 26439                               (: 'attribute' 'following-sibling' :)
     or $state[$p:lk] = 26461                               (: 'element' 'following-sibling' :)
     or $state[$p:lk] = 26494                               (: 'namespace' 'following-sibling' :)
     or $state[$p:lk] = 28487                               (: 'attribute' 'if' :)
     or $state[$p:lk] = 28509                               (: 'element' 'if' :)
     or $state[$p:lk] = 28542                               (: 'namespace' 'if' :)
     or $state[$p:lk] = 28743                               (: 'attribute' 'import' :)
     or $state[$p:lk] = 28765                               (: 'element' 'import' :)
     or $state[$p:lk] = 28798                               (: 'namespace' 'import' :)
     or $state[$p:lk] = 30279                               (: 'attribute' 'item' :)
     or $state[$p:lk] = 30301                               (: 'element' 'item' :)
     or $state[$p:lk] = 30334                               (: 'namespace' 'item' :)
     or $state[$p:lk] = 32071                               (: 'attribute' 'module' :)
     or $state[$p:lk] = 32093                               (: 'element' 'module' :)
     or $state[$p:lk] = 32126                               (: 'namespace' 'module' :)
     or $state[$p:lk] = 32327                               (: 'attribute' 'namespace' :)
     or $state[$p:lk] = 32349                               (: 'element' 'namespace' :)
     or $state[$p:lk] = 32382                               (: 'namespace' 'namespace' :)
     or $state[$p:lk] = 33351                               (: 'attribute' 'node' :)
     or $state[$p:lk] = 33373                               (: 'element' 'node' :)
     or $state[$p:lk] = 33406                               (: 'namespace' 'node' :)
     or $state[$p:lk] = 34631                               (: 'attribute' 'ordered' :)
     or $state[$p:lk] = 34653                               (: 'element' 'ordered' :)
     or $state[$p:lk] = 34686                               (: 'namespace' 'ordered' :)
     or $state[$p:lk] = 35143                               (: 'attribute' 'parent' :)
     or $state[$p:lk] = 35165                               (: 'element' 'parent' :)
     or $state[$p:lk] = 35198                               (: 'namespace' 'parent' :)
     or $state[$p:lk] = 35399                               (: 'attribute' 'preceding' :)
     or $state[$p:lk] = 35421                               (: 'element' 'preceding' :)
     or $state[$p:lk] = 35454                               (: 'namespace' 'preceding' :)
     or $state[$p:lk] = 35655                               (: 'attribute' 'preceding-sibling' :)
     or $state[$p:lk] = 35677                               (: 'element' 'preceding-sibling' :)
     or $state[$p:lk] = 35710                               (: 'namespace' 'preceding-sibling' :)
     or $state[$p:lk] = 36423                               (: 'attribute' 'processing-instruction' :)
     or $state[$p:lk] = 36445                               (: 'element' 'processing-instruction' :)
     or $state[$p:lk] = 36478                               (: 'namespace' 'processing-instruction' :)
     or $state[$p:lk] = 36679                               (: 'attribute' 'property' :)
     or $state[$p:lk] = 36701                               (: 'element' 'property' :)
     or $state[$p:lk] = 36734                               (: 'namespace' 'property' :)
     or $state[$p:lk] = 37703                               (: 'attribute' 'schema-attribute' :)
     or $state[$p:lk] = 37725                               (: 'element' 'schema-attribute' :)
     or $state[$p:lk] = 37758                               (: 'namespace' 'schema-attribute' :)
     or $state[$p:lk] = 37959                               (: 'attribute' 'schema-element' :)
     or $state[$p:lk] = 37981                               (: 'element' 'schema-element' :)
     or $state[$p:lk] = 38014                               (: 'namespace' 'schema-element' :)
     or $state[$p:lk] = 38215                               (: 'attribute' 'self' :)
     or $state[$p:lk] = 38237                               (: 'element' 'self' :)
     or $state[$p:lk] = 38270                               (: 'namespace' 'self' :)
     or $state[$p:lk] = 38471                               (: 'attribute' 'some' :)
     or $state[$p:lk] = 38493                               (: 'element' 'some' :)
     or $state[$p:lk] = 38526                               (: 'namespace' 'some' :)
     or $state[$p:lk] = 39751                               (: 'attribute' 'text' :)
     or $state[$p:lk] = 39773                               (: 'element' 'text' :)
     or $state[$p:lk] = 39806                               (: 'namespace' 'text' :)
     or $state[$p:lk] = 40775                               (: 'attribute' 'try' :)
     or $state[$p:lk] = 40797                               (: 'element' 'try' :)
     or $state[$p:lk] = 40830                               (: 'namespace' 'try' :)
     or $state[$p:lk] = 41031                               (: 'attribute' 'typeswitch' :)
     or $state[$p:lk] = 41053                               (: 'element' 'typeswitch' :)
     or $state[$p:lk] = 41086                               (: 'namespace' 'typeswitch' :)
     or $state[$p:lk] = 41543                               (: 'attribute' 'unordered' :)
     or $state[$p:lk] = 41565                               (: 'element' 'unordered' :)
     or $state[$p:lk] = 41598                               (: 'namespace' 'unordered' :)
     or $state[$p:lk] = 41799                               (: 'attribute' 'validate' :)
     or $state[$p:lk] = 41821                               (: 'element' 'validate' :)
     or $state[$p:lk] = 41854                               (: 'namespace' 'validate' :)
     or $state[$p:lk] = 42823                               (: 'attribute' 'xquery' :)
     or $state[$p:lk] = 42845                               (: 'element' 'xquery' :)
     or $state[$p:lk] = 42878                               (: 'namespace' 'xquery' :)
     or $state[$p:lk] = 43079                               (: 'attribute' '{' :)
     or $state[$p:lk] = 43081                               (: 'binary' '{' :)
     or $state[$p:lk] = 43090                               (: 'comment' '{' :)
     or $state[$p:lk] = 43099                               (: 'document' '{' :)
     or $state[$p:lk] = 43101                               (: 'element' '{' :)
     or $state[$p:lk] = 43134                               (: 'namespace' '{' :)
     or $state[$p:lk] = 43143                               (: 'ordered' '{' :)
     or $state[$p:lk] = 43150                               (: 'processing-instruction' '{' :)
     or $state[$p:lk] = 43163                               (: 'text' '{' :)
     or $state[$p:lk] = 43170                               (: 'unordered' '{' :)
     or $state[$p:lk] = 11027271                            (: 'attribute' 'and' '{' :)
     or $state[$p:lk] = 11027293                            (: 'element' 'and' '{' :)
     or $state[$p:lk] = 11027326                            (: 'namespace' 'and' '{' :)
     or $state[$p:lk] = 11027342                            (: 'processing-instruction' 'and' '{' :)
     or $state[$p:lk] = 11027783                            (: 'attribute' 'ascending' '{' :)
     or $state[$p:lk] = 11027805                            (: 'element' 'ascending' '{' :)
     or $state[$p:lk] = 11027838                            (: 'namespace' 'ascending' '{' :)
     or $state[$p:lk] = 11027854                            (: 'processing-instruction' 'ascending' '{' :)
     or $state[$p:lk] = 11029575                            (: 'attribute' 'case' '{' :)
     or $state[$p:lk] = 11029597                            (: 'element' 'case' '{' :)
     or $state[$p:lk] = 11029630                            (: 'namespace' 'case' '{' :)
     or $state[$p:lk] = 11029646                            (: 'processing-instruction' 'case' '{' :)
     or $state[$p:lk] = 11029831                            (: 'attribute' 'cast' '{' :)
     or $state[$p:lk] = 11029853                            (: 'element' 'cast' '{' :)
     or $state[$p:lk] = 11029886                            (: 'namespace' 'cast' '{' :)
     or $state[$p:lk] = 11029902                            (: 'processing-instruction' 'cast' '{' :)
     or $state[$p:lk] = 11030087                            (: 'attribute' 'castable' '{' :)
     or $state[$p:lk] = 11030109                            (: 'element' 'castable' '{' :)
     or $state[$p:lk] = 11030142                            (: 'namespace' 'castable' '{' :)
     or $state[$p:lk] = 11030158                            (: 'processing-instruction' 'castable' '{' :)
     or $state[$p:lk] = 11030855                            (: 'attribute' 'collation' '{' :)
     or $state[$p:lk] = 11030877                            (: 'element' 'collation' '{' :)
     or $state[$p:lk] = 11030910                            (: 'namespace' 'collation' '{' :)
     or $state[$p:lk] = 11030926                            (: 'processing-instruction' 'collation' '{' :)
     or $state[$p:lk] = 11032135                            (: 'attribute' 'default' '{' :)
     or $state[$p:lk] = 11032157                            (: 'element' 'default' '{' :)
     or $state[$p:lk] = 11032190                            (: 'namespace' 'default' '{' :)
     or $state[$p:lk] = 11032206                            (: 'processing-instruction' 'default' '{' :)
     or $state[$p:lk] = 11032903                            (: 'attribute' 'descending' '{' :)
     or $state[$p:lk] = 11032925                            (: 'element' 'descending' '{' :)
     or $state[$p:lk] = 11032958                            (: 'namespace' 'descending' '{' :)
     or $state[$p:lk] = 11032974                            (: 'processing-instruction' 'descending' '{' :)
     or $state[$p:lk] = 11033159                            (: 'attribute' 'div' '{' :)
     or $state[$p:lk] = 11033181                            (: 'element' 'div' '{' :)
     or $state[$p:lk] = 11033214                            (: 'namespace' 'div' '{' :)
     or $state[$p:lk] = 11033230                            (: 'processing-instruction' 'div' '{' :)
     or $state[$p:lk] = 11034183                            (: 'attribute' 'else' '{' :)
     or $state[$p:lk] = 11034205                            (: 'element' 'else' '{' :)
     or $state[$p:lk] = 11034238                            (: 'namespace' 'else' '{' :)
     or $state[$p:lk] = 11034254                            (: 'processing-instruction' 'else' '{' :)
     or $state[$p:lk] = 11034439                            (: 'attribute' 'empty' '{' :)
     or $state[$p:lk] = 11034461                            (: 'element' 'empty' '{' :)
     or $state[$p:lk] = 11034494                            (: 'namespace' 'empty' '{' :)
     or $state[$p:lk] = 11034510                            (: 'processing-instruction' 'empty' '{' :)
     or $state[$p:lk] = 11035207                            (: 'attribute' 'eq' '{' :)
     or $state[$p:lk] = 11035229                            (: 'element' 'eq' '{' :)
     or $state[$p:lk] = 11035262                            (: 'namespace' 'eq' '{' :)
     or $state[$p:lk] = 11035278                            (: 'processing-instruction' 'eq' '{' :)
     or $state[$p:lk] = 11035719                            (: 'attribute' 'except' '{' :)
     or $state[$p:lk] = 11035741                            (: 'element' 'except' '{' :)
     or $state[$p:lk] = 11035774                            (: 'namespace' 'except' '{' :)
     or $state[$p:lk] = 11035790                            (: 'processing-instruction' 'except' '{' :)
     or $state[$p:lk] = 11036743                            (: 'attribute' 'for' '{' :)
     or $state[$p:lk] = 11036765                            (: 'element' 'for' '{' :)
     or $state[$p:lk] = 11036798                            (: 'namespace' 'for' '{' :)
     or $state[$p:lk] = 11036814                            (: 'processing-instruction' 'for' '{' :)
     or $state[$p:lk] = 11037511                            (: 'attribute' 'ge' '{' :)
     or $state[$p:lk] = 11037533                            (: 'element' 'ge' '{' :)
     or $state[$p:lk] = 11037566                            (: 'namespace' 'ge' '{' :)
     or $state[$p:lk] = 11037582                            (: 'processing-instruction' 'ge' '{' :)
     or $state[$p:lk] = 11038023                            (: 'attribute' 'gt' '{' :)
     or $state[$p:lk] = 11038045                            (: 'element' 'gt' '{' :)
     or $state[$p:lk] = 11038078                            (: 'namespace' 'gt' '{' :)
     or $state[$p:lk] = 11038094                            (: 'processing-instruction' 'gt' '{' :)
     or $state[$p:lk] = 11038279                            (: 'attribute' 'idiv' '{' :)
     or $state[$p:lk] = 11038301                            (: 'element' 'idiv' '{' :)
     or $state[$p:lk] = 11038334                            (: 'namespace' 'idiv' '{' :)
     or $state[$p:lk] = 11038350                            (: 'processing-instruction' 'idiv' '{' :)
     or $state[$p:lk] = 11039559                            (: 'attribute' 'instance' '{' :)
     or $state[$p:lk] = 11039581                            (: 'element' 'instance' '{' :)
     or $state[$p:lk] = 11039614                            (: 'namespace' 'instance' '{' :)
     or $state[$p:lk] = 11039630                            (: 'processing-instruction' 'instance' '{' :)
     or $state[$p:lk] = 11039815                            (: 'attribute' 'intersect' '{' :)
     or $state[$p:lk] = 11039837                            (: 'element' 'intersect' '{' :)
     or $state[$p:lk] = 11039870                            (: 'namespace' 'intersect' '{' :)
     or $state[$p:lk] = 11039886                            (: 'processing-instruction' 'intersect' '{' :)
     or $state[$p:lk] = 11040071                            (: 'attribute' 'is' '{' :)
     or $state[$p:lk] = 11040093                            (: 'element' 'is' '{' :)
     or $state[$p:lk] = 11040126                            (: 'namespace' 'is' '{' :)
     or $state[$p:lk] = 11040142                            (: 'processing-instruction' 'is' '{' :)
     or $state[$p:lk] = 11040839                            (: 'attribute' 'le' '{' :)
     or $state[$p:lk] = 11040861                            (: 'element' 'le' '{' :)
     or $state[$p:lk] = 11040894                            (: 'namespace' 'le' '{' :)
     or $state[$p:lk] = 11040910                            (: 'processing-instruction' 'le' '{' :)
     or $state[$p:lk] = 11041351                            (: 'attribute' 'let' '{' :)
     or $state[$p:lk] = 11041373                            (: 'element' 'let' '{' :)
     or $state[$p:lk] = 11041406                            (: 'namespace' 'let' '{' :)
     or $state[$p:lk] = 11041422                            (: 'processing-instruction' 'let' '{' :)
     or $state[$p:lk] = 11041607                            (: 'attribute' 'lt' '{' :)
     or $state[$p:lk] = 11041629                            (: 'element' 'lt' '{' :)
     or $state[$p:lk] = 11041662                            (: 'namespace' 'lt' '{' :)
     or $state[$p:lk] = 11041678                            (: 'processing-instruction' 'lt' '{' :)
     or $state[$p:lk] = 11041863                            (: 'attribute' 'mod' '{' :)
     or $state[$p:lk] = 11041885                            (: 'element' 'mod' '{' :)
     or $state[$p:lk] = 11041918                            (: 'namespace' 'mod' '{' :)
     or $state[$p:lk] = 11041934                            (: 'processing-instruction' 'mod' '{' :)
     or $state[$p:lk] = 11042631                            (: 'attribute' 'ne' '{' :)
     or $state[$p:lk] = 11042653                            (: 'element' 'ne' '{' :)
     or $state[$p:lk] = 11042686                            (: 'namespace' 'ne' '{' :)
     or $state[$p:lk] = 11042702                            (: 'processing-instruction' 'ne' '{' :)
     or $state[$p:lk] = 11044167                            (: 'attribute' 'or' '{' :)
     or $state[$p:lk] = 11044189                            (: 'element' 'or' '{' :)
     or $state[$p:lk] = 11044222                            (: 'namespace' 'or' '{' :)
     or $state[$p:lk] = 11044238                            (: 'processing-instruction' 'or' '{' :)
     or $state[$p:lk] = 11044423                            (: 'attribute' 'order' '{' :)
     or $state[$p:lk] = 11044445                            (: 'element' 'order' '{' :)
     or $state[$p:lk] = 11044478                            (: 'namespace' 'order' '{' :)
     or $state[$p:lk] = 11044494                            (: 'processing-instruction' 'order' '{' :)
     or $state[$p:lk] = 11046983                            (: 'attribute' 'return' '{' :)
     or $state[$p:lk] = 11047005                            (: 'element' 'return' '{' :)
     or $state[$p:lk] = 11047038                            (: 'namespace' 'return' '{' :)
     or $state[$p:lk] = 11047054                            (: 'processing-instruction' 'return' '{' :)
     or $state[$p:lk] = 11047239                            (: 'attribute' 'satisfies' '{' :)
     or $state[$p:lk] = 11047261                            (: 'element' 'satisfies' '{' :)
     or $state[$p:lk] = 11047294                            (: 'namespace' 'satisfies' '{' :)
     or $state[$p:lk] = 11047310                            (: 'processing-instruction' 'satisfies' '{' :)
     or $state[$p:lk] = 11048775                            (: 'attribute' 'stable' '{' :)
     or $state[$p:lk] = 11048797                            (: 'element' 'stable' '{' :)
     or $state[$p:lk] = 11048830                            (: 'namespace' 'stable' '{' :)
     or $state[$p:lk] = 11048846                            (: 'processing-instruction' 'stable' '{' :)
     or $state[$p:lk] = 11050311                            (: 'attribute' 'to' '{' :)
     or $state[$p:lk] = 11050333                            (: 'element' 'to' '{' :)
     or $state[$p:lk] = 11050366                            (: 'namespace' 'to' '{' :)
     or $state[$p:lk] = 11050382                            (: 'processing-instruction' 'to' '{' :)
     or $state[$p:lk] = 11050567                            (: 'attribute' 'treat' '{' :)
     or $state[$p:lk] = 11050589                            (: 'element' 'treat' '{' :)
     or $state[$p:lk] = 11050622                            (: 'namespace' 'treat' '{' :)
     or $state[$p:lk] = 11050638                            (: 'processing-instruction' 'treat' '{' :)
     or $state[$p:lk] = 11051335                            (: 'attribute' 'union' '{' :)
     or $state[$p:lk] = 11051357                            (: 'element' 'union' '{' :)
     or $state[$p:lk] = 11051390                            (: 'namespace' 'union' '{' :)
     or $state[$p:lk] = 11051406                            (: 'processing-instruction' 'union' '{' :)
     or $state[$p:lk] = 11052615                            (: 'attribute' 'where' '{' :)
     or $state[$p:lk] = 11052637                            (: 'element' 'where' '{' :)
     or $state[$p:lk] = 11052670                            (: 'namespace' 'where' '{' :)
     or $state[$p:lk] = 11052686) then                      (: 'processing-instruction' 'where' '{' :)
      let $state := p:parse-FilterExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AxisStep($input, $state)
      return $state
  return p:reduce($state, "StepExpr", $count)
};

(:~
 : Parse the 1st loop of production RelativePathExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(150, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | ']' | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 43                               (: '/' :)
      and $state[$p:l1] != 44) then                         (: '//' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 43) then                      (: '/' :)
            let $state := p:shift(43, $input, $state)       (: '/' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(44, $input, $state)       (: '//' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-StepExpr($input, $state)
        return p:parse-RelativePathExpr-1($input, $state)
};

(:~
 : Parse RelativePathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RelativePathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-StepExpr($input, $state)
  let $state := p:parse-RelativePathExpr-1($input, $state)
  return p:reduce($state, "RelativePathExpr", $count)
};

(:~
 : Parse PathExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PathExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 43) then                            (: '/' :)
      let $state := p:shift(43, $input, $state)             (: '/' :)
      let $state := p:lookahead1W(183, $input, $state)      (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '!=' | '$' | '(' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               '.' | '..' | ';' | '<' | '<!--' | '<<' | '<=' | '<?' |
                                                               '=' | '>' | '>=' | '>>' | '@' | ']' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' | '|' | '}' :)
      let $state :=
        if ($state[$p:l1] = 24                              (: EOF :)
         or $state[$p:l1] = 25                              (: '!=' :)
         or $state[$p:l1] = 33                              (: ')' :)
         or $state[$p:l1] = 34                              (: '*' :)
         or $state[$p:l1] = 36                              (: '+' :)
         or $state[$p:l1] = 38                              (: ',' :)
         or $state[$p:l1] = 39                              (: '-' :)
         or $state[$p:l1] = 49                              (: ';' :)
         or $state[$p:l1] = 53                              (: '<<' :)
         or $state[$p:l1] = 54                              (: '<=' :)
         or $state[$p:l1] = 56                              (: '=' :)
         or $state[$p:l1] = 57                              (: '>' :)
         or $state[$p:l1] = 58                              (: '>=' :)
         or $state[$p:l1] = 59                              (: '>>' :)
         or $state[$p:l1] = 64                              (: ']' :)
         or $state[$p:l1] = 170                             (: '|' :)
         or $state[$p:l1] = 171) then                       (: '}' :)
          $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-RelativePathExpr($input, $state)
          return $state
      return $state
    else if ($state[$p:l1] = 44) then                       (: '//' :)
      let $state := p:shift(44, $input, $state)             (: '//' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-RelativePathExpr($input, $state)
      return $state
  return p:reduce($state, "PathExpr", $count)
};

(:~
 : Parse ValidationMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidationMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 119) then                           (: 'lax' :)
      let $state := p:shift(119, $input, $state)            (: 'lax' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(152, $input, $state)            (: 'strict' :)
      return $state
  return p:reduce($state, "ValidationMode", $count)
};

(:~
 : Parse ValidateExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValidateExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(163, $input, $state)                (: 'validate' :)
  let $state := p:lookahead1W(118, $input, $state)          (: S^WS | '(.' | 'as' | 'full' | 'lax' | 'strict' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 105                           (: 'full' :)
         and $state[$p:l1] != 168) then                     (: '{' :)
      let $state :=
        if ($state[$p:l1] = 68) then                        (: 'as' :)
          let $state := p:shift(68, $input, $state)         (: 'as' :)
          let $state := p:lookahead1W(167, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:parse-QName($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-ValidationMode($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(92, $input, $state)           (: S^WS | '(.' | 'full' | '{' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 105) then                      (: 'full' :)
      let $state := p:shift(105, $input, $state)            (: 'full' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(64, $input, $state)           (: S^WS | '(.' | '{' :)
  let $state := p:shift(168, $input, $state)                (: '{' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(65, $input, $state)           (: S^WS | '(.' | '}' :)
  let $state := p:shift(171, $input, $state)                (: '}' :)
  return p:reduce($state, "ValidateExpr", $count)
};

(:~
 : Parse ValueExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ValueExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 163) then                           (: 'validate' :)
      let $state := p:lookahead2W(162, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'as' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'full' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'lax' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'strict' | 'to' | 'treat' |
                                                               'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 17571                               (: 'validate' 'as' :)
     or $state[$p:lk] = 27043                               (: 'validate' 'full' :)
     or $state[$p:lk] = 30627                               (: 'validate' 'lax' :)
     or $state[$p:lk] = 39075                               (: 'validate' 'strict' :)
     or $state[$p:lk] = 43171) then                         (: 'validate' '{' :)
      let $state := p:parse-ValidateExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 31) then                       (: '(#' :)
      let $state := p:parse-ExtensionExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-PathExpr($input, $state)
      return $state
  return p:reduce($state, "ValueExpr", $count)
};

(:~
 : Parse the 1st loop of production UnaryExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(174, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 39) then                      (: '-' :)
            let $state := p:shift(39, $input, $state)       (: '-' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(36, $input, $state)       (: '+' :)
            return $state
        return p:parse-UnaryExpr-1($input, $state)
};

(:~
 : Parse UnaryExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnaryExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr-1($input, $state)
  let $state := p:parse-ValueExpr($input, $state)
  return p:reduce($state, "UnaryExpr", $count)
};

(:~
 : Parse CastExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnaryExpr($input, $state)
  let $state := p:lookahead1W(148, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:shift(77, $input, $state)             (: 'cast' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastExpr", $count)
};

(:~
 : Parse CastableExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CastableExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastExpr($input, $state)
  let $state := p:lookahead1W(147, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'castable' | 'collation' |
                                                               'default' | 'descending' | 'div' | 'else' | 'empty' |
                                                               'eq' | 'except' | 'for' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:shift(78, $input, $state)             (: 'castable' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SingleType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "CastableExpr", $count)
};

(:~
 : Parse TreatExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TreatExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-CastableExpr($input, $state)
  let $state := p:lookahead1W(146, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 158) then                      (: 'treat' :)
      let $state := p:shift(158, $input, $state)            (: 'treat' :)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "TreatExpr", $count)
};

(:~
 : Parse InstanceofExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InstanceofExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-TreatExpr($input, $state)
  let $state := p:lookahead1W(144, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '|' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 115) then                      (: 'instance' :)
      let $state := p:shift(115, $input, $state)            (: 'instance' :)
      let $state := p:lookahead1W(54, $input, $state)       (: S^WS | '(.' | 'of' :)
      let $state := p:shift(131, $input, $state)            (: 'of' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-SequenceType($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "InstanceofExpr", $count)
};

(:~
 : Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(143, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 100                              (: 'except' :)
      and $state[$p:l1] != 116) then                        (: 'intersect' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 116) then                     (: 'intersect' :)
            let $state := p:shift(116, $input, $state)      (: 'intersect' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(100, $input, $state)      (: 'except' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-InstanceofExpr($input, $state)
        return p:parse-IntersectExceptExpr-1($input, $state)
};

(:~
 : Parse IntersectExceptExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IntersectExceptExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-InstanceofExpr($input, $state)
  let $state := p:parse-IntersectExceptExpr-1($input, $state)
  return p:reduce($state, "IntersectExceptExpr", $count)
};

(:~
 : Parse the 1st loop of production UnionExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(142, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'union' | 'where' | '|' | '}' :)
    return
      if ($state[$p:l1] != 161                              (: 'union' :)
      and $state[$p:l1] != 170) then                        (: '|' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 161) then                     (: 'union' :)
            let $state := p:shift(161, $input, $state)      (: 'union' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(170, $input, $state)      (: '|' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-IntersectExceptExpr($input, $state)
        return p:parse-UnionExpr-1($input, $state)
};

(:~
 : Parse UnionExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-UnionExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-IntersectExceptExpr($input, $state)
  let $state := p:parse-UnionExpr-1($input, $state)
  return p:reduce($state, "UnionExpr", $count)
};

(:~
 : Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(141, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '+' | ',' | '-' |
                                                               ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'is' | 'le' | 'let' | 'lt' |
                                                               'mod' | 'ne' | 'or' | 'order' | 'return' | 'satisfies' |
                                                               'stable' | 'to' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 34                               (: '*' :)
      and $state[$p:l1] != 90                               (: 'div' :)
      and $state[$p:l1] != 110                              (: 'idiv' :)
      and $state[$p:l1] != 124) then                        (: 'mod' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 34) then                      (: '*' :)
            let $state := p:shift(34, $input, $state)       (: '*' :)
            return $state
          else if ($state[$p:l1] = 90) then                 (: 'div' :)
            let $state := p:shift(90, $input, $state)       (: 'div' :)
            return $state
          else if ($state[$p:l1] = 110) then                (: 'idiv' :)
            let $state := p:shift(110, $input, $state)      (: 'idiv' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(124, $input, $state)      (: 'mod' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-UnionExpr($input, $state)
        return p:parse-MultiplicativeExpr-1($input, $state)
};

(:~
 : Parse MultiplicativeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-MultiplicativeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-UnionExpr($input, $state)
  let $state := p:parse-MultiplicativeExpr-1($input, $state)
  return p:reduce($state, "MultiplicativeExpr", $count)
};

(:~
 : Parse the 1st loop of production AdditiveExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(138, $input, $state)        (: S^WS | EOF | '!=' | '(.' | ')' | '+' | ',' | '-' | ';' |
                                                               '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' |
                                                               'and' | 'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
    return
      if ($state[$p:l1] != 36                               (: '+' :)
      and $state[$p:l1] != 39) then                         (: '-' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 36) then                      (: '+' :)
            let $state := p:shift(36, $input, $state)       (: '+' :)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:shift(39, $input, $state)       (: '-' :)
            return $state
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-MultiplicativeExpr($input, $state)
        return p:parse-AdditiveExpr-1($input, $state)
};

(:~
 : Parse AdditiveExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AdditiveExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-MultiplicativeExpr($input, $state)
  let $state := p:parse-AdditiveExpr-1($input, $state)
  return p:reduce($state, "AdditiveExpr", $count)
};

(:~
 : Parse RangeExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-RangeExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AdditiveExpr($input, $state)
  let $state := p:lookahead1W(135, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'where' | '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 157) then                      (: 'to' :)
      let $state := p:shift(157, $input, $state)            (: 'to' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-AdditiveExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "RangeExpr", $count)
};

(:~
 : Parse ComparisonExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ComparisonExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-RangeExpr($input, $state)
  let $state := p:lookahead1W(134, $input, $state)          (: S^WS | EOF | '!=' | '(.' | ')' | ',' | ';' | '<' | '<<' |
                                                               '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'eq' | 'for' | 'ge' |
                                                               'gt' | 'is' | 'le' | 'let' | 'lt' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 25                             (: '!=' :)
          or $state[$p:l1] = 50                             (: '<' :)
          or $state[$p:l1] = 53                             (: '<<' :)
          or $state[$p:l1] = 54                             (: '<=' :)
          or $state[$p:l1] = 56                             (: '=' :)
          or $state[$p:l1] = 57                             (: '>' :)
          or $state[$p:l1] = 58                             (: '>=' :)
          or $state[$p:l1] = 59                             (: '>>' :)
          or $state[$p:l1] = 98                             (: 'eq' :)
          or $state[$p:l1] = 107                            (: 'ge' :)
          or $state[$p:l1] = 109                            (: 'gt' :)
          or $state[$p:l1] = 117                            (: 'is' :)
          or $state[$p:l1] = 120                            (: 'le' :)
          or $state[$p:l1] = 123                            (: 'lt' :)
          or $state[$p:l1] = 127) then                      (: 'ne' :)
      let $state :=
        if ($state[$p:l1] = 98                              (: 'eq' :)
         or $state[$p:l1] = 107                             (: 'ge' :)
         or $state[$p:l1] = 109                             (: 'gt' :)
         or $state[$p:l1] = 120                             (: 'le' :)
         or $state[$p:l1] = 123                             (: 'lt' :)
         or $state[$p:l1] = 127) then                       (: 'ne' :)
          let $state := p:parse-ValueComp($input, $state)
          return $state
        else if ($state[$p:l1] = 53                         (: '<<' :)
              or $state[$p:l1] = 59                         (: '>>' :)
              or $state[$p:l1] = 117) then                  (: 'is' :)
          let $state := p:parse-NodeComp($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-GeneralComp($input, $state)
          return $state
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-RangeExpr($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ComparisonExpr", $count)
};

(:~
 : Parse the 1st loop of production AndExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(129, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ';' | ']' | 'and' |
                                                               'ascending' | 'case' | 'collation' | 'default' |
                                                               'descending' | 'else' | 'empty' | 'for' | 'let' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'where' |
                                                               '}' :)
    return
      if ($state[$p:l1] != 67) then                         (: 'and' :)
        $state
      else
        let $state := p:shift(67, $input, $state)           (: 'and' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ComparisonExpr($input, $state)
        return p:parse-AndExpr-1($input, $state)
};

(:~
 : Parse AndExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AndExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ComparisonExpr($input, $state)
  let $state := p:parse-AndExpr-1($input, $state)
  return p:reduce($state, "AndExpr", $count)
};

(:~
 : Parse the 1st loop of production OrExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(128, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ';' | ']' | 'ascending' |
                                                               'case' | 'collation' | 'default' | 'descending' |
                                                               'else' | 'empty' | 'for' | 'let' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'where' | '}' :)
    return
      if ($state[$p:l1] != 133) then                        (: 'or' :)
        $state
      else
        let $state := p:shift(133, $input, $state)          (: 'or' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-AndExpr($input, $state)
        return p:parse-OrExpr-1($input, $state)
};

(:~
 : Parse OrExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AndExpr($input, $state)
  let $state := p:parse-OrExpr-1($input, $state)
  return p:reduce($state, "OrExpr", $count)
};

(:~
 : Parse IfExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-IfExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(111, $input, $state)                (: 'if' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(61, $input, $state)           (: S^WS | '(.' | 'then' :)
  let $state := p:shift(156, $input, $state)                (: 'then' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(48, $input, $state)           (: S^WS | '(.' | 'else' :)
  let $state := p:shift(94, $input, $state)                 (: 'else' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "IfExpr", $count)
};

(:~
 : Parse CaseClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CaseClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(11, $input, $state)            (: 'case' :)
  let $state := p:shift(76, $input, $state)                 (: 'case' :)
  let $state := p:lookahead1W(169, $input, $state)          (: S^WS | QName^Token | '$' | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:shift(28, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(167, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      let $state := p:lookahead1W(37, $input, $state)       (: S^WS | '(.' | 'as' :)
      let $state := p:shift(68, $input, $state)             (: 'as' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(144, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "CaseClause", $count)
};

(:~
 : Parse the 1st loop of production Expr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(121, $input, $state)        (: S^WS | EOF | '(.' | ')' | ',' | ';' | ']' | '}' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-Expr-1($input, $state)
};

(:~
 : Parse Expr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Expr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-Expr-1($input, $state)
  return p:reduce($state, "Expr", $count)
};

(:~
 : Parse the 1st loop of production TypeswitchExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(22, $input, $state)         (: EPSILON | S^WS | '(.' :)
    let $state := p:parse-CaseClause($input, $state)
    let $state := p:lookahead1W(88, $input, $state)         (: S^WS | '(.' | 'case' | 'default' :)
    return
      if ($state[$p:l1] != 76) then                         (: 'case' :)
        $state
      else
        p:parse-TypeswitchExpr-1($input, $state)
};

(:~
 : Parse TypeswitchExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeswitchExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(160, $input, $state)                (: 'typeswitch' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Expr($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-TypeswitchExpr-1($input, $state)
  let $state := p:shift(86, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(71, $input, $state)           (: S^WS | '$' | '(.' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 28) then                       (: '$' :)
      let $state := p:shift(28, $input, $state)             (: '$' :)
      let $state := p:lookahead1W(167, $input, $state)      (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
      let $state := p:parse-VarName($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(144, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "TypeswitchExpr", $count)
};

(:~
 : Parse the 1st loop of production QuantifiedExpr (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(79, $input, $state)         (: S^WS | '(.' | ',' | 'satisfies' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(167, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(84, $input, $state)     (: S^WS | '(.' | 'as' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(51, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(113, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-QuantifiedExpr-1($input, $state)
};

(:~
 : Parse QuantifiedExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QuantifiedExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 150) then                           (: 'some' :)
      let $state := p:shift(150, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(99, $input, $state)             (: 'every' :)
      return $state
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(84, $input, $state)           (: S^WS | '(.' | 'as' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(113, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-QuantifiedExpr-1($input, $state)
  let $state := p:shift(145, $input, $state)                (: 'satisfies' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "QuantifiedExpr", $count)
};

(:~
 : Parse OrderModifier.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderModifier($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(122, $input, $state)          (: S^WS | '(.' | ',' | 'ascending' | 'collation' |
                                                               'descending' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 69                             (: 'ascending' :)
          or $state[$p:l1] = 89) then                       (: 'descending' :)
      let $state :=
        if ($state[$p:l1] = 69) then                        (: 'ascending' :)
          let $state := p:shift(69, $input, $state)         (: 'ascending' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(89, $input, $state)         (: 'descending' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(114, $input, $state)          (: S^WS | '(.' | ',' | 'collation' | 'empty' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 95) then                       (: 'empty' :)
      let $state := p:shift(95, $input, $state)             (: 'empty' :)
      let $state := p:lookahead1W(95, $input, $state)       (: S^WS | '(.' | 'greatest' | 'least' :)
      let $state :=
        if ($state[$p:l1] = 108) then                       (: 'greatest' :)
          let $state := p:shift(108, $input, $state)        (: 'greatest' :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:shift(121, $input, $state)        (: 'least' :)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(107, $input, $state)          (: S^WS | '(.' | ',' | 'collation' | 'return' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:shift(81, $input, $state)             (: 'collation' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "OrderModifier", $count)
};

(:~
 : Parse OrderSpec.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpec($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderModifier($input, $state)
  return p:reduce($state, "OrderSpec", $count)
};

(:~
 : Parse the 1st loop of production OrderSpecList (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(78, $input, $state)         (: S^WS | '(.' | ',' | 'return' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-OrderSpec($input, $state)
        return p:parse-OrderSpecList-1($input, $state)
};

(:~
 : Parse OrderSpecList.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderSpecList($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-OrderSpec($input, $state)
  let $state := p:parse-OrderSpecList-1($input, $state)
  return p:reduce($state, "OrderSpecList", $count)
};

(:~
 : Parse OrderByClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderByClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 134) then                           (: 'order' :)
      let $state := p:shift(134, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(75, $input, $state)             (: 'by' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(151, $input, $state)            (: 'stable' :)
      let $state := p:lookahead1W(56, $input, $state)       (: S^WS | '(.' | 'order' :)
      let $state := p:shift(134, $input, $state)            (: 'order' :)
      let $state := p:lookahead1W(41, $input, $state)       (: S^WS | '(.' | 'by' :)
      let $state := p:shift(75, $input, $state)             (: 'by' :)
      return $state
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-OrderSpecList($input, $state)
  return p:reduce($state, "OrderByClause", $count)
};

(:~
 : Parse WhereClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-WhereClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(166, $input, $state)                (: 'where' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "WhereClause", $count)
};

(:~
 : Parse the 1st loop of production LetClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(125, $input, $state)        (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(167, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(80, $input, $state)     (: S^WS | '(.' | ':=' | 'as' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(33, $input, $state)     (: S^WS | '(.' | ':=' :)
        let $state := p:shift(48, $input, $state)           (: ':=' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-LetClause-1($input, $state)
};

(:~
 : Parse LetClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LetClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(122, $input, $state)                (: 'let' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(80, $input, $state)           (: S^WS | '(.' | ':=' | 'as' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(33, $input, $state)           (: S^WS | '(.' | ':=' :)
  let $state := p:shift(48, $input, $state)                 (: ':=' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-LetClause-1($input, $state)
  return p:reduce($state, "LetClause", $count)
};

(:~
 : Parse PositionalVar.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PositionalVar($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(70, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  return p:reduce($state, "PositionalVar", $count)
};

(:~
 : Parse VarName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "VarName", $count)
};

(:~
 : Parse the 1st loop of production ForClause (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(125, $input, $state)        (: S^WS | '(.' | ',' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(28, $input, $state)     (: S^WS | '$' | '(.' :)
        let $state := p:shift(28, $input, $state)           (: '$' :)
        let $state := p:lookahead1W(167, $input, $state)    (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
        let $state := p:parse-VarName($input, $state)
        let $state := p:lookahead1W(109, $input, $state)    (: S^WS | '(.' | 'as' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 68) then                 (: 'as' :)
            let $state := p:parse-TypeDeclaration($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(86, $input, $state)     (: S^WS | '(.' | 'at' | 'in' :)
        let $state :=
          if ($state[$p:error]) then
            $state
          else if ($state[$p:l1] = 70) then                 (: 'at' :)
            let $state := p:parse-PositionalVar($input, $state)
            return $state
          else
            $state
        let $state := p:lookahead1W(51, $input, $state)     (: S^WS | '(.' | 'in' :)
        let $state := p:shift(113, $input, $state)          (: 'in' :)
        let $state := p:lookahead1W(22, $input, $state)     (: EPSILON | S^WS | '(.' :)
        let $state := p:parse-ExprSingle($input, $state)
        return p:parse-ForClause-1($input, $state)
};

(:~
 : Parse ForClause.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ForClause($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(104, $input, $state)                (: 'for' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-VarName($input, $state)
  let $state := p:lookahead1W(109, $input, $state)          (: S^WS | '(.' | 'as' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(86, $input, $state)           (: S^WS | '(.' | 'at' | 'in' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:parse-PositionalVar($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(51, $input, $state)           (: S^WS | '(.' | 'in' :)
  let $state := p:shift(113, $input, $state)                (: 'in' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  let $state := p:parse-ForClause-1($input, $state)
  return p:reduce($state, "ForClause", $count)
};

(:~
 : Parse the 1st loop of production FLWORExpr (one or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state :=
      if ($state[$p:l1] = 104) then                         (: 'for' :)
        let $state := p:parse-ForClause($input, $state)
        return $state
      else if ($state[$p:error]) then
        $state
      else
        let $state := p:parse-LetClause($input, $state)
        return $state
    let $state := p:lookahead1W(124, $input, $state)        (: S^WS | '(.' | 'for' | 'let' | 'order' | 'return' |
                                                               'stable' | 'where' :)
    return
      if ($state[$p:l1] != 104                              (: 'for' :)
      and $state[$p:l1] != 122) then                        (: 'let' :)
        $state
      else
        p:parse-FLWORExpr-1($input, $state)
};

(:~
 : Parse FLWORExpr.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FLWORExpr($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-FLWORExpr-1($input, $state)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 166) then                      (: 'where' :)
      let $state := p:parse-WhereClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(113, $input, $state)          (: S^WS | '(.' | 'order' | 'return' | 'stable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 144) then                     (: 'return' :)
      let $state := p:parse-OrderByClause($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(58, $input, $state)           (: S^WS | '(.' | 'return' :)
  let $state := p:shift(144, $input, $state)                (: 'return' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-ExprSingle($input, $state)
  return p:reduce($state, "FLWORExpr", $count)
};

(:~
 : Parse ExprSingle.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ExprSingle($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(174, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 159) then                           (: 'try' :)
      let $state := p:lookahead2W(156, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 111                            (: 'typeswitch' :)
          or $state[$p:l1] = 160) then                      (: 'typeswitch' :)
      let $state := p:lookahead2W(152, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '+' | ',' |
                                                               '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '[' | ']' | 'and' | 'ascending' | 'case' |
                                                               'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else if ($state[$p:l1] = 99                             (: 'for' :)
          or $state[$p:l1] = 104                            (: 'let' :)
          or $state[$p:l1] = 122                            (: 'some' :)
          or $state[$p:l1] = 150) then                      (: 'some' :)
      let $state := p:lookahead2W(154, $input, $state)      (: S^WS | EOF | '!=' | '$' | '(' | '(.' | ')' | '*' | '+' |
                                                               ',' | '-' | '/' | '//' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '[' | ']' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7272                                (: 'for' '$' :)
     or $state[$p:lk] = 7290) then                          (: 'let' '$' :)
      let $state := p:parse-FLWORExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7267                           (: 'every' '$' :)
          or $state[$p:lk] = 7318) then                     (: 'some' '$' :)
      let $state := p:parse-QuantifiedExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7840) then                     (: 'typeswitch' '(' :)
      let $state := p:parse-TypeswitchExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 7791) then                     (: 'if' '(' :)
      let $state := p:parse-IfExpr($input, $state)
      return $state
    else if ($state[$p:lk] = 43167) then                    (: 'try' '{' :)
      let $state := p:parse-TryCatchExpr($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-OrExpr($input, $state)
      return $state
  return p:reduce($state, "ExprSingle", $count)
};

(:~
 : Parse OccurrenceIndicator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OccurrenceIndicator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 60) then                            (: '?' :)
      let $state := p:shift(60, $input, $state)             (: '?' :)
      return $state
    else if ($state[$p:l1] = 35) then                       (: '*' :)
      let $state := p:shift(35, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(37, $input, $state)             (: '+' :)
      return $state
  return p:reduce($state, "OccurrenceIndicator", $count)
};

(:~
 : Parse AtomicType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AtomicType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AtomicType", $count)
};

(:~
 : Parse BinaryTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BinaryTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(73, $input, $state)                 (: 'binary' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "BinaryTest", $count)
};

(:~
 : Parse AnyKindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AnyKindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(130, $input, $state)                (: 'node' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "AnyKindTest", $count)
};

(:~
 : Parse TextTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TextTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(155, $input, $state)                (: 'text' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "TextTest", $count)
};

(:~
 : Parse CommentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CommentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(82, $input, $state)                 (: 'comment' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "CommentTest", $count)
};

(:~
 : Parse PITest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PITest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(142, $input, $state)                (: 'processing-instruction' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(133, $input, $state)          (: StringLiteral | S^WS | NCName^Token | '(.' | ')' |
                                                               'and' | 'ascending' | 'case' | 'cast' | 'castable' |
                                                               'collation' | 'default' | 'descending' | 'div' | 'else' |
                                                               'empty' | 'eq' | 'except' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'ne' | 'or' | 'order' | 'return' |
                                                               'satisfies' | 'stable' | 'to' | 'treat' | 'union' |
                                                               'where' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 6) then                         (: StringLiteral :)
          let $state := p:shift(6, $input, $state)          (: StringLiteral :)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-NCName($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "PITest", $count)
};

(:~
 : Parse AttributeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-AttributeName($input, $state)
  return p:reduce($state, "AttributeDeclaration", $count)
};

(:~
 : Parse SchemaAttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaAttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(147, $input, $state)                (: 'schema-attribute' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-AttributeDeclaration($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaAttributeTest", $count)
};

(:~
 : Parse AttributeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "AttributeName", $count)
};

(:~
 : Parse AttribNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttribNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '*' :)
      let $state := p:shift(34, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AttributeName($input, $state)
      return $state
  return p:reduce($state, "AttribNameOrWildcard", $count)
};

(:~
 : Parse AttributeTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-AttributeTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(71, $input, $state)                 (: 'attribute' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-AttribNameOrWildcard($input, $state)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:shift(38, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(167, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "AttributeTest", $count)
};

(:~
 : Parse ElementDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ElementName($input, $state)
  return p:reduce($state, "ElementDeclaration", $count)
};

(:~
 : Parse SchemaElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(148, $input, $state)                (: 'schema-element' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-ElementDeclaration($input, $state)
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "SchemaElementTest", $count)
};

(:~
 : Parse TypeName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "TypeName", $count)
};

(:~
 : Parse ElementName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-QName($input, $state)
  return p:reduce($state, "ElementName", $count)
};

(:~
 : Parse ElementNameOrWildcard.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementNameOrWildcard($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 34) then                            (: '*' :)
      let $state := p:shift(34, $input, $state)             (: '*' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ElementName($input, $state)
      return $state
  return p:reduce($state, "ElementNameOrWildcard", $count)
};

(:~
 : Parse ElementTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ElementTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(93, $input, $state)                 (: 'element' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(172, $input, $state)          (: S^WS | QName^Token | '(.' | ')' | '*' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state := p:parse-ElementNameOrWildcard($input, $state)
      let $state := p:lookahead1W(75, $input, $state)       (: S^WS | '(.' | ')' | ',' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 38) then                   (: ',' :)
          let $state := p:shift(38, $input, $state)         (: ',' :)
          let $state := p:lookahead1W(167, $input, $state)  (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
          let $state := p:parse-TypeName($input, $state)
          let $state := p:lookahead1W(76, $input, $state)   (: S^WS | '(.' | ')' | '?' :)
          let $state :=
            if ($state[$p:error]) then
              $state
            else if ($state[$p:l1] = 60) then               (: '?' :)
              let $state := p:shift(60, $input, $state)     (: '?' :)
              return $state
            else
              $state
          return $state
        else
          $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "ElementTest", $count)
};

(:~
 : Parse DocumentTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DocumentTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(92, $input, $state)                 (: 'document-node' :)
  let $state := p:lookahead1W(29, $input, $state)           (: S^WS | '(' | '(.' :)
  let $state := p:shift(30, $input, $state)                 (: '(' :)
  let $state := p:lookahead1W(106, $input, $state)          (: S^WS | '(.' | ')' | 'element' | 'schema-element' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 33) then                      (: ')' :)
      let $state :=
        if ($state[$p:l1] = 93) then                        (: 'element' :)
          let $state := p:parse-ElementTest($input, $state)
          return $state
        else if ($state[$p:error]) then
          $state
        else
          let $state := p:parse-SchemaElementTest($input, $state)
          return $state
      return $state
    else
      $state
  let $state := p:lookahead1W(30, $input, $state)           (: S^WS | '(.' | ')' :)
  let $state := p:shift(33, $input, $state)                 (: ')' :)
  return p:reduce($state, "DocumentTest", $count)
};

(:~
 : Parse KindTest.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-KindTest($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 92) then                            (: 'document-node' :)
      let $state := p:parse-DocumentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'element' :)
      let $state := p:parse-ElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 71) then                       (: 'attribute' :)
      let $state := p:parse-AttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'schema-element' :)
      let $state := p:parse-SchemaElementTest($input, $state)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'schema-attribute' :)
      let $state := p:parse-SchemaAttributeTest($input, $state)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'processing-instruction' :)
      let $state := p:parse-PITest($input, $state)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:parse-CommentTest($input, $state)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'text' :)
      let $state := p:parse-TextTest($input, $state)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'node' :)
      let $state := p:parse-AnyKindTest($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-BinaryTest($input, $state)
      return $state
  return p:reduce($state, "KindTest", $count)
};

(:~
 : Parse ItemType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ItemType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 71                                  (: 'binary' :)
     or $state[$p:l1] = 73                                  (: 'comment' :)
     or $state[$p:l1] = 82                                  (: 'document-node' :)
     or $state[$p:l1] = 92                                  (: 'element' :)
     or $state[$p:l1] = 93                                  (: 'item' :)
     or $state[$p:l1] = 118                                 (: 'node' :)
     or $state[$p:l1] = 130                                 (: 'processing-instruction' :)
     or $state[$p:l1] = 142                                 (: 'schema-attribute' :)
     or $state[$p:l1] = 147                                 (: 'schema-element' :)
     or $state[$p:l1] = 148                                 (: 'text' :)
     or $state[$p:l1] = 155) then                           (: 'text' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'external' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7751                                (: 'attribute' '(' :)
     or $state[$p:lk] = 7753                                (: 'binary' '(' :)
     or $state[$p:lk] = 7762                                (: 'comment' '(' :)
     or $state[$p:lk] = 7772                                (: 'document-node' '(' :)
     or $state[$p:lk] = 7773                                (: 'element' '(' :)
     or $state[$p:lk] = 7810                                (: 'node' '(' :)
     or $state[$p:lk] = 7822                                (: 'processing-instruction' '(' :)
     or $state[$p:lk] = 7827                                (: 'schema-attribute' '(' :)
     or $state[$p:lk] = 7828                                (: 'schema-element' '(' :)
     or $state[$p:lk] = 7835) then                          (: 'text' '(' :)
      let $state := p:parse-KindTest($input, $state)
      return $state
    else if ($state[$p:lk] = 7798) then                     (: 'item' '(' :)
      let $state := p:shift(118, $input, $state)            (: 'item' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(30, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(33, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-AtomicType($input, $state)
      return $state
  return p:reduce($state, "ItemType", $count)
};

(:~
 : Parse SequenceType.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SequenceType($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(163, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 96) then                            (: 'empty-sequence' :)
      let $state := p:lookahead2W(160, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | ')' | '*' | '*' | '+' |
                                                               '+' | ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' |
                                                               '>' | '>=' | '>>' | '?' | ']' | 'and' | 'ascending' |
                                                               'at' | 'case' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'external' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'in' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'union' | 'where' | '{' | '|' | '}' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 7776) then                          (: 'empty-sequence' '(' :)
      let $state := p:shift(96, $input, $state)             (: 'empty-sequence' :)
      let $state := p:lookahead1W(29, $input, $state)       (: S^WS | '(' | '(.' :)
      let $state := p:shift(30, $input, $state)             (: '(' :)
      let $state := p:lookahead1W(30, $input, $state)       (: S^WS | '(.' | ')' :)
      let $state := p:shift(33, $input, $state)             (: ')' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ItemType($input, $state)
      let $state := p:lookahead1W(157, $input, $state)      (: S^WS | EOF | '!=' | '(.' | ')' | '*' | '*' | '+' | '+' |
                                                               ',' | '-' | ':=' | ';' | '<' | '<<' | '<=' | '=' | '>' |
                                                               '>=' | '>>' | '?' | ']' | 'and' | 'ascending' | 'at' |
                                                               'case' | 'collation' | 'default' | 'descending' | 'div' |
                                                               'else' | 'empty' | 'eq' | 'except' | 'external' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'in' | 'instance' | 'intersect' |
                                                               'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'order' | 'return' | 'satisfies' | 'stable' | 'to' |
                                                               'union' | 'where' | '{' | '|' | '}' :)
      let $state :=
        if ($state[$p:error]) then
          $state
        else if ($state[$p:l1] = 35                         (: '*' :)
              or $state[$p:l1] = 37                         (: '+' :)
              or $state[$p:l1] = 60) then                   (: '?' :)
          let $state := p:parse-OccurrenceIndicator($input, $state)
          return $state
        else
          $state
      return $state
  return p:reduce($state, "SequenceType", $count)
};

(:~
 : Parse TypeDeclaration.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-TypeDeclaration($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(68, $input, $state)                 (: 'as' :)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-SequenceType($input, $state)
  return p:reduce($state, "TypeDeclaration", $count)
};

(:~
 : Parse FunctionName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-FunctionName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(158, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'declare' | 'default' |
                                                               'descendant' | 'descendant-or-self' | 'descending' |
                                                               'div' | 'document' | 'else' | 'empty' | 'eq' | 'every' |
                                                               'except' | 'following' | 'following-sibling' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'import' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' |
                                                               'module' | 'ne' | 'or' | 'order' | 'ordered' | 'parent' |
                                                               'preceding' | 'preceding-sibling' | 'property' |
                                                               'return' | 'satisfies' | 'self' | 'some' | 'stable' |
                                                               'to' | 'treat' | 'try' | 'union' | 'unordered' |
                                                               'validate' | 'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 65) then                            (: 'ancestor' :)
      let $state := p:shift(65, $input, $state)             (: 'ancestor' :)
      return $state
    else if ($state[$p:l1] = 66) then                       (: 'ancestor-or-self' :)
      let $state := p:shift(66, $input, $state)             (: 'ancestor-or-self' :)
      return $state
    else if ($state[$p:l1] = 67) then                       (: 'and' :)
      let $state := p:shift(67, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ascending' :)
      let $state := p:shift(69, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:shift(76, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:shift(77, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:shift(78, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 79) then                       (: 'catch' :)
      let $state := p:shift(79, $input, $state)             (: 'catch' :)
      return $state
    else if ($state[$p:l1] = 80) then                       (: 'child' :)
      let $state := p:shift(80, $input, $state)             (: 'child' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:shift(81, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 85) then                       (: 'declare' :)
      let $state := p:shift(85, $input, $state)             (: 'declare' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'default' :)
      let $state := p:shift(86, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 87) then                       (: 'descendant' :)
      let $state := p:shift(87, $input, $state)             (: 'descendant' :)
      return $state
    else if ($state[$p:l1] = 88) then                       (: 'descendant-or-self' :)
      let $state := p:shift(88, $input, $state)             (: 'descendant-or-self' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'descending' :)
      let $state := p:shift(89, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'div' :)
      let $state := p:shift(90, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 91) then                       (: 'document' :)
      let $state := p:shift(91, $input, $state)             (: 'document' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'else' :)
      let $state := p:shift(94, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'empty' :)
      let $state := p:shift(95, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'eq' :)
      let $state := p:shift(98, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 99) then                       (: 'every' :)
      let $state := p:shift(99, $input, $state)             (: 'every' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'except' :)
      let $state := p:shift(100, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 102) then                      (: 'following' :)
      let $state := p:shift(102, $input, $state)            (: 'following' :)
      return $state
    else if ($state[$p:l1] = 103) then                      (: 'following-sibling' :)
      let $state := p:shift(103, $input, $state)            (: 'following-sibling' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'for' :)
      let $state := p:shift(104, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'ge' :)
      let $state := p:shift(107, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'gt' :)
      let $state := p:shift(109, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'idiv' :)
      let $state := p:shift(110, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 112) then                      (: 'import' :)
      let $state := p:shift(112, $input, $state)            (: 'import' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'instance' :)
      let $state := p:shift(115, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'intersect' :)
      let $state := p:shift(116, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'is' :)
      let $state := p:shift(117, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'le' :)
      let $state := p:shift(120, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'let' :)
      let $state := p:shift(122, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'lt' :)
      let $state := p:shift(123, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'mod' :)
      let $state := p:shift(124, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 125) then                      (: 'module' :)
      let $state := p:shift(125, $input, $state)            (: 'module' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'ne' :)
      let $state := p:shift(127, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'or' :)
      let $state := p:shift(133, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'order' :)
      let $state := p:shift(134, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 135) then                      (: 'ordered' :)
      let $state := p:shift(135, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:l1] = 137) then                      (: 'parent' :)
      let $state := p:shift(137, $input, $state)            (: 'parent' :)
      return $state
    else if ($state[$p:l1] = 138) then                      (: 'preceding' :)
      let $state := p:shift(138, $input, $state)            (: 'preceding' :)
      return $state
    else if ($state[$p:l1] = 139) then                      (: 'preceding-sibling' :)
      let $state := p:shift(139, $input, $state)            (: 'preceding-sibling' :)
      return $state
    else if ($state[$p:l1] = 143) then                      (: 'property' :)
      let $state := p:shift(143, $input, $state)            (: 'property' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'return' :)
      let $state := p:shift(144, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'satisfies' :)
      let $state := p:shift(145, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 149) then                      (: 'self' :)
      let $state := p:shift(149, $input, $state)            (: 'self' :)
      return $state
    else if ($state[$p:l1] = 150) then                      (: 'some' :)
      let $state := p:shift(150, $input, $state)            (: 'some' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'stable' :)
      let $state := p:shift(151, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'to' :)
      let $state := p:shift(157, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'treat' :)
      let $state := p:shift(158, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 159) then                      (: 'try' :)
      let $state := p:shift(159, $input, $state)            (: 'try' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'union' :)
      let $state := p:shift(161, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 162) then                      (: 'unordered' :)
      let $state := p:shift(162, $input, $state)            (: 'unordered' :)
      return $state
    else if ($state[$p:l1] = 163) then                      (: 'validate' :)
      let $state := p:shift(163, $input, $state)            (: 'validate' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'where' :)
      let $state := p:shift(166, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:l1] = 167) then                      (: 'xquery' :)
      let $state := p:shift(167, $input, $state)            (: 'xquery' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(17, $input, $state)             (: QName^Token :)
      return $state
  return p:reduce($state, "FunctionName", $count)
};

(:~
 : Parse QName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-QName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(163, $input, $state)           (: QName^Token | 'ancestor' | 'ancestor-or-self' | 'and' |
                                                               'ascending' | 'attribute' | 'binary' | 'case' | 'cast' |
                                                               'castable' | 'catch' | 'child' | 'collation' |
                                                               'comment' | 'declare' | 'default' | 'descendant' |
                                                               'descendant-or-self' | 'descending' | 'div' |
                                                               'document' | 'document-node' | 'element' | 'else' |
                                                               'empty' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                               'following' | 'following-sibling' | 'for' | 'ge' | 'gt' |
                                                               'idiv' | 'if' | 'import' | 'instance' | 'intersect' |
                                                               'is' | 'item' | 'le' | 'let' | 'lt' | 'mod' | 'module' |
                                                               'namespace' | 'ne' | 'node' | 'or' | 'order' |
                                                               'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 71) then                            (: 'attribute' :)
      let $state := p:shift(71, $input, $state)             (: 'attribute' :)
      return $state
    else if ($state[$p:l1] = 126) then                      (: 'namespace' :)
      let $state := p:shift(126, $input, $state)            (: 'namespace' :)
      return $state
    else if ($state[$p:l1] = 73) then                       (: 'binary' :)
      let $state := p:shift(73, $input, $state)             (: 'binary' :)
      return $state
    else if ($state[$p:l1] = 82) then                       (: 'comment' :)
      let $state := p:shift(82, $input, $state)             (: 'comment' :)
      return $state
    else if ($state[$p:l1] = 92) then                       (: 'document-node' :)
      let $state := p:shift(92, $input, $state)             (: 'document-node' :)
      return $state
    else if ($state[$p:l1] = 93) then                       (: 'element' :)
      let $state := p:shift(93, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:l1] = 96) then                       (: 'empty-sequence' :)
      let $state := p:shift(96, $input, $state)             (: 'empty-sequence' :)
      return $state
    else if ($state[$p:l1] = 111) then                      (: 'if' :)
      let $state := p:shift(111, $input, $state)            (: 'if' :)
      return $state
    else if ($state[$p:l1] = 118) then                      (: 'item' :)
      let $state := p:shift(118, $input, $state)            (: 'item' :)
      return $state
    else if ($state[$p:l1] = 130) then                      (: 'node' :)
      let $state := p:shift(130, $input, $state)            (: 'node' :)
      return $state
    else if ($state[$p:l1] = 142) then                      (: 'processing-instruction' :)
      let $state := p:shift(142, $input, $state)            (: 'processing-instruction' :)
      return $state
    else if ($state[$p:l1] = 147) then                      (: 'schema-attribute' :)
      let $state := p:shift(147, $input, $state)            (: 'schema-attribute' :)
      return $state
    else if ($state[$p:l1] = 148) then                      (: 'schema-element' :)
      let $state := p:shift(148, $input, $state)            (: 'schema-element' :)
      return $state
    else if ($state[$p:l1] = 155) then                      (: 'text' :)
      let $state := p:shift(155, $input, $state)            (: 'text' :)
      return $state
    else if ($state[$p:l1] = 160) then                      (: 'typeswitch' :)
      let $state := p:shift(160, $input, $state)            (: 'typeswitch' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-FunctionName($input, $state)
      return $state
  return p:reduce($state, "QName", $count)
};

(:~
 : Parse VarDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VarDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(102, $input, $state)          (: S^WS | '(.' | 'private' | 'variable' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 141) then                      (: 'private' :)
      let $state := p:shift(141, $input, $state)            (: 'private' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(62, $input, $state)           (: S^WS | '(.' | 'variable' :)
  let $state := p:shift(164, $input, $state)                (: 'variable' :)
  let $state := p:lookahead1W(28, $input, $state)           (: S^WS | '$' | '(.' :)
  let $state := p:shift(28, $input, $state)                 (: '$' :)
  let $state := p:lookahead1W(167, $input, $state)          (: S^WS | QName^Token | '(.' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state := p:parse-QName($input, $state)
  let $state := p:lookahead1W(108, $input, $state)          (: S^WS | '(.' | ':=' | 'as' | 'external' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 68) then                       (: 'as' :)
      let $state := p:parse-TypeDeclaration($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(81, $input, $state)           (: S^WS | '(.' | ':=' | 'external' :)
  let $state :=
    if ($state[$p:l1] = 48) then                            (: ':=' :)
      let $state := p:shift(48, $input, $state)             (: ':=' :)
      let $state := p:lookahead1W(22, $input, $state)       (: EPSILON | S^WS | '(.' :)
      let $state := p:parse-ExprSingle($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(101, $input, $state)            (: 'external' :)
      return $state
  return p:reduce($state, "VarDecl", $count)
};

(:~
 : Parse ImportStylesheetDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ImportStylesheetDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(112, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(60, $input, $state)           (: S^WS | '(.' | 'stylesheet' :)
  let $state := p:shift(154, $input, $state)                (: 'stylesheet' :)
  let $state := p:lookahead1W(38, $input, $state)           (: S^WS | '(.' | 'at' :)
  let $state := p:shift(70, $input, $state)                 (: 'at' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "ImportStylesheetDecl", $count)
};

(:~
 : Parse the 1st loop of production ModuleImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | '(.' | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(24, $input, $state)     (: StringLiteral | S^WS | '(.' :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-ModuleImport-1($input, $state)
};

(:~
 : Parse ModuleImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(112, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(52, $input, $state)           (: S^WS | '(.' | 'module' :)
  let $state := p:shift(125, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(67, $input, $state)           (: StringLiteral | S^WS | '(.' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 126) then                      (: 'namespace' :)
      let $state := p:shift(126, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(131, $input, $state)      (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | '(.' | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:shift(70, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-ModuleImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "ModuleImport", $count)
};

(:~
 : Parse SchemaPrefix.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaPrefix($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 126) then                           (: 'namespace' :)
      let $state := p:shift(126, $input, $state)            (: 'namespace' :)
      let $state := p:lookahead1W(131, $input, $state)      (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
      let $state := p:parse-NCName($input, $state)
      let $state := p:lookahead1W(35, $input, $state)       (: S^WS | '(.' | '=' :)
      let $state := p:shift(56, $input, $state)             (: '=' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(86, $input, $state)             (: 'default' :)
      let $state := p:lookahead1W(47, $input, $state)       (: S^WS | '(.' | 'element' :)
      let $state := p:shift(93, $input, $state)             (: 'element' :)
      let $state := p:lookahead1W(53, $input, $state)       (: S^WS | '(.' | 'namespace' :)
      let $state := p:shift(126, $input, $state)            (: 'namespace' :)
      return $state
  return p:reduce($state, "SchemaPrefix", $count)
};

(:~
 : Parse the 1st loop of production SchemaImport (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(77, $input, $state)         (: S^WS | '(.' | ',' | ';' :)
    return
      if ($state[$p:l1] != 38) then                         (: ',' :)
        $state
      else
        let $state := p:shift(38, $input, $state)           (: ',' :)
        let $state := p:lookahead1W(24, $input, $state)     (: StringLiteral | S^WS | '(.' :)
        let $state := p:parse-URILiteral($input, $state)
        return p:parse-SchemaImport-1($input, $state)
};

(:~
 : Parse SchemaImport.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-SchemaImport($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(112, $input, $state)                (: 'import' :)
  let $state := p:lookahead1W(59, $input, $state)           (: S^WS | '(.' | 'schema' :)
  let $state := p:shift(146, $input, $state)                (: 'schema' :)
  let $state := p:lookahead1W(103, $input, $state)          (: StringLiteral | S^WS | '(.' | 'default' | 'namespace' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] != 6) then                       (: StringLiteral :)
      let $state := p:parse-SchemaPrefix($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(82, $input, $state)           (: S^WS | '(.' | ';' | 'at' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 70) then                       (: 'at' :)
      let $state := p:shift(70, $input, $state)             (: 'at' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:parse-URILiteral($input, $state)
      let $state := p:parse-SchemaImport-1($input, $state)
      return $state
    else
      $state
  return p:reduce($state, "SchemaImport", $count)
};

(:~
 : Parse Import.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Import($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 112) then                           (: 'import' :)
      let $state := p:lookahead2W(112, $input, $state)      (: S^WS | '(.' | 'module' | 'schema' | 'stylesheet' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 37488) then                         (: 'import' 'schema' :)
      let $state := p:parse-SchemaImport($input, $state)
      return $state
    else if ($state[$p:lk] = 32112) then                    (: 'import' 'module' :)
      let $state := p:parse-ModuleImport($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-ImportStylesheetDecl($input, $state)
      return $state
  return p:reduce($state, "Import", $count)
};

(:~
 : Parse NamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(126, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | '(.' | '=' :)
  let $state := p:shift(56, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "NamespaceDecl", $count)
};

(:~
 : Parse InheritMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-InheritMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(20, $input, $state)            (: 'inherit' | 'no-inherit' :)
  let $state :=
    if ($state[$p:l1] = 114) then                           (: 'inherit' :)
      let $state := p:shift(114, $input, $state)            (: 'inherit' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(128, $input, $state)            (: 'no-inherit' :)
      return $state
  return p:reduce($state, "InheritMode", $count)
};

(:~
 : Parse PreserveMode.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-PreserveMode($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(21, $input, $state)            (: 'no-preserve' | 'preserve' :)
  let $state :=
    if ($state[$p:l1] = 140) then                           (: 'preserve' :)
      let $state := p:shift(140, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(129, $input, $state)            (: 'no-preserve' :)
      return $state
  return p:reduce($state, "PreserveMode", $count)
};

(:~
 : Parse CopyNamespacesDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-CopyNamespacesDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(45, $input, $state)           (: S^WS | '(.' | 'copy-namespaces' :)
  let $state := p:shift(84, $input, $state)                 (: 'copy-namespaces' :)
  let $state := p:lookahead1W(97, $input, $state)           (: S^WS | '(.' | 'no-preserve' | 'preserve' :)
  let $state := p:parse-PreserveMode($input, $state)
  let $state := p:lookahead1W(31, $input, $state)           (: S^WS | '(.' | ',' :)
  let $state := p:shift(38, $input, $state)                 (: ',' :)
  let $state := p:lookahead1W(96, $input, $state)           (: S^WS | '(.' | 'inherit' | 'no-inherit' :)
  let $state := p:parse-InheritMode($input, $state)
  return p:reduce($state, "CopyNamespacesDecl", $count)
};

(:~
 : Parse EmptyOrderDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-EmptyOrderDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(86, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(56, $input, $state)           (: S^WS | '(.' | 'order' :)
  let $state := p:shift(134, $input, $state)                (: 'order' :)
  let $state := p:lookahead1W(49, $input, $state)           (: S^WS | '(.' | 'empty' :)
  let $state := p:shift(95, $input, $state)                 (: 'empty' :)
  let $state := p:lookahead1W(95, $input, $state)           (: S^WS | '(.' | 'greatest' | 'least' :)
  let $state :=
    if ($state[$p:l1] = 108) then                           (: 'greatest' :)
      let $state := p:shift(108, $input, $state)            (: 'greatest' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(121, $input, $state)            (: 'least' :)
      return $state
  return p:reduce($state, "EmptyOrderDecl", $count)
};

(:~
 : Parse OrderingModeDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-OrderingModeDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(57, $input, $state)           (: S^WS | '(.' | 'ordering' :)
  let $state := p:shift(136, $input, $state)                (: 'ordering' :)
  let $state := p:lookahead1W(100, $input, $state)          (: S^WS | '(.' | 'ordered' | 'unordered' :)
  let $state :=
    if ($state[$p:l1] = 135) then                           (: 'ordered' :)
      let $state := p:shift(135, $input, $state)            (: 'ordered' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(162, $input, $state)            (: 'unordered' :)
      return $state
  return p:reduce($state, "OrderingModeDecl", $count)
};

(:~
 : Parse ConstructionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ConstructionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(44, $input, $state)           (: S^WS | '(.' | 'construction' :)
  let $state := p:shift(83, $input, $state)                 (: 'construction' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | '(.' | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 153) then                           (: 'strip' :)
      let $state := p:shift(153, $input, $state)            (: 'strip' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(140, $input, $state)            (: 'preserve' :)
      return $state
  return p:reduce($state, "ConstructionDecl", $count)
};

(:~
 : Parse BaseURIDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BaseURIDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(39, $input, $state)           (: S^WS | '(.' | 'base-uri' :)
  let $state := p:shift(72, $input, $state)                 (: 'base-uri' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "BaseURIDecl", $count)
};

(:~
 : Parse DefaultCollationDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultCollationDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(86, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(43, $input, $state)           (: S^WS | '(.' | 'collation' :)
  let $state := p:shift(81, $input, $state)                 (: 'collation' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "DefaultCollationDecl", $count)
};

(:~
 : Parse BoundarySpaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-BoundarySpaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(40, $input, $state)           (: S^WS | '(.' | 'boundary-space' :)
  let $state := p:shift(74, $input, $state)                 (: 'boundary-space' :)
  let $state := p:lookahead1W(101, $input, $state)          (: S^WS | '(.' | 'preserve' | 'strip' :)
  let $state :=
    if ($state[$p:l1] = 140) then                           (: 'preserve' :)
      let $state := p:shift(140, $input, $state)            (: 'preserve' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(153, $input, $state)            (: 'strip' :)
      return $state
  return p:reduce($state, "BoundarySpaceDecl", $count)
};

(:~
 : Parse Setter.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Setter($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state :=
    if ($state[$p:l1] = 85) then                            (: 'declare' :)
      let $state := p:lookahead2W(123, $input, $state)      (: S^WS | '(.' | 'base-uri' | 'boundary-space' |
                                                               'construction' | 'copy-namespaces' | 'default' |
                                                               'ordering' :)
      let $state :=
        if ($state[$p:lk] = 22101) then                     (: 'declare' 'default' :)
          let $state := p:lookahead3W(89, $input, $state)   (: S^WS | '(.' | 'collation' | 'order' :)
          return $state
        else
          $state
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 19029) then                         (: 'declare' 'boundary-space' :)
      let $state := p:parse-BoundarySpaceDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 5330517) then                  (: 'declare' 'default' 'collation' :)
      let $state := p:parse-DefaultCollationDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 18517) then                    (: 'declare' 'base-uri' :)
      let $state := p:parse-BaseURIDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 21333) then                    (: 'declare' 'construction' :)
      let $state := p:parse-ConstructionDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 34901) then                    (: 'declare' 'ordering' :)
      let $state := p:parse-OrderingModeDecl($input, $state)
      return $state
    else if ($state[$p:lk] = 8803925) then                  (: 'declare' 'default' 'order' :)
      let $state := p:parse-EmptyOrderDecl($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-CopyNamespacesDecl($input, $state)
      return $state
  return p:reduce($state, "Setter", $count)
};

(:~
 : Parse DefaultNamespaceDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-DefaultNamespaceDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(85, $input, $state)                 (: 'declare' :)
  let $state := p:lookahead1W(46, $input, $state)           (: S^WS | '(.' | 'default' :)
  let $state := p:shift(86, $input, $state)                 (: 'default' :)
  let $state := p:lookahead1W(90, $input, $state)           (: S^WS | '(.' | 'element' | 'function' :)
  let $state :=
    if ($state[$p:l1] = 93) then                            (: 'element' :)
      let $state := p:shift(93, $input, $state)             (: 'element' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(106, $input, $state)            (: 'function' :)
      return $state
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(126, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  return p:reduce($state, "DefaultNamespaceDecl", $count)
};

(:~
 : Parse the 1st loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-1($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(175, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '$' | '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 85) then                          (: 'declare' :)
        let $state := p:lookahead2W(145, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'base-uri' | 'boundary-space' |
                                                               'cast' | 'castable' | 'construction' |
                                                               'copy-namespaces' | 'default' | 'div' | 'eq' | 'except' |
                                                               'function' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'option' | 'or' | 'ordering' | 'private' | 'to' |
                                                               'treat' | 'union' | 'variable' | '|' :)
        return $state
      else if ($state[$p:l1] = 112) then                    (: 'import' :)
        let $state := p:lookahead2W(139, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'module' |
                                                               'ne' | 'or' | 'schema' | 'stylesheet' | 'to' | 'treat' |
                                                               'union' | '|' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 18517                            (: 'declare' 'base-uri' :)
      and $state[$p:lk] != 19029                            (: 'declare' 'boundary-space' :)
      and $state[$p:lk] != 21333                            (: 'declare' 'construction' :)
      and $state[$p:lk] != 21589                            (: 'declare' 'copy-namespaces' :)
      and $state[$p:lk] != 22101                            (: 'declare' 'default' :)
      and $state[$p:lk] != 32112                            (: 'import' 'module' :)
      and $state[$p:lk] != 32341                            (: 'declare' 'namespace' :)
      and $state[$p:lk] != 34901                            (: 'declare' 'ordering' :)
      and $state[$p:lk] != 37488                            (: 'import' 'schema' :)
      and $state[$p:lk] != 39536) then                      (: 'import' 'stylesheet' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 85) then                      (: 'declare' :)
            let $state := p:lookahead2W(126, $input, $state) (: S^WS | '(.' | 'base-uri' | 'boundary-space' |
                                                                'construction' | 'copy-namespaces' | 'default' |
                                                                'namespace' | 'ordering' :)
            let $state :=
              if ($state[$p:lk] = 22101) then               (: 'declare' 'default' :)
                let $state := p:lookahead3W(115, $input, $state) (: S^WS | '(.' | 'collation' | 'element' | 'function' |
                                                                    'order' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 6116949                       (: 'declare' 'default' 'element' :)
           or $state[$p:lk] = 6968917) then                 (: 'declare' 'default' 'function' :)
            let $state := p:parse-DefaultNamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 32341) then              (: 'declare' 'namespace' :)
            let $state := p:parse-NamespaceDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 112) then                (: 'import' :)
            let $state := p:parse-Import($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-Setter($input, $state)
            return $state
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | '(.' | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-1($input, $state)
};

(:~
 : Parse the 2nd loop of production Prolog (zero or more). Use
 : tail recursion for iteratively updating the parser state.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog-2($input as xs:string, $state as item()+) as item()+
{
  if ($state[$p:error]) then
    $state
  else
    let $state := p:lookahead1W(175, $input, $state)        (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | EOF |
                                                               '$' | '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' |
                                                               '//' | '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
    let $state :=
      if ($state[$p:l1] = 85) then                          (: 'declare' :)
        let $state := p:lookahead2W(140, $input, $state)    (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                               'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' |
                                                               'ne' | 'option' | 'or' | 'private' | 'to' | 'treat' |
                                                               'union' | 'variable' | '|' :)
        return $state
      else
        ($state[$p:l1], $state[position() > $p:lk])
    return
      if ($state[$p:lk] != 27221                            (: 'declare' 'function' :)
      and $state[$p:lk] != 33877                            (: 'declare' 'option' :)
      and $state[$p:lk] != 36181                            (: 'declare' 'private' :)
      and $state[$p:lk] != 42069) then                      (: 'declare' 'variable' :)
        $state
      else
        let $state :=
          if ($state[$p:l1] = 85) then                      (: 'declare' :)
            let $state := p:lookahead2W(116, $input, $state) (: S^WS | '(.' | 'function' | 'option' | 'private' |
                                                                'variable' :)
            let $state :=
              if ($state[$p:lk] = 36181) then               (: 'declare' 'private' :)
                let $state := p:lookahead3W(94, $input, $state) (: S^WS | '(.' | 'function' | 'variable' :)
                return $state
              else
                $state
            return $state
          else
            ($state[$p:l1], $state[position() > $p:lk])
        let $state :=
          if ($state[$p:lk] = 42069                         (: 'declare' 'variable' :)
           or $state[$p:lk] = 10784085) then                (: 'declare' 'private' 'variable' :)
            let $state := p:parse-VarDecl($input, $state)
            return $state
          else if ($state[$p:lk] = 33877) then              (: 'declare' 'option' :)
            let $state := p:parse-OptionDecl($input, $state)
            return $state
          else if ($state[$p:error]) then
            $state
          else
            let $state := p:parse-FunctionDecl($input, $state)
            return $state
        let $state := p:lookahead1W(34, $input, $state)     (: S^WS | '(.' | ';' :)
        let $state := p:parse-Separator($input, $state)
        return p:parse-Prolog-2($input, $state)
};

(:~
 : Parse Prolog.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Prolog($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-Prolog-1($input, $state)
  let $state := p:parse-Prolog-2($input, $state)
  return p:reduce($state, "Prolog", $count)
};

(:~
 : Parse URILiteral.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-URILiteral($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  return p:reduce($state, "URILiteral", $count)
};

(:~
 : Parse NCName.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-NCName($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(130, $input, $state)           (: NCName^Token | 'and' | 'ascending' | 'case' | 'cast' |
                                                               'castable' | 'collation' | 'default' | 'descending' |
                                                               'div' | 'else' | 'empty' | 'eq' | 'except' | 'for' |
                                                               'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                               'le' | 'let' | 'lt' | 'mod' | 'ne' | 'or' | 'order' |
                                                               'return' | 'satisfies' | 'stable' | 'to' | 'treat' |
                                                               'union' | 'where' :)
  let $state :=
    if ($state[$p:l1] = 67) then                            (: 'and' :)
      let $state := p:shift(67, $input, $state)             (: 'and' :)
      return $state
    else if ($state[$p:l1] = 69) then                       (: 'ascending' :)
      let $state := p:shift(69, $input, $state)             (: 'ascending' :)
      return $state
    else if ($state[$p:l1] = 76) then                       (: 'case' :)
      let $state := p:shift(76, $input, $state)             (: 'case' :)
      return $state
    else if ($state[$p:l1] = 77) then                       (: 'cast' :)
      let $state := p:shift(77, $input, $state)             (: 'cast' :)
      return $state
    else if ($state[$p:l1] = 78) then                       (: 'castable' :)
      let $state := p:shift(78, $input, $state)             (: 'castable' :)
      return $state
    else if ($state[$p:l1] = 81) then                       (: 'collation' :)
      let $state := p:shift(81, $input, $state)             (: 'collation' :)
      return $state
    else if ($state[$p:l1] = 86) then                       (: 'default' :)
      let $state := p:shift(86, $input, $state)             (: 'default' :)
      return $state
    else if ($state[$p:l1] = 89) then                       (: 'descending' :)
      let $state := p:shift(89, $input, $state)             (: 'descending' :)
      return $state
    else if ($state[$p:l1] = 90) then                       (: 'div' :)
      let $state := p:shift(90, $input, $state)             (: 'div' :)
      return $state
    else if ($state[$p:l1] = 94) then                       (: 'else' :)
      let $state := p:shift(94, $input, $state)             (: 'else' :)
      return $state
    else if ($state[$p:l1] = 95) then                       (: 'empty' :)
      let $state := p:shift(95, $input, $state)             (: 'empty' :)
      return $state
    else if ($state[$p:l1] = 98) then                       (: 'eq' :)
      let $state := p:shift(98, $input, $state)             (: 'eq' :)
      return $state
    else if ($state[$p:l1] = 100) then                      (: 'except' :)
      let $state := p:shift(100, $input, $state)            (: 'except' :)
      return $state
    else if ($state[$p:l1] = 104) then                      (: 'for' :)
      let $state := p:shift(104, $input, $state)            (: 'for' :)
      return $state
    else if ($state[$p:l1] = 107) then                      (: 'ge' :)
      let $state := p:shift(107, $input, $state)            (: 'ge' :)
      return $state
    else if ($state[$p:l1] = 109) then                      (: 'gt' :)
      let $state := p:shift(109, $input, $state)            (: 'gt' :)
      return $state
    else if ($state[$p:l1] = 110) then                      (: 'idiv' :)
      let $state := p:shift(110, $input, $state)            (: 'idiv' :)
      return $state
    else if ($state[$p:l1] = 115) then                      (: 'instance' :)
      let $state := p:shift(115, $input, $state)            (: 'instance' :)
      return $state
    else if ($state[$p:l1] = 116) then                      (: 'intersect' :)
      let $state := p:shift(116, $input, $state)            (: 'intersect' :)
      return $state
    else if ($state[$p:l1] = 117) then                      (: 'is' :)
      let $state := p:shift(117, $input, $state)            (: 'is' :)
      return $state
    else if ($state[$p:l1] = 120) then                      (: 'le' :)
      let $state := p:shift(120, $input, $state)            (: 'le' :)
      return $state
    else if ($state[$p:l1] = 122) then                      (: 'let' :)
      let $state := p:shift(122, $input, $state)            (: 'let' :)
      return $state
    else if ($state[$p:l1] = 123) then                      (: 'lt' :)
      let $state := p:shift(123, $input, $state)            (: 'lt' :)
      return $state
    else if ($state[$p:l1] = 124) then                      (: 'mod' :)
      let $state := p:shift(124, $input, $state)            (: 'mod' :)
      return $state
    else if ($state[$p:l1] = 127) then                      (: 'ne' :)
      let $state := p:shift(127, $input, $state)            (: 'ne' :)
      return $state
    else if ($state[$p:l1] = 133) then                      (: 'or' :)
      let $state := p:shift(133, $input, $state)            (: 'or' :)
      return $state
    else if ($state[$p:l1] = 134) then                      (: 'order' :)
      let $state := p:shift(134, $input, $state)            (: 'order' :)
      return $state
    else if ($state[$p:l1] = 144) then                      (: 'return' :)
      let $state := p:shift(144, $input, $state)            (: 'return' :)
      return $state
    else if ($state[$p:l1] = 145) then                      (: 'satisfies' :)
      let $state := p:shift(145, $input, $state)            (: 'satisfies' :)
      return $state
    else if ($state[$p:l1] = 151) then                      (: 'stable' :)
      let $state := p:shift(151, $input, $state)            (: 'stable' :)
      return $state
    else if ($state[$p:l1] = 157) then                      (: 'to' :)
      let $state := p:shift(157, $input, $state)            (: 'to' :)
      return $state
    else if ($state[$p:l1] = 158) then                      (: 'treat' :)
      let $state := p:shift(158, $input, $state)            (: 'treat' :)
      return $state
    else if ($state[$p:l1] = 161) then                      (: 'union' :)
      let $state := p:shift(161, $input, $state)            (: 'union' :)
      return $state
    else if ($state[$p:l1] = 166) then                      (: 'where' :)
      let $state := p:shift(166, $input, $state)            (: 'where' :)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:shift(16, $input, $state)             (: NCName^Token :)
      return $state
  return p:reduce($state, "NCName", $count)
};

(:~
 : Parse ModuleDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-ModuleDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1(12, $input, $state)            (: 'module' :)
  let $state := p:shift(125, $input, $state)                (: 'module' :)
  let $state := p:lookahead1W(53, $input, $state)           (: S^WS | '(.' | 'namespace' :)
  let $state := p:shift(126, $input, $state)                (: 'namespace' :)
  let $state := p:lookahead1W(131, $input, $state)          (: S^WS | NCName^Token | '(.' | 'and' | 'ascending' |
                                                               'case' | 'cast' | 'castable' | 'collation' | 'default' |
                                                               'descending' | 'div' | 'else' | 'empty' | 'eq' |
                                                               'except' | 'for' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'let' | 'lt' | 'mod' | 'ne' |
                                                               'or' | 'order' | 'return' | 'satisfies' | 'stable' |
                                                               'to' | 'treat' | 'union' | 'where' :)
  let $state := p:parse-NCName($input, $state)
  let $state := p:lookahead1W(35, $input, $state)           (: S^WS | '(.' | '=' :)
  let $state := p:shift(56, $input, $state)                 (: '=' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:parse-URILiteral($input, $state)
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | '(.' | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "ModuleDecl", $count)
};

(:~
 : Parse LibraryModule.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-LibraryModule($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:parse-ModuleDecl($input, $state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Prolog($input, $state)
  return p:reduce($state, "LibraryModule", $count)
};

(:~
 : Parse Separator.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Separator($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(49, $input, $state)                 (: ';' :)
  return p:reduce($state, "Separator", $count)
};

(:~
 : Parse VersionDecl.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-VersionDecl($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:shift(167, $input, $state)                (: 'xquery' :)
  let $state := p:lookahead1W(63, $input, $state)           (: S^WS | '(.' | 'version' :)
  let $state := p:shift(165, $input, $state)                (: 'version' :)
  let $state := p:lookahead1W(24, $input, $state)           (: StringLiteral | S^WS | '(.' :)
  let $state := p:shift(6, $input, $state)                  (: StringLiteral :)
  let $state := p:lookahead1W(83, $input, $state)           (: S^WS | '(.' | ';' | 'encoding' :)
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:l1] = 97) then                       (: 'encoding' :)
      let $state := p:shift(97, $input, $state)             (: 'encoding' :)
      let $state := p:lookahead1W(24, $input, $state)       (: StringLiteral | S^WS | '(.' :)
      let $state := p:shift(6, $input, $state)              (: StringLiteral :)
      return $state
    else
      $state
  let $state := p:lookahead1W(34, $input, $state)           (: S^WS | '(.' | ';' :)
  let $state := p:parse-Separator($input, $state)
  return p:reduce($state, "VersionDecl", $count)
};

(:~
 : Parse Module.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-Module($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(174, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 167) then                           (: 'xquery' :)
      let $state := p:lookahead2W(137, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                               'to' | 'treat' | 'union' | 'version' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:error]) then
      $state
    else if ($state[$p:lk] = 42407) then                    (: 'xquery' 'version' :)
      let $state := p:parse-VersionDecl($input, $state)
      return $state
    else
      $state
  let $state := p:lookahead1W(174, $input, $state)          (: IntegerLiteral | DecimalLiteral | DoubleLiteral |
                                                               StringLiteral | S^WS | QName^Token | Wildcard | '$' |
                                                               '(' | '(#' | '(.' | '+' | '-' | '.' | '..' | '/' | '//' |
                                                               '<' | '<!--' | '<?' | '@' | 'ancestor' |
                                                               'ancestor-or-self' | 'and' | 'ascending' | 'attribute' |
                                                               'binary' | 'case' | 'cast' | 'castable' | 'catch' |
                                                               'child' | 'collation' | 'comment' | 'declare' |
                                                               'default' | 'descendant' | 'descendant-or-self' |
                                                               'descending' | 'div' | 'document' | 'document-node' |
                                                               'element' | 'else' | 'empty' | 'empty-sequence' | 'eq' |
                                                               'every' | 'except' | 'following' | 'following-sibling' |
                                                               'for' | 'ge' | 'gt' | 'idiv' | 'if' | 'import' |
                                                               'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' |
                                                               'lt' | 'mod' | 'module' | 'namespace' | 'ne' | 'node' |
                                                               'or' | 'order' | 'ordered' | 'parent' | 'preceding' |
                                                               'preceding-sibling' | 'processing-instruction' |
                                                               'property' | 'return' | 'satisfies' |
                                                               'schema-attribute' | 'schema-element' | 'self' | 'some' |
                                                               'stable' | 'text' | 'to' | 'treat' | 'try' |
                                                               'typeswitch' | 'union' | 'unordered' | 'validate' |
                                                               'where' | 'xquery' :)
  let $state :=
    if ($state[$p:l1] = 125) then                           (: 'module' :)
      let $state := p:lookahead2W(136, $input, $state)      (: S^WS | EOF | '!=' | '(' | '(.' | '*' | '+' | ',' | '-' |
                                                               '/' | '//' | ';' | '<' | '<<' | '<=' | '=' | '>' | '>=' |
                                                               '>>' | '[' | 'and' | 'cast' | 'castable' | 'div' | 'eq' |
                                                               'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                               'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'namespace' |
                                                               'ne' | 'or' | 'to' | 'treat' | 'union' | '|' :)
      return $state
    else
      ($state[$p:l1], $state[position() > $p:lk])
  let $state :=
    if ($state[$p:lk] = 32381) then                         (: 'module' 'namespace' :)
      let $state := p:parse-LibraryModule($input, $state)
      return $state
    else if ($state[$p:error]) then
      $state
    else
      let $state := p:parse-MainModuleSequence($input, $state)
      return $state
  return p:reduce($state, "Module", $count)
};

(:~
 : Parse XQuery.
 :
 : @param $input the input string.
 : @param $state the parser state.
 : @return the updated parser state.
 :)
declare function p:parse-XQuery($input as xs:string, $state as item()+) as item()+
{
  let $count := count($state)
  let $state := p:lookahead1W(22, $input, $state)           (: EPSILON | S^WS | '(.' :)
  let $state := p:parse-Module($input, $state)
  let $state := p:lookahead1W(27, $input, $state)           (: S^WS | EOF | '(.' :)
  let $state := p:shift(24, $input, $state)                 (: EOF :)
  return p:reduce($state, "XQuery", $count)
};

(:~
 : Parse start symbol XQuery from given string.
 :
 : @param $s the string to be parsed.
 : @return the result as generated by parser actions.
 :)
declare function p:parse-XQuery($s as xs:string) as item()*
{
  let $input-cp := xdmp:set($input-cp,fn:string-to-codepoints($s))
  let $state := p:parse-XQuery($s, (0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, false()))
  let $error := $state[$p:error]
  let $parse := 
    if ($error) then
      element ERROR {$error/@*, p:error-message($s, $error)}
    else
      $state[position() >= $p:result]
  return
    $parse
};
(:Cleans up Parse Tree to be more tight:)
declare function p:cleanup($p as node())
{
   typeswitch($p) 
     case document-node() return document {for $n in $p/node() return $n}
     case element(Expr) return for $n in $p/node() return p:cleanup($n)
     case element(ExprSingle) return for $n in $p/node() return p:cleanup($n)
     case element(OrExpr) return for $n in $p/node() return p:cleanup($n)
     case element(AndExpr) return for $n in $p/node() return p:cleanup($n)
     case element() return 
        element {fn:node-name($p)}
        {
           $p/@*,
           for $n in $p/node() return p:cleanup($n)
        }
     default return $p
};

(: End :)
